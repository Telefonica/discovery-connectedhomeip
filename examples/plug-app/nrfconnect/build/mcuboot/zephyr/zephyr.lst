
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

00000000 <_vector_table>:
   0:	80 3f 00 20 59 13 00 00 e1 53 00 00 2d 13 00 00     .?. Y....S..-...
  10:	2d 13 00 00 2d 13 00 00 2d 13 00 00 00 00 00 00     -...-...-.......
	...
  2c:	95 10 00 00 2d 13 00 00 00 00 00 00 2d 13 00 00     ....-.......-...
  3c:	2d 13 00 00                                         -...

00000040 <_irq_vector_table>:
  40:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  50:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  60:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  70:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  80:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  90:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  a0:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  b0:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  c0:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  d0:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  e0:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................
  f0:	15 11 00 00 15 11 00 00 15 11 00 00 15 11 00 00     ................

Disassembly of section text:

00000100 <main>:
    return detect_value == expected;
}
#endif

void main(void)
{
     100:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
}

NRF_STATIC_INLINE void nrf_wdt_reload_request_set(NRF_WDT_Type *        p_reg,
                                                  nrf_wdt_rr_register_t rr_register)
{
    p_reg->RR[rr_register] = NRF_WDT_RR_VALUE;
     102:	4b21      	ldr	r3, [pc, #132]	; (188 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x1b>)
     104:	4a21      	ldr	r2, [pc, #132]	; (18c <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x1f>)
     106:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
     10a:	f8c3 2604 	str.w	r2, [r3, #1540]	; 0x604
     10e:	f8c3 2608 	str.w	r2, [r3, #1544]	; 0x608
     112:	f8c3 260c 	str.w	r2, [r3, #1548]	; 0x60c
     116:	f8c3 2610 	str.w	r2, [r3, #1552]	; 0x610
     11a:	f8c3 2614 	str.w	r2, [r3, #1556]	; 0x614
     11e:	f8c3 2618 	str.w	r2, [r3, #1560]	; 0x618
     122:	f8c3 261c 	str.w	r2, [r3, #1564]	; 0x61c
#ifdef CONFIG_MCUBOOT_INDICATION_LED
    /* LED init */
    led_init();
#endif

    os_heap_init();
     126:	f004 fc05 	bl	4934 <os_heap_init>
    ZEPHYR_BOOT_LOG_START();

    (void)rc;

#if (!defined(CONFIG_XTENSA) && DT_HAS_CHOSEN(zephyr_flash_controller))
    if (!flash_device_get_binding(DT_LABEL(DT_CHOSEN(zephyr_flash_controller)))) {
     12a:	4819      	ldr	r0, [pc, #100]	; (190 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x23>)
     12c:	f000 f834 	bl	198 <flash_device_get_binding>
     130:	b900      	cbnz	r0, 134 <FIH_LABEL_FIH_CALL_START_194>
        BOOT_LOG_ERR("Flash device %s not found",
		     DT_LABEL(DT_CHOSEN(zephyr_flash_controller)));
        while (1)
     132:	e7fe      	b.n	132 <main+0x32>

00000134 <FIH_LABEL_FIH_CALL_START_194>:
    rc = boot_console_init();
    int timeout_in_ms = CONFIG_BOOT_SERIAL_WAIT_FOR_DFU_TIMEOUT;
    uint32_t start = k_uptime_get_32();
#endif

    FIH_CALL(boot_go, fih_rc, &rsp);
     134:	a801      	add	r0, sp, #4
     136:	f000 fbf9 	bl	92c <boot_go>

0000013a <FIH_LABEL_FIH_CALL_END_207>:
        timeout_in_ms = 1;
    }
   boot_serial_check_start(&boot_funcs,timeout_in_ms);
#endif

    if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
     13a:	4b16      	ldr	r3, [pc, #88]	; (194 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x27>)
     13c:	681b      	ldr	r3, [r3, #0]
     13e:	4283      	cmp	r3, r0
     140:	d000      	beq.n	144 <CONFIG_IDLE_STACK_SIZE+0x4>
        BOOT_LOG_ERR("Unable to find bootable image");
        FIH_PANIC;
     142:	e7fe      	b.n	142 <CONFIG_IDLE_STACK_SIZE+0x2>
/* There is only one instance of MCUBoot */
#define PROTECT_SIZE (PM_MCUBOOT_PRIMARY_ADDRESS - PM_MCUBOOT_ADDRESS)
#define PROTECT_ADDR PM_MCUBOOT_ADDRESS
#endif

    rc = fprotect_area(PROTECT_ADDR, PROTECT_SIZE);
     144:	f44f 41e0 	mov.w	r1, #28672	; 0x7000
     148:	2000      	movs	r0, #0
     14a:	f005 fbe2 	bl	5912 <fprotect_area>

    if (rc != 0) {
     14e:	b100      	cbz	r0, 152 <CONFIG_IDLE_STACK_SIZE+0x12>
        BOOT_LOG_ERR("Protect mcuboot flash failed, cancel startup.");
        while (1)
     150:	e7fe      	b.n	150 <CONFIG_IDLE_STACK_SIZE+0x10>
    rc = flash_device_base(rsp->br_flash_dev_id, &flash_base);
     152:	4669      	mov	r1, sp
     154:	f89d 0008 	ldrb.w	r0, [sp, #8]
     158:	f004 fbda 	bl	4910 <flash_device_base>
    vt = (struct arm_vector_table *)(flash_base +
     15c:	9b00      	ldr	r3, [sp, #0]
     15e:	9c03      	ldr	r4, [sp, #12]
     160:	441c      	add	r4, r3
                                     rsp->br_hdr->ih_hdr_size);
     162:	9b01      	ldr	r3, [sp, #4]
     164:	891d      	ldrh	r5, [r3, #8]
    nrf_cleanup_peripheral();
     166:	f000 fd9d 	bl	ca4 <nrf_cleanup_peripheral>
                                     rsp->br_image_off +
     16a:	1966      	adds	r6, r4, r5
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
     16c:	f04f 0220 	mov.w	r2, #32
     170:	f3ef 8311 	mrs	r3, BASEPRI
     174:	f382 8812 	msr	BASEPRI_MAX, r2
     178:	f3bf 8f6f 	isb	sy
  \details Assigns the given value to the Main Stack Pointer (MSP).
  \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
     17c:	5963      	ldr	r3, [r4, r5]
     17e:	f383 8808 	msr	MSP, r3
    ((void (*)(void))vt->reset)();
     182:	6873      	ldr	r3, [r6, #4]
     184:	4798      	blx	r3
    ZEPHYR_BOOT_LOG_STOP();

    do_boot(&rsp);

    BOOT_LOG_ERR("Never should get here");
    while (1)
     186:	e7fe      	b.n	186 <CONFIG_SYS_CLOCK_MAX_TIMEOUT_DAYS+0x19>
     188:	40010000 	.word	0x40010000
     18c:	6e524635 	.word	0x6e524635
     190:	000061ee 	.word	0x000061ee
     194:	200000b4 	.word	0x200000b4

00000198 <flash_device_get_binding>:
#endif

static const struct device *flash_dev;

const struct device *flash_device_get_binding(char *dev_name)
{
     198:	b510      	push	{r4, lr}
    if (!flash_dev) {
     19a:	4c04      	ldr	r4, [pc, #16]	; (1ac <flash_device_get_binding+0x14>)
     19c:	6823      	ldr	r3, [r4, #0]
     19e:	b913      	cbnz	r3, 1a6 <flash_device_get_binding+0xe>
		union { uintptr_t x; const char * val; } parm0 = { .val = name };
		return (const struct device *) arch_syscall_invoke1(parm0.x, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
     1a0:	f002 fee2 	bl	2f68 <z_impl_device_get_binding>
        flash_dev = device_get_binding(dev_name);
     1a4:	6020      	str	r0, [r4, #0]
    }
    return flash_dev;
}
     1a6:	6820      	ldr	r0, [r4, #0]
     1a8:	bd10      	pop	{r4, pc}
     1aa:	bf00      	nop
     1ac:	200000b0 	.word	0x200000b0

000001b0 <bootutil_img_validate>:
fih_int
bootutil_img_validate(struct enc_key_data *enc_state, int image_index,
                      struct image_header *hdr, const struct flash_area *fap,
                      uint8_t *tmp_buf, uint32_t tmp_buf_sz, uint8_t *seed,
                      int seed_len, uint8_t *out_hash)
{
     1b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     1b4:	461d      	mov	r5, r3
     1b6:	b0db      	sub	sp, #364	; 0x16c
    uint32_t off;
    uint16_t len;
    uint16_t type;
    int sha256_valid = 0;
#ifdef EXPECTED_SIG_TLV
    fih_int valid_signature = FIH_FAILURE;
     1b8:	4b82      	ldr	r3, [pc, #520]	; (3c4 <FIH_LABEL_FIH_CALL_END_923+0x26>)
{
     1ba:	f8dd b190 	ldr.w	fp, [sp, #400]	; 0x190
    fih_int valid_signature = FIH_FAILURE;
     1be:	681e      	ldr	r6, [r3, #0]
{
     1c0:	e9dd 4866 	ldrd	r4, r8, [sp, #408]	; 0x198
     1c4:	4617      	mov	r7, r2
}

/* Enable and disable cc310 to reduce power consumption */
static inline void cc310_sha256_init(nrf_cc310_bl_hash_context_sha256_t * ctx)
{
    cc310_init();
     1c6:	f000 fd3b 	bl	c40 <cc310_init>
    NRF_CRYPTOCELL->ENABLE=1;
     1ca:	4b7f      	ldr	r3, [pc, #508]	; (3c8 <FIH_LABEL_FIH_CALL_END_923+0x2a>)
     1cc:	2201      	movs	r2, #1
     1ce:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    nrf_cc310_enable();
    nrf_cc310_bl_hash_sha256_init(ctx);
     1d2:	a83a      	add	r0, sp, #232	; 0xe8
     1d4:	f003 fadc 	bl	3790 <nrf_cc310_bl_hash_sha256_init>
    if (seed && (seed_len > 0)) {
     1d8:	b13c      	cbz	r4, 1ea <bootutil_img_validate+0x3a>
     1da:	f1b8 0f00 	cmp.w	r8, #0
     1de:	dd04      	ble.n	1ea <bootutil_img_validate+0x3a>

static inline int bootutil_sha256_update(bootutil_sha256_context *ctx,
                                          const void *data,
                                          uint32_t data_len)
{
    cc310_sha256_update(ctx, data, data_len);
     1e0:	4642      	mov	r2, r8
     1e2:	4621      	mov	r1, r4
     1e4:	a83a      	add	r0, sp, #232	; 0xe8
     1e6:	f004 ff89 	bl	50fc <cc310_sha256_update>
    size += hdr->ih_protect_tlv_size;
     1ea:	897b      	ldrh	r3, [r7, #10]
    size = hdr_size = hdr->ih_hdr_size;
     1ec:	f8b7 8008 	ldrh.w	r8, [r7, #8]
     1f0:	4498      	add	r8, r3
    size += hdr->ih_protect_tlv_size;
     1f2:	68fb      	ldr	r3, [r7, #12]
    for (off = 0; off < size; off += blk_sz) {
     1f4:	f04f 0900 	mov.w	r9, #0
    size += hdr->ih_protect_tlv_size;
     1f8:	4498      	add	r8, r3
    for (off = 0; off < size; off += blk_sz) {
     1fa:	45c8      	cmp	r8, r9
     1fc:	d84e      	bhi.n	29c <FIH_LABEL_FIH_CALL_END_384+0xe>
}

static inline void cc310_sha256_finalize(bootutil_sha256_context *ctx,
                                          uint8_t *output)
{
    nrf_cc310_bl_hash_sha256_finalize(ctx,
     1fe:	a90d      	add	r1, sp, #52	; 0x34
     200:	a83a      	add	r0, sp, #232	; 0xe8
     202:	f003 fb37 	bl	3874 <nrf_cc310_bl_hash_sha256_finalize>
    NRF_CRYPTOCELL->ENABLE=0;
     206:	4b70      	ldr	r3, [pc, #448]	; (3c8 <FIH_LABEL_FIH_CALL_END_923+0x2a>)
     208:	2200      	movs	r2, #0
     20a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
     20e:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
            tmp_buf_sz, hash, seed, seed_len);
    if (rc) {
        goto out;
    }

    if (out_hash) {
     212:	9b68      	ldr	r3, [sp, #416]	; 0x1a0
     214:	b123      	cbz	r3, 220 <CONFIG_PM_PARTITION_SIZE_MCUBOOT_PAD+0x20>
        memcpy(out_hash, hash, 32);
     216:	2220      	movs	r2, #32
     218:	a90d      	add	r1, sp, #52	; 0x34
     21a:	4618      	mov	r0, r3
     21c:	f005 f91c 	bl	5458 <memcpy>
    }

    rc = bootutil_tlv_iter_begin(&it, hdr, fap, IMAGE_TLV_ANY, false);
     220:	2300      	movs	r3, #0
     222:	9300      	str	r3, [sp, #0]
     224:	462a      	mov	r2, r5
     226:	f64f 73ff 	movw	r3, #65535	; 0xffff
     22a:	4639      	mov	r1, r7
     22c:	a807      	add	r0, sp, #28
     22e:	f004 fb82 	bl	4936 <bootutil_tlv_iter_begin>
    if (rc) {
     232:	4604      	mov	r4, r0
     234:	2800      	cmp	r0, #0
     236:	d144      	bne.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
             * can be multiple signatures, each preceded by a key.
             */
#endif /* !MCUBOOT_HW_KEY */
        } else if (type == EXPECTED_SIG_TLV) {
            /* Ignore this signature if it is out of bounds. */
            if (key_id < 0 || key_id >= bootutil_key_cnt) {
     238:	f8df a198 	ldr.w	sl, [pc, #408]	; 3d4 <FIH_LABEL_FIH_CALL_END_923+0x36>
     23c:	f8df 8188 	ldr.w	r8, [pc, #392]	; 3c8 <FIH_LABEL_FIH_CALL_END_923+0x2a>
    int sha256_valid = 0;
     240:	9002      	str	r0, [sp, #8]
    int key_id = -1;
     242:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
        rc = bootutil_tlv_iter_next(&it, &off, &len, &type);
     246:	f10d 0316 	add.w	r3, sp, #22
     24a:	aa05      	add	r2, sp, #20
     24c:	a906      	add	r1, sp, #24
     24e:	a807      	add	r0, sp, #28
     250:	f004 fbbd 	bl	49ce <bootutil_tlv_iter_next>
        if (rc < 0) {
     254:	1e04      	subs	r4, r0, #0
     256:	db34      	blt.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
        } else if (rc > 0) {
     258:	f040 80a4 	bne.w	3a4 <FIH_LABEL_FIH_CALL_END_923+0x6>
        if (type == IMAGE_TLV_SHA256) {
     25c:	f8bd 9016 	ldrh.w	r9, [sp, #22]
     260:	f1b9 0f10 	cmp.w	r9, #16
     264:	d138      	bne.n	2d8 <FIH_LABEL_FIH_CALL_END_384+0x4a>
            if (len != sizeof(hash)) {
     266:	f8bd 9014 	ldrh.w	r9, [sp, #20]
     26a:	f1b9 0f20 	cmp.w	r9, #32
     26e:	f040 80a3 	bne.w	3b8 <FIH_LABEL_FIH_CALL_END_923+0x1a>
            rc = LOAD_IMAGE_DATA(hdr, fap, off, buf, sizeof(hash));
     272:	9906      	ldr	r1, [sp, #24]
     274:	464b      	mov	r3, r9
     276:	aa3a      	add	r2, sp, #232	; 0xe8
     278:	4628      	mov	r0, r5
     27a:	f005 f826 	bl	52ca <flash_area_read>
            if (rc) {
     27e:	4604      	mov	r4, r0
     280:	b9f8      	cbnz	r0, 2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>

00000282 <FIH_LABEL_FIH_CALL_START_365>:
            FIH_CALL(boot_fih_memequal, fih_rc, hash, buf, sizeof(hash));
     282:	464a      	mov	r2, r9
     284:	a93a      	add	r1, sp, #232	; 0xe8
     286:	a80d      	add	r0, sp, #52	; 0x34
     288:	f004 fc18 	bl	4abc <boot_fih_memequal>
     28c:	4604      	mov	r4, r0

0000028e <FIH_LABEL_FIH_CALL_END_384>:
            if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
     28e:	4b4f      	ldr	r3, [pc, #316]	; (3cc <FIH_LABEL_FIH_CALL_END_923+0x2e>)
     290:	681b      	ldr	r3, [r3, #0]
     292:	4283      	cmp	r3, r0
     294:	d115      	bne.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
            sha256_valid = 1;
     296:	2301      	movs	r3, #1
     298:	9302      	str	r3, [sp, #8]
     29a:	e7d4      	b.n	246 <CONFIG_PM_PARTITION_SIZE_MCUBOOT_PAD+0x46>
        blk_sz = size - off;
     29c:	9a65      	ldr	r2, [sp, #404]	; 0x194
     29e:	eba8 0309 	sub.w	r3, r8, r9
        if (blk_sz > tmp_buf_sz) {
     2a2:	429a      	cmp	r2, r3
     2a4:	bf28      	it	cs
     2a6:	461a      	movcs	r2, r3
        rc = flash_area_read(fap, off, tmp_buf, blk_sz);
     2a8:	4613      	mov	r3, r2
     2aa:	4692      	mov	sl, r2
     2ac:	4649      	mov	r1, r9
     2ae:	465a      	mov	r2, fp
     2b0:	4628      	mov	r0, r5
     2b2:	f005 f80a 	bl	52ca <flash_area_read>
        if (rc) {
     2b6:	4604      	mov	r4, r0
     2b8:	b138      	cbz	r0, 2ca <FIH_LABEL_FIH_CALL_END_384+0x3c>
     2ba:	4b43      	ldr	r3, [pc, #268]	; (3c8 <FIH_LABEL_FIH_CALL_END_923+0x2a>)
     2bc:	2200      	movs	r2, #0
     2be:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    if (rc) {
        fih_rc = fih_int_encode(rc);
    }

    FIH_RET(fih_rc);
}
     2c2:	4620      	mov	r0, r4
     2c4:	b05b      	add	sp, #364	; 0x16c
     2c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     2ca:	4652      	mov	r2, sl
     2cc:	4659      	mov	r1, fp
     2ce:	a83a      	add	r0, sp, #232	; 0xe8
     2d0:	f004 ff14 	bl	50fc <cc310_sha256_update>
    for (off = 0; off < size; off += blk_sz) {
     2d4:	44d1      	add	r9, sl
     2d6:	e790      	b.n	1fa <bootutil_img_validate+0x4a>
        } else if (type == IMAGE_TLV_KEYHASH) {
     2d8:	f1b9 0f01 	cmp.w	r9, #1
     2dc:	d13e      	bne.n	35c <FIH_LABEL_FIH_CALL_END_384+0xce>
            if (len > 32) {
     2de:	f8bd 3014 	ldrh.w	r3, [sp, #20]
     2e2:	2b20      	cmp	r3, #32
     2e4:	d868      	bhi.n	3b8 <FIH_LABEL_FIH_CALL_END_923+0x1a>
            rc = LOAD_IMAGE_DATA(hdr, fap, off, buf, len);
     2e6:	9906      	ldr	r1, [sp, #24]
     2e8:	aa3a      	add	r2, sp, #232	; 0xe8
     2ea:	4628      	mov	r0, r5
     2ec:	f004 ffed 	bl	52ca <flash_area_read>
            if (rc) {
     2f0:	4604      	mov	r4, r0
     2f2:	2800      	cmp	r0, #0
     2f4:	d1e5      	bne.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
            key_id = bootutil_find_key(buf, len);
     2f6:	f89d b014 	ldrb.w	fp, [sp, #20]
    if (keyhash_len > 32) {
     2fa:	f1bb 0f20 	cmp.w	fp, #32
     2fe:	d809      	bhi.n	314 <FIH_LABEL_FIH_CALL_END_384+0x86>
    for (i = 0; i < bootutil_key_cnt; i++) {
     300:	f8da 3000 	ldr.w	r3, [sl]
     304:	4f32      	ldr	r7, [pc, #200]	; (3d0 <FIH_LABEL_FIH_CALL_END_923+0x32>)
     306:	9303      	str	r3, [sp, #12]
     308:	9b03      	ldr	r3, [sp, #12]
     30a:	429c      	cmp	r4, r3
     30c:	db05      	blt.n	31a <FIH_LABEL_FIH_CALL_END_384+0x8c>
     30e:	2300      	movs	r3, #0
     310:	f8c8 3500 	str.w	r3, [r8, #1280]	; 0x500
        return -1;
     314:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
     318:	e01c      	b.n	354 <FIH_LABEL_FIH_CALL_END_384+0xc6>
    cc310_init();
     31a:	f000 fc91 	bl	c40 <cc310_init>
    NRF_CRYPTOCELL->ENABLE=1;
     31e:	f8c8 9500 	str.w	r9, [r8, #1280]	; 0x500
    nrf_cc310_bl_hash_sha256_init(ctx);
     322:	a81d      	add	r0, sp, #116	; 0x74
     324:	f003 fa34 	bl	3790 <nrf_cc310_bl_hash_sha256_init>
        bootutil_sha256_update(&sha256_ctx, key->key, *key->len);
     328:	687a      	ldr	r2, [r7, #4]
     32a:	f857 1b08 	ldr.w	r1, [r7], #8
     32e:	6812      	ldr	r2, [r2, #0]
     330:	a81d      	add	r0, sp, #116	; 0x74
     332:	f004 fee3 	bl	50fc <cc310_sha256_update>
    nrf_cc310_bl_hash_sha256_finalize(ctx,
     336:	a915      	add	r1, sp, #84	; 0x54
     338:	a81d      	add	r0, sp, #116	; 0x74
     33a:	f003 fa9b 	bl	3874 <nrf_cc310_bl_hash_sha256_finalize>
    NRF_CRYPTOCELL->ENABLE=0;
     33e:	2200      	movs	r2, #0
     340:	f8c8 2500 	str.w	r2, [r8, #1280]	; 0x500
        if (!memcmp(hash, keyhash, keyhash_len)) {
     344:	a93a      	add	r1, sp, #232	; 0xe8
     346:	465a      	mov	r2, fp
     348:	a815      	add	r0, sp, #84	; 0x54
     34a:	f005 f85c 	bl	5406 <memcmp>
     34e:	b918      	cbnz	r0, 358 <FIH_LABEL_FIH_CALL_END_384+0xca>
     350:	f8c8 0500 	str.w	r0, [r8, #1280]	; 0x500
            key_id = bootutil_find_key(buf, len);
     354:	4627      	mov	r7, r4
     356:	e776      	b.n	246 <CONFIG_PM_PARTITION_SIZE_MCUBOOT_PAD+0x46>
    for (i = 0; i < bootutil_key_cnt; i++) {
     358:	3401      	adds	r4, #1
     35a:	e7d5      	b.n	308 <FIH_LABEL_FIH_CALL_END_384+0x7a>
        } else if (type == EXPECTED_SIG_TLV) {
     35c:	f1b9 0f22 	cmp.w	r9, #34	; 0x22
     360:	f47f af71 	bne.w	246 <CONFIG_PM_PARTITION_SIZE_MCUBOOT_PAD+0x46>
            if (key_id < 0 || key_id >= bootutil_key_cnt) {
     364:	1c7b      	adds	r3, r7, #1
     366:	f43f af6e 	beq.w	246 <CONFIG_PM_PARTITION_SIZE_MCUBOOT_PAD+0x46>
     36a:	f8da 3000 	ldr.w	r3, [sl]
     36e:	42bb      	cmp	r3, r7
     370:	dd15      	ble.n	39e <FIH_LABEL_FIH_CALL_END_923>
            if (!EXPECTED_SIG_LEN(len) || len > sizeof(buf)) {
     372:	f8bd 3014 	ldrh.w	r3, [sp, #20]
     376:	2b80      	cmp	r3, #128	; 0x80
     378:	d81e      	bhi.n	3b8 <FIH_LABEL_FIH_CALL_END_923+0x1a>
            rc = LOAD_IMAGE_DATA(hdr, fap, off, buf, len);
     37a:	9906      	ldr	r1, [sp, #24]
     37c:	aa3a      	add	r2, sp, #232	; 0xe8
     37e:	4628      	mov	r0, r5
     380:	f004 ffa3 	bl	52ca <flash_area_read>
            if (rc) {
     384:	4604      	mov	r4, r0
     386:	2800      	cmp	r0, #0
     388:	d19b      	bne.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>

0000038a <FIH_LABEL_FIH_CALL_START_901>:
            FIH_CALL(bootutil_verify_sig, valid_signature, hash, sizeof(hash),
     38a:	b2ff      	uxtb	r7, r7
     38c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
     390:	9700      	str	r7, [sp, #0]
     392:	aa3a      	add	r2, sp, #232	; 0xe8
     394:	2120      	movs	r1, #32
     396:	a80d      	add	r0, sp, #52	; 0x34
     398:	f000 f81e 	bl	3d8 <bootutil_verify_sig>
     39c:	4606      	mov	r6, r0

0000039e <FIH_LABEL_FIH_CALL_END_923>:
                key_id = -1;
     39e:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
     3a2:	e750      	b.n	246 <CONFIG_PM_PARTITION_SIZE_MCUBOOT_PAD+0x46>
    if (rc) {
     3a4:	9b02      	ldr	r3, [sp, #8]
     3a6:	b153      	cbz	r3, 3be <FIH_LABEL_FIH_CALL_END_923+0x20>
    fih_rc = fih_int_encode_zero_equality(fih_not_eq(valid_signature,
     3a8:	4b08      	ldr	r3, [pc, #32]	; (3cc <FIH_LABEL_FIH_CALL_END_923+0x2e>)
 * value that is not FIH_SUCCESS
 */
__attribute__((always_inline)) inline
fih_int fih_int_encode_zero_equality(int x)
{
    if (x) {
     3aa:	681b      	ldr	r3, [r3, #0]
     3ac:	42b3      	cmp	r3, r6
     3ae:	d001      	beq.n	3b4 <FIH_LABEL_FIH_CALL_END_923+0x16>
        return FIH_FAILURE;
     3b0:	4b04      	ldr	r3, [pc, #16]	; (3c4 <FIH_LABEL_FIH_CALL_END_923+0x26>)
     3b2:	681e      	ldr	r6, [r3, #0]
                rc = -1;
     3b4:	4634      	mov	r4, r6
     3b6:	e784      	b.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
     3b8:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
     3bc:	e781      	b.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
     3be:	2401      	movs	r4, #1
    FIH_RET(fih_rc);
     3c0:	e77f      	b.n	2c2 <FIH_LABEL_FIH_CALL_END_384+0x34>
     3c2:	bf00      	nop
     3c4:	20000000 	.word	0x20000000
     3c8:	5002a000 	.word	0x5002a000
     3cc:	200000b4 	.word	0x200000b4
     3d0:	00005e9c 	.word	0x00005e9c
     3d4:	00005e98 	.word	0x00005e98

000003d8 <bootutil_verify_sig>:
#endif /* not MCUBOOT_ECDSA_NEED_ASN1_SIG */

int
bootutil_verify_sig(uint8_t *hash, uint32_t hlen, uint8_t *sig, size_t slen,
  uint8_t key_id)
{
     3d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     3dc:	b096      	sub	sp, #88	; 0x58
     3de:	4617      	mov	r7, r2
     3e0:	461d      	mov	r5, r3
     3e2:	f89d 2070 	ldrb.w	r2, [sp, #112]	; 0x70

#ifndef MCUBOOT_ECDSA_NEED_ASN1_SIG
    uint8_t signature[2 * NUM_ECC_BYTES];
#endif

    pubkey = (uint8_t *)bootutil_keys[key_id].key;
     3e6:	4b35      	ldr	r3, [pc, #212]	; (4bc <CONFIG_FLASH_SIZE+0xbc>)
{
     3e8:	460e      	mov	r6, r1
    pubkey = (uint8_t *)bootutil_keys[key_id].key;
     3ea:	f853 1032 	ldr.w	r1, [r3, r2, lsl #3]
     3ee:	9101      	str	r1, [sp, #4]
    end = pubkey + *bootutil_keys[key_id].len;
     3f0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
{
     3f4:	4680      	mov	r8, r0
    end = pubkey + *bootutil_keys[key_id].len;
     3f6:	685b      	ldr	r3, [r3, #4]
     3f8:	6818      	ldr	r0, [r3, #0]
    if (mbedtls_asn1_get_tag(cp, end, &len,
     3fa:	aa02      	add	r2, sp, #8
     3fc:	4401      	add	r1, r0
     3fe:	2330      	movs	r3, #48	; 0x30
     400:	a801      	add	r0, sp, #4
     402:	f004 fe08 	bl	5016 <mbedtls_asn1_get_tag>
     406:	b110      	cbz	r0, 40e <CONFIG_FLASH_SIZE+0xe>
    }
    rc = mbedtls_ecdsa_read_signature(&ctx, hash, hlen, sig, slen);

#else /* CY_MBEDTLS_HW_ACCELERATION */
    if (hlen != NUM_ECC_BYTES) {
        return -1;
     408:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     40c:	e053      	b.n	4b6 <CONFIG_FLASH_SIZE+0xb6>
    end = *cp + len;
     40e:	e9dd 4301 	ldrd	r4, r3, [sp, #4]
     412:	441c      	add	r4, r3
    if (mbedtls_asn1_get_alg(cp, end, &alg, &param)) {
     414:	aa03      	add	r2, sp, #12
     416:	ab06      	add	r3, sp, #24
     418:	4621      	mov	r1, r4
     41a:	a801      	add	r0, sp, #4
     41c:	f004 fe23 	bl	5066 <mbedtls_asn1_get_alg>
     420:	2800      	cmp	r0, #0
     422:	d1f1      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (alg.MBEDTLS_CONTEXT_MEMBER(len) != sizeof(ec_pubkey_oid) - 1 ||
     424:	9a04      	ldr	r2, [sp, #16]
     426:	2a07      	cmp	r2, #7
     428:	d1ee      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
        memcmp(alg.MBEDTLS_CONTEXT_MEMBER(p), ec_pubkey_oid, sizeof(ec_pubkey_oid) - 1)) {
     42a:	4925      	ldr	r1, [pc, #148]	; (4c0 <CONFIG_FLASH_SIZE+0xc0>)
     42c:	9805      	ldr	r0, [sp, #20]
     42e:	f004 ffea 	bl	5406 <memcmp>
    if (alg.MBEDTLS_CONTEXT_MEMBER(len) != sizeof(ec_pubkey_oid) - 1 ||
     432:	2800      	cmp	r0, #0
     434:	d1e8      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (param.MBEDTLS_CONTEXT_MEMBER(len) != sizeof(ec_secp256r1_oid) - 1 ||
     436:	9a07      	ldr	r2, [sp, #28]
     438:	2a08      	cmp	r2, #8
     43a:	d1e5      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
        memcmp(param.MBEDTLS_CONTEXT_MEMBER(p), ec_secp256r1_oid, sizeof(ec_secp256r1_oid) - 1)) {
     43c:	4921      	ldr	r1, [pc, #132]	; (4c4 <CONFIG_FLASH_SIZE+0xc4>)
     43e:	9808      	ldr	r0, [sp, #32]
     440:	f004 ffe1 	bl	5406 <memcmp>
    if (param.MBEDTLS_CONTEXT_MEMBER(len) != sizeof(ec_secp256r1_oid) - 1 ||
     444:	2800      	cmp	r0, #0
     446:	d1df      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (mbedtls_asn1_get_bitstring_null(cp, end, &len)) {
     448:	aa02      	add	r2, sp, #8
     44a:	4621      	mov	r1, r4
     44c:	a801      	add	r0, sp, #4
     44e:	f004 fdf6 	bl	503e <mbedtls_asn1_get_bitstring_null>
     452:	2800      	cmp	r0, #0
     454:	d1d8      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (*cp + len != end) {
     456:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
     45a:	4413      	add	r3, r2
     45c:	429c      	cmp	r4, r3
     45e:	d1d3      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (len != 2 * NUM_ECC_BYTES + 1) {
     460:	2a41      	cmp	r2, #65	; 0x41
     462:	d1d1      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    rc = bootutil_decode_sig(signature, sig, sig + slen);
     464:	443d      	add	r5, r7
    rc = mbedtls_asn1_get_tag(&cp, end, &len,
     466:	2330      	movs	r3, #48	; 0x30
     468:	aa03      	add	r2, sp, #12
     46a:	4629      	mov	r1, r5
     46c:	a802      	add	r0, sp, #8
     46e:	9702      	str	r7, [sp, #8]
     470:	f004 fdd1 	bl	5016 <mbedtls_asn1_get_tag>
    if (rc) {
     474:	2800      	cmp	r0, #0
     476:	d1c7      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (cp + len > end) {
     478:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
     47c:	4413      	add	r3, r2
     47e:	429d      	cmp	r5, r3
     480:	d3c2      	bcc.n	408 <CONFIG_FLASH_SIZE+0x8>
    rc = bootutil_read_bigint(signature, &cp, end);
     482:	462a      	mov	r2, r5
     484:	a902      	add	r1, sp, #8
     486:	a806      	add	r0, sp, #24
     488:	f004 faec 	bl	4a64 <bootutil_read_bigint>
    if (rc) {
     48c:	2800      	cmp	r0, #0
     48e:	d1bb      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    rc = bootutil_read_bigint(signature + NUM_ECC_BYTES, &cp, end);
     490:	462a      	mov	r2, r5
     492:	a902      	add	r1, sp, #8
     494:	a80e      	add	r0, sp, #56	; 0x38
     496:	f004 fae5 	bl	4a64 <bootutil_read_bigint>
    if (rc) {
     49a:	2800      	cmp	r0, #0
     49c:	d1b4      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
    if (hlen != NUM_ECC_BYTES) {
     49e:	2e20      	cmp	r6, #32
     4a0:	d1b2      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>

    bootutil_ecdsa_p256_init(&ctx);
#ifdef MCUBOOT_ECDSA_NEED_ASN1_SIG
    rc = bootutil_ecdsa_p256_verify(&ctx, pubkey, end - pubkey, hash, sig, slen);
#else
    rc = bootutil_ecdsa_p256_verify(&ctx, pubkey, end - pubkey, hash, signature,
     4a2:	9901      	ldr	r1, [sp, #4]
    (void)ctx;
    (void)pk_len;
    (void)sig_len;

    /* Only support uncompressed keys. */
    if (pk[0] != 0x04) {
     4a4:	780b      	ldrb	r3, [r1, #0]
     4a6:	2b04      	cmp	r3, #4
     4a8:	d1ae      	bne.n	408 <CONFIG_FLASH_SIZE+0x8>
        return -1;
    }
    pk++;

    return cc310_ecdsa_verify_secp256r1(hash, pk, sig, BOOTUTIL_CRYPTO_ECDSA_P256_HASH_SIZE);
     4aa:	4633      	mov	r3, r6
     4ac:	aa06      	add	r2, sp, #24
     4ae:	3101      	adds	r1, #1
     4b0:	4640      	mov	r0, r8
     4b2:	f000 fbdd 	bl	c70 <cc310_ecdsa_verify_secp256r1>
#endif /* CY_MBEDTLS_HW_ACCELERATION */

    bootutil_ecdsa_p256_drop(&ctx);

    return rc;
}
     4b6:	b016      	add	sp, #88	; 0x58
     4b8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     4bc:	00005e9c 	.word	0x00005e9c
     4c0:	00006201 	.word	0x00006201
     4c4:	00006209 	.word	0x00006209

000004c8 <boot_read_swap_size>:
    return -1;
}

int
boot_read_swap_size(int image_index, uint32_t *swap_size)
{
     4c8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
     4cc:	b086      	sub	sp, #24
    uint8_t areas[2] = {
     4ce:	2303      	movs	r3, #3
    if (memcmp(magic, BOOT_IMG_MAGIC, BOOT_MAGIC_SZ) == 0) {
     4d0:	f8df 806c 	ldr.w	r8, [pc, #108]	; 540 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x58>
    uint8_t areas[2] = {
     4d4:	f8ad 3000 	strh.w	r3, [sp]
{
     4d8:	460d      	mov	r5, r1
     4da:	466f      	mov	r7, sp
    for (i = 0; i < sizeof(areas) / sizeof(areas[0]); i++) {
     4dc:	2600      	movs	r6, #0
        rc = flash_area_open(areas[i], fap);
     4de:	f817 0b01 	ldrb.w	r0, [r7], #1
     4e2:	a901      	add	r1, sp, #4
     4e4:	f000 fcf2 	bl	ecc <flash_area_open>
        if (rc != 0) {
     4e8:	4604      	mov	r4, r0
     4ea:	b9a0      	cbnz	r0, 516 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x2e>
        off = boot_magic_off(*fap);
     4ec:	9801      	ldr	r0, [sp, #4]
    return flash_area_get_size(fap) - BOOT_MAGIC_SZ;
     4ee:	6881      	ldr	r1, [r0, #8]
        rc = flash_area_read(*fap, off, magic, BOOT_MAGIC_SZ);
     4f0:	2310      	movs	r3, #16
     4f2:	aa02      	add	r2, sp, #8
     4f4:	3910      	subs	r1, #16
     4f6:	f004 fee8 	bl	52ca <flash_area_read>
     4fa:	4604      	mov	r4, r0
        flash_area_close(*fap);
     4fc:	9801      	ldr	r0, [sp, #4]
     4fe:	f004 fee3 	bl	52c8 <flash_area_close>
        if (rc != 0) {
     502:	b944      	cbnz	r4, 516 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x2e>
    if (memcmp(magic, BOOT_IMG_MAGIC, BOOT_MAGIC_SZ) == 0) {
     504:	2210      	movs	r2, #16
     506:	4641      	mov	r1, r8
     508:	a802      	add	r0, sp, #8
     50a:	f004 ff7c 	bl	5406 <memcmp>
     50e:	b140      	cbz	r0, 522 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x3a>
    for (i = 0; i < sizeof(areas) / sizeof(areas[0]); i++) {
     510:	b12e      	cbz	r6, 51e <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x36>
    return -1;
     512:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
        rc = flash_area_read(fap, off, swap_size, sizeof *swap_size);
        flash_area_close(fap);
    }

    return rc;
}
     516:	4620      	mov	r0, r4
     518:	b006      	add	sp, #24
     51a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
     51e:	2601      	movs	r6, #1
     520:	e7dd      	b.n	4de <boot_read_swap_size+0x16>
    return boot_swap_info_off(fap) - BOOT_MAX_ALIGN;
     522:	9801      	ldr	r0, [sp, #4]
     524:	f005 fa14 	bl	5950 <boot_swap_info_off>
        rc = flash_area_read(fap, off, swap_size, sizeof *swap_size);
     528:	2304      	movs	r3, #4
     52a:	f1a0 0108 	sub.w	r1, r0, #8
     52e:	462a      	mov	r2, r5
     530:	9801      	ldr	r0, [sp, #4]
     532:	f004 feca 	bl	52ca <flash_area_read>
     536:	4604      	mov	r4, r0
        flash_area_close(fap);
     538:	9801      	ldr	r0, [sp, #4]
     53a:	f004 fec5 	bl	52c8 <flash_area_close>
     53e:	e7ea      	b.n	516 <CONFIG_NRF_MODEM_SHMEM_CTRL_SIZE+0x2e>
     540:	000061de 	.word	0x000061de

00000544 <boot_validate_slot.isra.0>:
 *         FIH_SUCCESS                      if image was successfully validated
 *         1 (or its fih_int encoded form)  if no bootloable image was found
 *         FIH_FAILURE                      on any errors
 */
static fih_int
boot_validate_slot(struct boot_loader_state *state, int slot,
     544:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
                   struct boot_status *bs)
{
    const struct flash_area *fap;
    struct image_header *hdr;
    int area_id;
    fih_int fih_rc = FIH_FAILURE;
     548:	4b34      	ldr	r3, [pc, #208]	; (61c <FIH_LABEL_FIH_CALL_END_296+0x70>)
boot_validate_slot(struct boot_loader_state *state, int slot,
     54a:	b088      	sub	sp, #32
     54c:	4606      	mov	r6, r0
    int rc;

    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
     54e:	2000      	movs	r0, #0
boot_validate_slot(struct boot_loader_state *state, int slot,
     550:	460c      	mov	r4, r1
    fih_int fih_rc = FIH_FAILURE;
     552:	681d      	ldr	r5, [r3, #0]
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
     554:	f004 f9e2 	bl	491c <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
     558:	a906      	add	r1, sp, #24
     55a:	b2c0      	uxtb	r0, r0
     55c:	f000 fcb6 	bl	ecc <flash_area_open>
    if (rc != 0) {
     560:	2800      	cmp	r0, #0
     562:	d14c      	bne.n	5fe <FIH_LABEL_FIH_CALL_END_296+0x52>
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
     564:	4621      	mov	r1, r4
     566:	f004 f9d9 	bl	491c <flash_area_id_from_multi_image_slot>
     ((swap_type) == BOOT_SWAP_TYPE_PERM))

static inline struct image_header*
boot_img_hdr(struct boot_loader_state *state, size_t slot)
{
    return &BOOT_IMG(state, slot).hdr;
     56a:	252c      	movs	r5, #44	; 0x2c
    rc = flash_area_open(area_id, &fap);
     56c:	a907      	add	r1, sp, #28
     56e:	b2c0      	uxtb	r0, r0
     570:	fb05 6504 	mla	r5, r5, r4, r6
     574:	f000 fcaa 	bl	ecc <flash_area_open>
    if (rc != 0) {
     578:	2800      	cmp	r0, #0
     57a:	d030      	beq.n	5de <FIH_LABEL_FIH_CALL_END_296+0x32>
        FIH_RET(fih_rc);
    }

    hdr = boot_img_hdr(state, slot);
    if (boot_check_header_erased(state, slot) == 0 ||
        (hdr->ih_flags & IMAGE_F_NON_BOOTABLE)) {
     57c:	f04f 082c 	mov.w	r8, #44	; 0x2c
     580:	fb08 f804 	mul.w	r8, r8, r4
     584:	eb06 0708 	add.w	r7, r6, r8
     588:	6939      	ldr	r1, [r7, #16]
    if (boot_check_header_erased(state, slot) == 0 ||
     58a:	f011 0110 	ands.w	r1, r1, #16
     58e:	d131      	bne.n	5f4 <FIH_LABEL_FIH_CALL_END_296+0x48>

00000590 <FIH_LABEL_FIH_CALL_START_240>:
    FIH_CALL(bootutil_img_validate, fih_rc, BOOT_CURR_ENC(state), image_index,
     590:	f44f 7380 	mov.w	r3, #256	; 0x100
     594:	9301      	str	r3, [sp, #4]
     596:	4b22      	ldr	r3, [pc, #136]	; (620 <FIH_LABEL_FIH_CALL_END_296+0x74>)
     598:	9300      	str	r3, [sp, #0]
     59a:	462a      	mov	r2, r5
     59c:	e9cd 1103 	strd	r1, r1, [sp, #12]
     5a0:	9b06      	ldr	r3, [sp, #24]
     5a2:	9102      	str	r1, [sp, #8]
     5a4:	4608      	mov	r0, r1
     5a6:	f7ff fe03 	bl	1b0 <bootutil_img_validate>
     5aa:	4605      	mov	r5, r0

000005ac <FIH_LABEL_FIH_CALL_END_296>:
    if (hdr->ih_magic != IMAGE_MAGIC) {
     5ac:	4b1d      	ldr	r3, [pc, #116]	; (624 <FIH_LABEL_FIH_CALL_END_296+0x78>)
     5ae:	f856 2008 	ldr.w	r2, [r6, r8]
                       fih_rc, BOOT_CURR_IMG(state), slot);
    if (fih_eq(fih_rc, fih_int_encode(BOOT_HOOK_REGULAR)))
    {
        FIH_CALL(boot_image_check, fih_rc, state, hdr, fap, bs);
    }
    if (!boot_is_header_valid(hdr, fap) || fih_not_eq(fih_rc, FIH_SUCCESS)) {
     5b2:	9806      	ldr	r0, [sp, #24]
    if (hdr->ih_magic != IMAGE_MAGIC) {
     5b4:	429a      	cmp	r2, r3
     5b6:	d10c      	bne.n	5d2 <FIH_LABEL_FIH_CALL_END_296+0x26>
    if (!boot_u32_safe_add(&size, hdr->ih_img_size, hdr->ih_hdr_size)) {
     5b8:	893a      	ldrh	r2, [r7, #8]
     5ba:	68fb      	ldr	r3, [r7, #12]
    if (a > UINT32_MAX - b) {
     5bc:	43d1      	mvns	r1, r2
     5be:	428b      	cmp	r3, r1
     5c0:	d807      	bhi.n	5d2 <FIH_LABEL_FIH_CALL_END_296+0x26>
        *dest = a + b;
     5c2:	4413      	add	r3, r2
    if (size >= flash_area_get_size(fap)) {
     5c4:	6882      	ldr	r2, [r0, #8]
     5c6:	4293      	cmp	r3, r2
     5c8:	d203      	bcs.n	5d2 <FIH_LABEL_FIH_CALL_END_296+0x26>
    if (!boot_is_header_valid(hdr, fap) || fih_not_eq(fih_rc, FIH_SUCCESS)) {
     5ca:	4b17      	ldr	r3, [pc, #92]	; (628 <FIH_LABEL_FIH_CALL_END_296+0x7c>)
     5cc:	681b      	ldr	r3, [r3, #0]
     5ce:	42ab      	cmp	r3, r5
     5d0:	d012      	beq.n	5f8 <FIH_LABEL_FIH_CALL_END_296+0x4c>
        if ((slot != BOOT_PRIMARY_SLOT) || ARE_SLOTS_EQUIVALENT()) {
     5d2:	b184      	cbz	r4, 5f6 <FIH_LABEL_FIH_CALL_END_296+0x4a>
            flash_area_erase(fap, 0, flash_area_get_size(fap));
     5d4:	6882      	ldr	r2, [r0, #8]
     5d6:	2100      	movs	r1, #0
     5d8:	f004 feaf 	bl	533a <flash_area_erase>
     5dc:	e01c      	b.n	618 <FIH_LABEL_FIH_CALL_END_296+0x6c>
    erased_val = flash_area_erased_val(fap);
     5de:	9807      	ldr	r0, [sp, #28]
     5e0:	f004 fecb 	bl	537a <flash_area_erased_val>
     5e4:	4607      	mov	r7, r0
    flash_area_close(fap);
     5e6:	9807      	ldr	r0, [sp, #28]
     5e8:	f004 fe6e 	bl	52c8 <flash_area_close>
boot_data_is_set_to(uint8_t val, void *data, size_t len)
     5ec:	1e6b      	subs	r3, r5, #1
     5ee:	1cea      	adds	r2, r5, #3
    for (i = 0; i < len; i++) {
     5f0:	429a      	cmp	r2, r3
     5f2:	d108      	bne.n	606 <FIH_LABEL_FIH_CALL_END_296+0x5a>
        if (slot != BOOT_PRIMARY_SLOT) {
     5f4:	b964      	cbnz	r4, 610 <FIH_LABEL_FIH_CALL_END_296+0x64>
        fih_rc = fih_int_encode(1);
     5f6:	2501      	movs	r5, #1
        }
    }
#endif

out:
    flash_area_close(fap);
     5f8:	9806      	ldr	r0, [sp, #24]
     5fa:	f004 fe65 	bl	52c8 <flash_area_close>

    FIH_RET(fih_rc);
}
     5fe:	4628      	mov	r0, r5
     600:	b008      	add	sp, #32
     602:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        if (val != p[i]) {
     606:	f813 1f01 	ldrb.w	r1, [r3, #1]!
     60a:	42b9      	cmp	r1, r7
     60c:	d0f0      	beq.n	5f0 <FIH_LABEL_FIH_CALL_END_296+0x44>
     60e:	e7b5      	b.n	57c <boot_validate_slot.isra.0+0x38>
            swap_erase_trailer_sectors(state, fap);
     610:	9906      	ldr	r1, [sp, #24]
     612:	4630      	mov	r0, r6
     614:	f004 fb4b 	bl	4cae <swap_erase_trailer_sectors>
        fih_rc = fih_int_encode(1);
     618:	4625      	mov	r5, r4
     61a:	e7ed      	b.n	5f8 <FIH_LABEL_FIH_CALL_END_296+0x4c>
     61c:	20000000 	.word	0x20000000
     620:	20001668 	.word	0x20001668
     624:	96f3b83d 	.word	0x96f3b83d
     628:	200000b4 	.word	0x200000b4

0000062c <boot_swap_image>:
 *
 * @return                      0 on success; nonzero on failure.
 */
static int
boot_swap_image(struct boot_loader_state *state, struct boot_status *bs)
{
     62c:	b573      	push	{r0, r1, r4, r5, r6, lr}
     62e:	460d      	mov	r5, r1
     630:	4604      	mov	r4, r0
    uint8_t image_index;
    int rc;

    /* FIXME: just do this if asked by user? */

    size = copy_size = 0;
     632:	2100      	movs	r1, #0
    image_index = BOOT_CURR_IMG(state);

    if (boot_status_is_reset(bs)) {
     634:	4628      	mov	r0, r5
    size = copy_size = 0;
     636:	e9cd 1100 	strd	r1, r1, [sp]
    if (boot_status_is_reset(bs)) {
     63a:	f004 faf7 	bl	4c2c <boot_status_is_reset>
     63e:	b1f0      	cbz	r0, 67e <boot_swap_image+0x52>
        /*
         * No swap ever happened, so need to find the largest image which
         * will be used to determine the amount of sectors to swap.
         */
        hdr = boot_img_hdr(state, BOOT_PRIMARY_SLOT);
        if (hdr->ih_magic == IMAGE_MAGIC) {
     640:	4e12      	ldr	r6, [pc, #72]	; (68c <boot_swap_image+0x60>)
     642:	6823      	ldr	r3, [r4, #0]
     644:	42b3      	cmp	r3, r6
     646:	d103      	bne.n	650 <boot_swap_image+0x24>
            rc = boot_read_image_size(state, BOOT_PRIMARY_SLOT, &copy_size);
     648:	aa01      	add	r2, sp, #4
     64a:	4620      	mov	r0, r4
     64c:	f004 fa82 	bl	4b54 <boot_read_image_size.isra.0>
            memset(bs->enckey[0], 0xff, BOOT_ENC_KEY_ALIGN_SIZE);
        }
#endif

        hdr = boot_img_hdr(state, BOOT_SECONDARY_SLOT);
        if (hdr->ih_magic == IMAGE_MAGIC) {
     650:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
     652:	42b3      	cmp	r3, r6
     654:	d104      	bne.n	660 <boot_swap_image+0x34>
            rc = boot_read_image_size(state, BOOT_SECONDARY_SLOT, &size);
     656:	466a      	mov	r2, sp
     658:	2101      	movs	r1, #1
     65a:	4620      	mov	r0, r4
     65c:	f004 fa7a 	bl	4b54 <boot_read_image_size.isra.0>
        } else {
            memset(bs->enckey[1], 0xff, BOOT_ENC_KEY_ALIGN_SIZE);
        }
#endif

        if (size > copy_size) {
     660:	e9dd 3200 	ldrd	r3, r2, [sp]
     664:	4293      	cmp	r3, r2
            copy_size = size;
     666:	bf88      	it	hi
     668:	9301      	strhi	r3, [sp, #4]
        }

        bs->swap_size = copy_size;
     66a:	9b01      	ldr	r3, [sp, #4]
     66c:	60ab      	str	r3, [r5, #8]
            }
        }
#endif
    }

    swap_run(state, bs, copy_size);
     66e:	4620      	mov	r0, r4
     670:	9a01      	ldr	r2, [sp, #4]
     672:	4629      	mov	r1, r5
     674:	f000 f9e0 	bl	a38 <swap_run>
                     boot_status_fails);
    }
#endif

    return 0;
}
     678:	2000      	movs	r0, #0
     67a:	b002      	add	sp, #8
     67c:	bd70      	pop	{r4, r5, r6, pc}
        rc = boot_read_swap_size(image_index, &bs->swap_size);
     67e:	f105 0108 	add.w	r1, r5, #8
     682:	f7ff ff21 	bl	4c8 <boot_read_swap_size>
        copy_size = bs->swap_size;
     686:	68ab      	ldr	r3, [r5, #8]
     688:	9301      	str	r3, [sp, #4]
     68a:	e7f0      	b.n	66e <boot_swap_image+0x42>
     68c:	96f3b83d 	.word	0x96f3b83d

00000690 <boot_copy_region>:
{
     690:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
     694:	f8df b078 	ldr.w	fp, [pc, #120]	; 710 <boot_copy_region+0x80>
     698:	4c1b      	ldr	r4, [pc, #108]	; (708 <boot_copy_region+0x78>)
     69a:	4d1c      	ldr	r5, [pc, #112]	; (70c <boot_copy_region+0x7c>)
{
     69c:	468a      	mov	sl, r1
     69e:	4690      	mov	r8, r2
     6a0:	4699      	mov	r9, r3
    bytes_copied = 0;
     6a2:	2600      	movs	r6, #0
    while (bytes_copied < sz) {
     6a4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
     6a6:	429e      	cmp	r6, r3
     6a8:	d301      	bcc.n	6ae <boot_copy_region+0x1e>
    return 0;
     6aa:	2000      	movs	r0, #0
     6ac:	e00f      	b.n	6ce <boot_copy_region+0x3e>
        if (sz - bytes_copied > sizeof buf) {
     6ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
     6b0:	4a17      	ldr	r2, [pc, #92]	; (710 <boot_copy_region+0x80>)
        if (sz - bytes_copied > sizeof buf) {
     6b2:	1b9f      	subs	r7, r3, r6
     6b4:	f5b7 6f80 	cmp.w	r7, #1024	; 0x400
     6b8:	bf28      	it	cs
     6ba:	f44f 6780 	movcs.w	r7, #1024	; 0x400
        rc = flash_area_read(fap_src, off_src + bytes_copied, buf, chunk_sz);
     6be:	463b      	mov	r3, r7
     6c0:	eb06 0109 	add.w	r1, r6, r9
     6c4:	4650      	mov	r0, sl
     6c6:	f004 fe00 	bl	52ca <flash_area_read>
        if (rc != 0) {
     6ca:	b110      	cbz	r0, 6d2 <boot_copy_region+0x42>
            return BOOT_EFLASH;
     6cc:	2001      	movs	r0, #1
}
     6ce:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        rc = flash_area_write(fap_dst, off_dst + bytes_copied, buf, chunk_sz);
     6d2:	990a      	ldr	r1, [sp, #40]	; 0x28
     6d4:	463b      	mov	r3, r7
     6d6:	465a      	mov	r2, fp
     6d8:	1871      	adds	r1, r6, r1
     6da:	4640      	mov	r0, r8
     6dc:	f004 fe11 	bl	5302 <flash_area_write>
        if (rc != 0) {
     6e0:	2800      	cmp	r0, #0
     6e2:	d1f3      	bne.n	6cc <boot_copy_region+0x3c>
     6e4:	f8c4 5600 	str.w	r5, [r4, #1536]	; 0x600
        bytes_copied += chunk_sz;
     6e8:	443e      	add	r6, r7
     6ea:	f8c4 5604 	str.w	r5, [r4, #1540]	; 0x604
     6ee:	f8c4 5608 	str.w	r5, [r4, #1544]	; 0x608
     6f2:	f8c4 560c 	str.w	r5, [r4, #1548]	; 0x60c
     6f6:	f8c4 5610 	str.w	r5, [r4, #1552]	; 0x610
     6fa:	f8c4 5614 	str.w	r5, [r4, #1556]	; 0x614
     6fe:	f8c4 5618 	str.w	r5, [r4, #1560]	; 0x618
     702:	f8c4 561c 	str.w	r5, [r4, #1564]	; 0x61c
        MCUBOOT_WATCHDOG_FEED();
     706:	e7cd      	b.n	6a4 <boot_copy_region+0x14>
     708:	40010000 	.word	0x40010000
     70c:	6e524635 	.word	0x6e524635
     710:	20000118 	.word	0x20000118

00000714 <context_boot_go>:
#endif
}

fih_int
context_boot_go(struct boot_loader_state *state, struct boot_rsp *rsp)
{
     714:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    size_t slot;
    struct boot_status bs;
    int rc = -1;
    fih_int fih_rc = FIH_FAILURE;
     718:	4b80      	ldr	r3, [pc, #512]	; (91c <FIH_LABEL_FIH_CALL_END_2240+0x46>)
     71a:	681e      	ldr	r6, [r3, #0]
        boot_enc_zeroize(BOOT_CURR_ENC(state));
#endif

        image_index = BOOT_CURR_IMG(state);

        BOOT_IMG(state, BOOT_PRIMARY_SLOT).sectors =
     71c:	4b80      	ldr	r3, [pc, #512]	; (920 <FIH_LABEL_FIH_CALL_END_2240+0x4a>)
     71e:	6243      	str	r3, [r0, #36]	; 0x24
{
     720:	460f      	mov	r7, r1
            primary_slot_sectors[image_index];
        BOOT_IMG(state, BOOT_SECONDARY_SLOT).sectors =
     722:	4b80      	ldr	r3, [pc, #512]	; (924 <FIH_LABEL_FIH_CALL_END_2240+0x4e>)
     724:	6503      	str	r3, [r0, #80]	; 0x50

        /* Open primary and secondary image areas for the duration
         * of this call.
         */
        for (slot = 0; slot < BOOT_NUM_SLOTS; slot++) {
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
     726:	2100      	movs	r1, #0
{
     728:	b085      	sub	sp, #20
     72a:	4604      	mov	r4, r0
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
     72c:	4608      	mov	r0, r1
     72e:	f004 f8f5 	bl	491c <flash_area_id_from_multi_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(state, slot));
     732:	f104 0120 	add.w	r1, r4, #32
     736:	b2c0      	uxtb	r0, r0
     738:	f000 fbc8 	bl	ecc <flash_area_open>
            fa_id = flash_area_id_from_multi_image_slot(image_index, slot);
     73c:	2101      	movs	r1, #1
     73e:	2000      	movs	r0, #0
     740:	f004 f8ec 	bl	491c <flash_area_id_from_multi_image_slot>
            rc = flash_area_open(fa_id, &BOOT_IMG_AREA(state, slot));
     744:	f104 014c 	add.w	r1, r4, #76	; 0x4c
     748:	b2c0      	uxtb	r0, r0
     74a:	f000 fbbf 	bl	ecc <flash_area_open>
     74e:	4605      	mov	r5, r0
    rc = boot_read_sectors(state);
     750:	4620      	mov	r0, r4
     752:	f004 fa40 	bl	4bd6 <boot_read_sectors>
    if (rc != 0) {
     756:	2800      	cmp	r0, #0
     758:	d148      	bne.n	7ec <context_boot_go+0xd8>
    rc = boot_read_image_headers(state, false, NULL);
     75a:	2200      	movs	r2, #0
     75c:	4611      	mov	r1, r2
     75e:	4620      	mov	r0, r4
     760:	f004 f9df 	bl	4b22 <boot_read_image_headers>
    if (rc != 0) {
     764:	2800      	cmp	r0, #0
     766:	d158      	bne.n	81a <CONFIG_ISR_STACK_SIZE+0x1a>
    if (boot_slots_compatible(state)) {
     768:	4620      	mov	r0, r4
     76a:	f004 fbc7 	bl	4efc <boot_slots_compatible>
     76e:	2800      	cmp	r0, #0
     770:	d053      	beq.n	81a <CONFIG_ISR_STACK_SIZE+0x1a>
        boot_status_reset(bs);
     772:	4668      	mov	r0, sp
     774:	f004 fa51 	bl	4c1a <boot_status_reset>
        rc = swap_read_status(state, bs);
     778:	4669      	mov	r1, sp
     77a:	4620      	mov	r0, r4
     77c:	f004 faeb 	bl	4d56 <swap_read_status>
        if (rc != 0) {
     780:	2800      	cmp	r0, #0
     782:	d14a      	bne.n	81a <CONFIG_ISR_STACK_SIZE+0x1a>
        rc = boot_read_image_headers(state, !boot_status_is_reset(bs), bs);
     784:	4668      	mov	r0, sp
     786:	f004 fa51 	bl	4c2c <boot_status_is_reset>
     78a:	f080 0001 	eor.w	r0, r0, #1
     78e:	466a      	mov	r2, sp
     790:	b2c1      	uxtb	r1, r0
     792:	4620      	mov	r0, r4
     794:	f004 f9c5 	bl	4b22 <boot_read_image_headers>
        if (rc != 0) {
     798:	4602      	mov	r2, r0
     79a:	bbf0      	cbnz	r0, 81a <CONFIG_ISR_STACK_SIZE+0x1a>
        if (!boot_status_is_reset(bs)) {
     79c:	4668      	mov	r0, sp
     79e:	f004 fa45 	bl	4c2c <boot_status_is_reset>
     7a2:	4680      	mov	r8, r0
     7a4:	bbe8      	cbnz	r0, 822 <CONFIG_ISR_STACK_SIZE+0x22>
    rc = boot_swap_image(state, bs);
     7a6:	4669      	mov	r1, sp
     7a8:	4620      	mov	r0, r4
     7aa:	f7ff ff3f 	bl	62c <boot_swap_image>
    BOOT_SWAP_TYPE(state) = bs->swap_type;
     7ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
     7b2:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    if (bs->swap_type == BOOT_SWAP_TYPE_REVERT ||
     7b6:	3b03      	subs	r3, #3
     7b8:	2b01      	cmp	r3, #1
     7ba:	d806      	bhi.n	7ca <context_boot_go+0xb6>
        rc = swap_set_image_ok(BOOT_CURR_IMG(state));
     7bc:	4640      	mov	r0, r8
     7be:	f004 fb19 	bl	4df4 <swap_set_image_ok>
        if (rc != 0) {
     7c2:	b110      	cbz	r0, 7ca <context_boot_go+0xb6>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_PANIC;
     7c4:	23ff      	movs	r3, #255	; 0xff
     7c6:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    if (BOOT_IS_UPGRADE(bs->swap_type)) {
     7ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
     7ce:	3b02      	subs	r3, #2
     7d0:	2b02      	cmp	r3, #2
     7d2:	d806      	bhi.n	7e2 <context_boot_go+0xce>
        rc = swap_set_copy_done(BOOT_CURR_IMG(state));
     7d4:	2000      	movs	r0, #0
     7d6:	f004 fafb 	bl	4dd0 <swap_set_copy_done>
        if (rc != 0) {
     7da:	b110      	cbz	r0, 7e2 <context_boot_go+0xce>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_PANIC;
     7dc:	23ff      	movs	r3, #255	; 0xff
     7de:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
    if (BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_PANIC) {
     7e2:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
     7e6:	2bff      	cmp	r3, #255	; 0xff
     7e8:	d112      	bne.n	810 <CONFIG_ISR_STACK_SIZE+0x10>
        while (1) {}
     7ea:	e7fe      	b.n	7ea <context_boot_go+0xd6>
        BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
     7ec:	2301      	movs	r3, #1
        if (rc == BOOT_EFLASH)
     7ee:	4298      	cmp	r0, r3
        BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
     7f0:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        if (rc == BOOT_EFLASH)
     7f4:	d1b1      	bne.n	75a <context_boot_go+0x46>
#endif

        /* Determine swap type and complete swap if it has been aborted. */
        boot_prepare_image_for_update(state, &bs);

        if (BOOT_IS_UPGRADE(BOOT_SWAP_TYPE(state))) {
     7f6:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
        /* Indicate that swap is not aborted */
        boot_status_reset(&bs);
#endif /* (BOOT_IMAGE_NUMBER > 1) */

        /* Set the previously determined swap type */
        bs.swap_type = BOOT_SWAP_TYPE(state);
     7fa:	f88d 3007 	strb.w	r3, [sp, #7]

        switch (BOOT_SWAP_TYPE(state)) {
     7fe:	2b04      	cmp	r3, #4
     800:	d838      	bhi.n	874 <FIH_LABEL_FIH_CALL_END_2051+0x10>
     802:	2b01      	cmp	r3, #1
     804:	d83c      	bhi.n	880 <FIH_LABEL_FIH_CALL_END_2051+0x1c>
     806:	d053      	beq.n	8b0 <FIH_LABEL_FIH_CALL_END_2051+0x4c>
            }
#endif /* !MCUBOOT_OVERWRITE_ONLY */
            break;

        default:
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_PANIC;
     808:	23ff      	movs	r3, #255	; 0xff
     80a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
     80e:	e04f      	b.n	8b0 <FIH_LABEL_FIH_CALL_END_2051+0x4c>
            rc = boot_read_image_headers(state, false, bs);
     810:	466a      	mov	r2, sp
     812:	2100      	movs	r1, #0
     814:	4620      	mov	r0, r4
     816:	f004 f984 	bl	4b22 <boot_read_image_headers>
            BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_NONE;
     81a:	2301      	movs	r3, #1
                    BOOT_SWAP_TYPE(state) = bs->swap_type;
     81c:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
     820:	e7e9      	b.n	7f6 <context_boot_go+0xe2>
            if (bs->swap_type == BOOT_SWAP_TYPE_NONE) {
     822:	f89d 9007 	ldrb.w	r9, [sp, #7]
     826:	f1b9 0f01 	cmp.w	r9, #1
     82a:	d117      	bne.n	85c <FIH_LABEL_FIH_CALL_START_2031>
    swap_type = boot_swap_type_multi(BOOT_CURR_IMG(state));
     82c:	4610      	mov	r0, r2
     82e:	f001 fe5d 	bl	24ec <boot_swap_type_multi>
    if (BOOT_IS_UPGRADE(swap_type)) {
     832:	1e83      	subs	r3, r0, #2
     834:	2b02      	cmp	r3, #2
    swap_type = boot_swap_type_multi(BOOT_CURR_IMG(state));
     836:	4680      	mov	r8, r0
    if (BOOT_IS_UPGRADE(swap_type)) {
     838:	d80d      	bhi.n	856 <FIH_LABEL_FIH_CALL_END_1966+0x14>

0000083a <FIH_LABEL_FIH_CALL_START_1942>:
        FIH_CALL(boot_validate_slot, fih_rc, state, BOOT_SECONDARY_SLOT, bs);
     83a:	4649      	mov	r1, r9
     83c:	4620      	mov	r0, r4
     83e:	f7ff fe81 	bl	544 <boot_validate_slot.isra.0>

00000842 <FIH_LABEL_FIH_CALL_END_1966>:
        if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
     842:	4b39      	ldr	r3, [pc, #228]	; (928 <FIH_LABEL_FIH_CALL_END_2240+0x52>)
     844:	681b      	ldr	r3, [r3, #0]
     846:	4298      	cmp	r0, r3
     848:	d005      	beq.n	856 <FIH_LABEL_FIH_CALL_END_1966+0x14>
                swap_type = BOOT_SWAP_TYPE_FAIL;
     84a:	2801      	cmp	r0, #1
     84c:	bf0c      	ite	eq
     84e:	f04f 0801 	moveq.w	r8, #1
     852:	f04f 0805 	movne.w	r8, #5
                BOOT_SWAP_TYPE(state) = boot_validated_swap_type(state, bs);
     856:	f884 8058 	strb.w	r8, [r4, #88]	; 0x58
     85a:	e7cc      	b.n	7f6 <context_boot_go+0xe2>

0000085c <FIH_LABEL_FIH_CALL_START_2031>:
                FIH_CALL(boot_validate_slot, fih_rc,
     85c:	2101      	movs	r1, #1
     85e:	4620      	mov	r0, r4
     860:	f7ff fe70 	bl	544 <boot_validate_slot.isra.0>

00000864 <FIH_LABEL_FIH_CALL_END_2051>:
                if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
     864:	4b30      	ldr	r3, [pc, #192]	; (928 <FIH_LABEL_FIH_CALL_END_2240+0x52>)
     866:	681b      	ldr	r3, [r3, #0]
     868:	4298      	cmp	r0, r3
                    BOOT_SWAP_TYPE(state) = bs->swap_type;
     86a:	bf0c      	ite	eq
     86c:	f89d 3007 	ldrbeq.w	r3, [sp, #7]
                    BOOT_SWAP_TYPE(state) = BOOT_SWAP_TYPE_FAIL;
     870:	2305      	movne	r3, #5
                    BOOT_SWAP_TYPE(state) = bs->swap_type;
     872:	e7d3      	b.n	81c <CONFIG_ISR_STACK_SIZE+0x1c>
        switch (BOOT_SWAP_TYPE(state)) {
     874:	2b05      	cmp	r3, #5
     876:	d1c7      	bne.n	808 <CONFIG_ISR_STACK_SIZE+0x8>
            rc = swap_set_image_ok(BOOT_CURR_IMG(state));
     878:	2000      	movs	r0, #0
     87a:	f004 fabb 	bl	4df4 <swap_set_image_ok>
     87e:	e012      	b.n	8a6 <FIH_LABEL_FIH_CALL_END_2051+0x42>
        rc = boot_swap_image(state, bs);
     880:	4669      	mov	r1, sp
     882:	4620      	mov	r0, r4
     884:	f7ff fed2 	bl	62c <boot_swap_image>
    swap_type = BOOT_SWAP_TYPE(state);
     888:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
    if (swap_type == BOOT_SWAP_TYPE_REVERT ||
     88c:	1eda      	subs	r2, r3, #3
     88e:	2a01      	cmp	r2, #1
        rc = boot_swap_image(state, bs);
     890:	4605      	mov	r5, r0
    if (swap_type == BOOT_SWAP_TYPE_REVERT ||
     892:	d80b      	bhi.n	8ac <FIH_LABEL_FIH_CALL_END_2051+0x48>
        rc = swap_set_image_ok(BOOT_CURR_IMG(state));
     894:	2000      	movs	r0, #0
     896:	f004 faad 	bl	4df4 <swap_set_image_ok>
        if (rc != 0) {
     89a:	4605      	mov	r5, r0
     89c:	2800      	cmp	r0, #0
     89e:	d1b3      	bne.n	808 <CONFIG_ISR_STACK_SIZE+0x8>
        rc = swap_set_copy_done(BOOT_CURR_IMG(state));
     8a0:	2000      	movs	r0, #0
     8a2:	f004 fa95 	bl	4dd0 <swap_set_copy_done>
            if (rc != 0) {
     8a6:	4605      	mov	r5, r0
     8a8:	b110      	cbz	r0, 8b0 <FIH_LABEL_FIH_CALL_END_2051+0x4c>
     8aa:	e7ad      	b.n	808 <CONFIG_ISR_STACK_SIZE+0x8>
    if (BOOT_IS_UPGRADE(swap_type)) {
     8ac:	2b02      	cmp	r3, #2
     8ae:	d0f7      	beq.n	8a0 <FIH_LABEL_FIH_CALL_END_2051+0x3c>
        }

        if (BOOT_SWAP_TYPE(state) == BOOT_SWAP_TYPE_PANIC) {
     8b0:	f894 3058 	ldrb.w	r3, [r4, #88]	; 0x58
     8b4:	2bff      	cmp	r3, #255	; 0xff
     8b6:	d100      	bne.n	8ba <FIH_LABEL_FIH_CALL_END_2051+0x56>
            BOOT_LOG_ERR("panic!");
            assert(0);

            /* Loop forever... */
            FIH_PANIC;
     8b8:	e7fe      	b.n	8b8 <FIH_LABEL_FIH_CALL_END_2051+0x54>
#if BOOT_IMAGE_NUMBER > 1
        if (state->img_mask[BOOT_CURR_IMG(state)]) {
            continue;
        }
#endif
        if (BOOT_SWAP_TYPE(state) != BOOT_SWAP_TYPE_NONE) {
     8ba:	2b01      	cmp	r3, #1
     8bc:	d006      	beq.n	8cc <FIH_LABEL_FIH_CALL_START_2224>
            /* Attempt to read an image header from each slot. Ensure that image
             * headers in slots are aligned with headers in boot_data.
             */
            rc = boot_read_image_headers(state, false, &bs);
     8be:	466a      	mov	r2, sp
     8c0:	2100      	movs	r1, #0
     8c2:	4620      	mov	r0, r4
     8c4:	f004 f92d 	bl	4b22 <boot_read_image_headers>
            if (rc != 0) {
     8c8:	4605      	mov	r5, r0
     8ca:	b9d0      	cbnz	r0, 902 <FIH_LABEL_FIH_CALL_END_2240+0x2c>

000008cc <FIH_LABEL_FIH_CALL_START_2224>:
	 * primary.
	 */
	if (BOOT_CURR_IMG(state) == 0)
#endif
	{
            FIH_CALL(boot_validate_slot, fih_rc, state, BOOT_PRIMARY_SLOT, NULL);
     8cc:	2100      	movs	r1, #0
     8ce:	4620      	mov	r0, r4
     8d0:	f7ff fe38 	bl	544 <boot_validate_slot.isra.0>
     8d4:	4606      	mov	r6, r0

000008d6 <FIH_LABEL_FIH_CALL_END_2240>:
            if (fih_not_eq(fih_rc, FIH_SUCCESS)) {
     8d6:	f8df 8050 	ldr.w	r8, [pc, #80]	; 928 <FIH_LABEL_FIH_CALL_END_2240+0x52>
     8da:	f8d8 3000 	ldr.w	r3, [r8]
     8de:	4283      	cmp	r3, r0
     8e0:	d10f      	bne.n	902 <FIH_LABEL_FIH_CALL_END_2240+0x2c>
    /*
     * Since the boot_status struct stores plaintext encryption keys, reset
     * them here to avoid the possibility of jumping into an image that could
     * easily recover them.
     */
    memset(&bs, 0, sizeof(struct boot_status));
     8e2:	2210      	movs	r2, #16
     8e4:	2100      	movs	r1, #0
     8e6:	4668      	mov	r0, sp
     8e8:	f004 fdc1 	bl	546e <memset>
    rsp->br_flash_dev_id = flash_area_get_device_id(BOOT_IMG_AREA(state, active_slot));
     8ec:	6a20      	ldr	r0, [r4, #32]
     8ee:	f004 f81f 	bl	4930 <flash_area_get_device_id>
     8f2:	7138      	strb	r0, [r7, #4]
 */
int flash_area_sector_from_off(off_t off, struct flash_sector *sector);

static inline uint32_t flash_area_get_off(const struct flash_area *fa)
{
	return (uint32_t)fa->fa_off;
     8f4:	6a23      	ldr	r3, [r4, #32]

    fill_rsp(state, rsp);

    fih_rc = FIH_SUCCESS;
     8f6:	f8d8 6000 	ldr.w	r6, [r8]
    rsp->br_image_off = boot_img_slot_off(state, active_slot);
     8fa:	685b      	ldr	r3, [r3, #4]
     8fc:	60bb      	str	r3, [r7, #8]
    rsp->br_hdr = boot_img_hdr(state, active_slot);
     8fe:	603c      	str	r4, [r7, #0]
        rc = boot_add_shared_data(state, BOOT_PRIMARY_SLOT);
     900:	2500      	movs	r5, #0
            flash_area_close(BOOT_IMG_AREA(state, BOOT_NUM_SLOTS - 1 - slot));
     902:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
     904:	f004 fce0 	bl	52c8 <flash_area_close>
     908:	6a20      	ldr	r0, [r4, #32]
     90a:	f004 fcdd 	bl	52c8 <flash_area_close>
    if (rc) {
        fih_rc = fih_int_encode(rc);
    }

    FIH_RET(fih_rc);
}
     90e:	2d00      	cmp	r5, #0
     910:	bf14      	ite	ne
     912:	4628      	movne	r0, r5
     914:	4630      	moveq	r0, r6
     916:	b005      	add	sp, #20
     918:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     91c:	20000000 	.word	0x20000000
     920:	20000518 	.word	0x20000518
     924:	20000d18 	.word	0x20000d18
     928:	200000b4 	.word	0x200000b4

0000092c <boot_go>:
 *
 * @return                      FIH_SUCCESS on success; nonzero on failure.
 */
fih_int
boot_go(struct boot_rsp *rsp)
{
     92c:	b538      	push	{r3, r4, r5, lr}
void boot_state_clear(struct boot_loader_state *state)
{
    if (state != NULL) {
        memset(state, 0, sizeof(struct boot_loader_state));
    } else {
        memset(&boot_data, 0, sizeof(struct boot_loader_state));
     92e:	4d06      	ldr	r5, [pc, #24]	; (948 <FIH_LABEL_FIH_CALL_END_2914+0x4>)
{
     930:	4604      	mov	r4, r0
        memset(&boot_data, 0, sizeof(struct boot_loader_state));
     932:	2260      	movs	r2, #96	; 0x60
     934:	2100      	movs	r1, #0
     936:	4628      	mov	r0, r5
     938:	f004 fd99 	bl	546e <memset>

0000093c <FIH_LABEL_FIH_CALL_START_2899>:
    FIH_CALL(context_boot_go, fih_rc, &boot_data, rsp);
     93c:	4621      	mov	r1, r4
     93e:	4628      	mov	r0, r5
     940:	f7ff fee8 	bl	714 <context_boot_go>

00000944 <FIH_LABEL_FIH_CALL_END_2914>:
}
     944:	bd38      	pop	{r3, r4, r5, pc}
     946:	bf00      	nop
     948:	200000b8 	.word	0x200000b8

0000094c <boot_read_image_header>:
static uint32_t g_last_idx = UINT32_MAX;

int
boot_read_image_header(struct boot_loader_state *state, int slot,
                       struct image_header *out_hdr, struct boot_status *bs)
{
     94c:	b573      	push	{r0, r1, r4, r5, r6, lr}
     94e:	4616      	mov	r6, r2
#if (BOOT_IMAGE_NUMBER == 1)
    (void)state;
#endif

    off = 0;
    if (bs) {
     950:	461c      	mov	r4, r3
     952:	b333      	cbz	r3, 9a2 <boot_read_image_header+0x56>
	return fs->fs_off;
}

static inline uint32_t flash_sector_get_size(const struct flash_sector *fs)
{
	return fs->fs_size;
     954:	6a43      	ldr	r3, [r0, #36]	; 0x24
     956:	685d      	ldr	r5, [r3, #4]
        sz = boot_img_sector_size(state, BOOT_PRIMARY_SLOT, 0);
        if (bs->op == BOOT_STATUS_OP_MOVE) {
     958:	7963      	ldrb	r3, [r4, #5]
     95a:	2b01      	cmp	r3, #1
     95c:	d115      	bne.n	98a <boot_read_image_header+0x3e>
            if (slot == 0 && bs->idx > g_last_idx) {
     95e:	bb01      	cbnz	r1, 9a2 <boot_read_image_header+0x56>
     960:	4b1f      	ldr	r3, [pc, #124]	; (9e0 <boot_read_image_header+0x94>)
     962:	6822      	ldr	r2, [r4, #0]
     964:	681b      	ldr	r3, [r3, #0]
    off = 0;
     966:	429a      	cmp	r2, r3
     968:	bf98      	it	ls
     96a:	2500      	movls	r5, #0
                }
            }
        }
    }

    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
     96c:	2000      	movs	r0, #0
     96e:	f003 ffd5 	bl	491c <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
     972:	a901      	add	r1, sp, #4
     974:	b2c0      	uxtb	r0, r0
     976:	f000 faa9 	bl	ecc <flash_area_open>
    if (rc != 0) {
     97a:	b1f0      	cbz	r0, 9ba <boot_read_image_header+0x6e>
        rc = BOOT_EFLASH;
     97c:	2501      	movs	r5, #1
    }

    rc = 0;

done:
    flash_area_close(fap);
     97e:	9801      	ldr	r0, [sp, #4]
     980:	f004 fca2 	bl	52c8 <flash_area_close>
    return rc;
}
     984:	4628      	mov	r0, r5
     986:	b002      	add	sp, #8
     988:	bd70      	pop	{r4, r5, r6, pc}
        } else if (bs->op == BOOT_STATUS_OP_SWAP) {
     98a:	2b02      	cmp	r3, #2
     98c:	d109      	bne.n	9a2 <boot_read_image_header+0x56>
            if (bs->idx > 1 && bs->idx <= g_last_idx) {
     98e:	6823      	ldr	r3, [r4, #0]
     990:	2b01      	cmp	r3, #1
     992:	d908      	bls.n	9a6 <boot_read_image_header+0x5a>
     994:	4a12      	ldr	r2, [pc, #72]	; (9e0 <boot_read_image_header+0x94>)
     996:	6812      	ldr	r2, [r2, #0]
     998:	4293      	cmp	r3, r2
     99a:	d802      	bhi.n	9a2 <boot_read_image_header+0x56>
                if (slot == 0) {
     99c:	fab1 f181 	clz	r1, r1
     9a0:	0949      	lsrs	r1, r1, #5
    off = 0;
     9a2:	2500      	movs	r5, #0
     9a4:	e7e2      	b.n	96c <boot_read_image_header+0x20>
            } else if (bs->idx == 1) {
     9a6:	d1fc      	bne.n	9a2 <boot_read_image_header+0x56>
                if (slot == 0) {
     9a8:	2900      	cmp	r1, #0
     9aa:	d0df      	beq.n	96c <boot_read_image_header+0x20>
                if (slot == 1 && bs->state == 2) {
     9ac:	2901      	cmp	r1, #1
     9ae:	d1f8      	bne.n	9a2 <boot_read_image_header+0x56>
     9b0:	7921      	ldrb	r1, [r4, #4]
     9b2:	3902      	subs	r1, #2
     9b4:	bf18      	it	ne
     9b6:	2101      	movne	r1, #1
     9b8:	e7f3      	b.n	9a2 <boot_read_image_header+0x56>
    rc = flash_area_read(fap, off, out_hdr, sizeof *out_hdr);
     9ba:	4629      	mov	r1, r5
     9bc:	9801      	ldr	r0, [sp, #4]
     9be:	2320      	movs	r3, #32
     9c0:	4632      	mov	r2, r6
     9c2:	f004 fc82 	bl	52ca <flash_area_read>
    if (rc != 0) {
     9c6:	4605      	mov	r5, r0
     9c8:	2800      	cmp	r0, #0
     9ca:	d1d7      	bne.n	97c <boot_read_image_header+0x30>
    if (bs != NULL && out_hdr->ih_magic != IMAGE_MAGIC) {
     9cc:	2c00      	cmp	r4, #0
     9ce:	d0d6      	beq.n	97e <boot_read_image_header+0x32>
     9d0:	6835      	ldr	r5, [r6, #0]
     9d2:	4804      	ldr	r0, [pc, #16]	; (9e4 <boot_read_image_header+0x98>)
     9d4:	1a2d      	subs	r5, r5, r0
     9d6:	bf18      	it	ne
     9d8:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
     9dc:	e7cf      	b.n	97e <boot_read_image_header+0x32>
     9de:	bf00      	nop
     9e0:	20000004 	.word	0x20000004
     9e4:	96f3b83d 	.word	0x96f3b83d

000009e8 <fixup_revert>:
 * upgrade (by initializing the secondary slot).
 */
void
fixup_revert(const struct boot_loader_state *state, struct boot_status *bs,
        const struct flash_area *fap_sec)
{
     9e8:	b573      	push	{r0, r1, r4, r5, r6, lr}
#if (BOOT_IMAGE_NUMBER == 1)
    (void)state;
#endif

    /* No fixup required */
    if (bs->swap_type != BOOT_SWAP_TYPE_REVERT ||
     9ea:	684b      	ldr	r3, [r1, #4]
{
     9ec:	4614      	mov	r4, r2
    if (bs->swap_type != BOOT_SWAP_TYPE_REVERT ||
     9ee:	4a11      	ldr	r2, [pc, #68]	; (a34 <fixup_revert+0x4c>)
     9f0:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
     9f4:	4293      	cmp	r3, r2
{
     9f6:	4606      	mov	r6, r0
     9f8:	460d      	mov	r5, r1
    if (bs->swap_type != BOOT_SWAP_TYPE_REVERT ||
     9fa:	d118      	bne.n	a2e <fixup_revert+0x46>
        bs->op != BOOT_STATUS_OP_MOVE ||
     9fc:	680b      	ldr	r3, [r1, #0]
     9fe:	2b01      	cmp	r3, #1
     a00:	d115      	bne.n	a2e <fixup_revert+0x46>
        bs->idx != BOOT_STATUS_IDX_0) {
        return;
    }

    rc = boot_read_swap_state(fap_sec, &swap_state);
     a02:	4669      	mov	r1, sp
     a04:	4620      	mov	r0, r4
     a06:	f001 fd1d 	bl	2444 <boot_read_swap_state>
    assert(rc == 0);

    BOOT_LOG_SWAP_STATE("Secondary image", &swap_state);

    if (swap_state.magic == BOOT_MAGIC_UNSET) {
     a0a:	f89d 3000 	ldrb.w	r3, [sp]
     a0e:	2b03      	cmp	r3, #3
     a10:	d10d      	bne.n	a2e <fixup_revert+0x46>
        rc = swap_erase_trailer_sectors(state, fap_sec);
     a12:	4621      	mov	r1, r4
     a14:	4630      	mov	r0, r6
     a16:	f004 f94a 	bl	4cae <swap_erase_trailer_sectors>
        assert(rc == 0);

        rc = boot_write_image_ok(fap_sec);
     a1a:	4620      	mov	r0, r4
     a1c:	f005 f805 	bl	5a2a <boot_write_image_ok>
        assert(rc == 0);

        rc = boot_write_swap_size(fap_sec, bs->swap_size);
     a20:	68a9      	ldr	r1, [r5, #8]
     a22:	4620      	mov	r0, r4
     a24:	f004 f86e 	bl	4b04 <boot_write_swap_size>
        assert(rc == 0);

        rc = boot_write_magic(fap_sec);
     a28:	4620      	mov	r0, r4
     a2a:	f001 fceb 	bl	2404 <boot_write_magic>
        assert(rc == 0);
    }
}
     a2e:	b002      	add	sp, #8
     a30:	bd70      	pop	{r4, r5, r6, pc}
     a32:	bf00      	nop
     a34:	04000100 	.word	0x04000100

00000a38 <swap_run>:

void
swap_run(struct boot_loader_state *state, struct boot_status *bs,
         uint32_t copy_size)
{
     a38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     a3c:	ed2d 8b02 	vpush	{d8}
     a40:	6a43      	ldr	r3, [r0, #36]	; 0x24
     a42:	460c      	mov	r4, r1
     a44:	685e      	ldr	r6, [r3, #4]
     a46:	b089      	sub	sp, #36	; 0x24
     a48:	4605      	mov	r5, r0
     a4a:	2101      	movs	r1, #1
    const struct flash_area *fap_sec;
    int rc;

    BOOT_LOG_INF("Starting swap using move algorithm.");

    sz = 0;
     a4c:	2300      	movs	r3, #0
    g_last_idx = 0;

    sector_sz = boot_img_sector_size(state, BOOT_PRIMARY_SLOT, 0);
    while (1) {
        sz += sector_sz;
     a4e:	4433      	add	r3, r6
        /* Skip to next sector because all sectors will be moved up. */
        g_last_idx++;
        if (sz >= copy_size) {
     a50:	4293      	cmp	r3, r2
     a52:	4608      	mov	r0, r1
     a54:	f101 0101 	add.w	r1, r1, #1
     a58:	d3f9      	bcc.n	a4e <swap_run+0x16>
     a5a:	f8df b1dc 	ldr.w	fp, [pc, #476]	; c38 <swap_run+0x200>
     a5e:	f8cb 0000 	str.w	r0, [fp]
    }

    /*
     * When starting a new swap upgrade, check that there is enough space.
     */
    if (boot_status_is_reset(bs)) {
     a62:	4620      	mov	r0, r4
     a64:	f004 f8e2 	bl	4c2c <boot_status_is_reset>
     a68:	b1a8      	cbz	r0, a96 <swap_run+0x5e>
        sz = 0;
        trailer_sz = boot_trailer_sz(BOOT_WRITE_SZ(state));
     a6a:	6de8      	ldr	r0, [r5, #92]	; 0x5c
     a6c:	f004 f828 	bl	4ac0 <boot_trailer_sz>
        first_trailer_idx = boot_img_num_sectors(state, BOOT_PRIMARY_SLOT) - 1;
     a70:	6aab      	ldr	r3, [r5, #40]	; 0x28
        sz = 0;
     a72:	2200      	movs	r2, #0
        first_trailer_idx = boot_img_num_sectors(state, BOOT_PRIMARY_SLOT) - 1;
     a74:	3b01      	subs	r3, #1

        while (1) {
            sz += sector_sz;
     a76:	4432      	add	r2, r6
            if  (sz >= trailer_sz) {
     a78:	4290      	cmp	r0, r2
     a7a:	d901      	bls.n	a80 <swap_run+0x48>
                break;
            }
            first_trailer_idx--;
     a7c:	3b01      	subs	r3, #1
            sz += sector_sz;
     a7e:	e7fa      	b.n	a76 <swap_run+0x3e>
        }

        if (g_last_idx >= first_trailer_idx) {
     a80:	f8db 2000 	ldr.w	r2, [fp]
     a84:	429a      	cmp	r2, r3
     a86:	d306      	bcc.n	a96 <swap_run+0x5e>
            BOOT_LOG_WRN("Not enough free space to run swap upgrade");
            BOOT_LOG_WRN("required %d bytes but only %d are available",
                         (g_last_idx + 1) * sector_sz ,
                         first_trailer_idx * sector_sz);
            bs->swap_type = BOOT_SWAP_TYPE_NONE;
     a88:	2301      	movs	r3, #1
     a8a:	71e3      	strb	r3, [r4, #7]
        idx++;
    }

    flash_area_close(fap_pri);
    flash_area_close(fap_sec);
}
     a8c:	b009      	add	sp, #36	; 0x24
     a8e:	ecbd 8b02 	vpop	{d8}
     a92:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index), &fap_pri);
     a96:	a906      	add	r1, sp, #24
     a98:	2003      	movs	r0, #3
     a9a:	f000 fa17 	bl	ecc <flash_area_open>
    rc = flash_area_open(FLASH_AREA_IMAGE_SECONDARY(image_index), &fap_sec);
     a9e:	a907      	add	r1, sp, #28
     aa0:	2001      	movs	r0, #1
     aa2:	f000 fa13 	bl	ecc <flash_area_open>
    fixup_revert(state, bs, fap_sec);
     aa6:	9a07      	ldr	r2, [sp, #28]
     aa8:	4621      	mov	r1, r4
     aaa:	4628      	mov	r0, r5
     aac:	f7ff ff9c 	bl	9e8 <fixup_revert>
    if (bs->op == BOOT_STATUS_OP_MOVE) {
     ab0:	7963      	ldrb	r3, [r4, #5]
     ab2:	2b01      	cmp	r3, #1
     ab4:	d108      	bne.n	ac8 <swap_run+0x90>
        idx = g_last_idx;
     ab6:	f8db 7000 	ldr.w	r7, [fp]
    BOOT_STATUS_ASSERT(rc == 0);
     aba:	f8df a180 	ldr.w	sl, [pc, #384]	; c3c <swap_run+0x204>
            if (idx <= (g_last_idx - bs->idx + 1)) {
     abe:	f8db 3000 	ldr.w	r3, [fp]
        while (idx > 0) {
     ac2:	b9a7      	cbnz	r7, aee <swap_run+0xb6>
        bs->idx = BOOT_STATUS_IDX_0;
     ac4:	2301      	movs	r3, #1
     ac6:	6023      	str	r3, [r4, #0]
    bs->op = BOOT_STATUS_OP_SWAP;
     ac8:	f04f 0302 	mov.w	r3, #2
        BOOT_STATUS_ASSERT(rc == 0);
     acc:	f8df 816c 	ldr.w	r8, [pc, #364]	; c3c <swap_run+0x204>
    bs->op = BOOT_STATUS_OP_SWAP;
     ad0:	7163      	strb	r3, [r4, #5]
    idx = 1;
     ad2:	2701      	movs	r7, #1
    while (idx <= g_last_idx) {
     ad4:	f8db 3000 	ldr.w	r3, [fp]
            boot_swap_sectors(idx, sector_sz, state, bs, fap_pri, fap_sec);
     ad8:	f8dd 9018 	ldr.w	r9, [sp, #24]
    while (idx <= g_last_idx) {
     adc:	42bb      	cmp	r3, r7
     ade:	d24d      	bcs.n	b7c <swap_run+0x144>
    flash_area_close(fap_pri);
     ae0:	4648      	mov	r0, r9
     ae2:	f004 fbf1 	bl	52c8 <flash_area_close>
    flash_area_close(fap_sec);
     ae6:	9807      	ldr	r0, [sp, #28]
     ae8:	f004 fbee 	bl	52c8 <flash_area_close>
     aec:	e7ce      	b.n	a8c <swap_run+0x54>
            if (idx <= (g_last_idx - bs->idx + 1)) {
     aee:	6822      	ldr	r2, [r4, #0]
     af0:	3301      	adds	r3, #1
     af2:	1a9b      	subs	r3, r3, r2
     af4:	42bb      	cmp	r3, r7
     af6:	d33f      	bcc.n	b78 <swap_run+0x140>

static inline uint32_t
boot_img_sector_off(const struct boot_loader_state *state, size_t slot,
                    size_t sector)
{
    return flash_sector_get_off(&BOOT_IMG(state, slot).sectors[sector]) -
     af8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
                boot_move_sector_up(idx, sector_sz, state, bs, fap_pri, fap_sec);
     afa:	f8dd 8018 	ldr.w	r8, [sp, #24]
	return fs->fs_off;
     afe:	6819      	ldr	r1, [r3, #0]
     b00:	f853 0037 	ldr.w	r0, [r3, r7, lsl #3]
     b04:	eb03 03c7 	add.w	r3, r3, r7, lsl #3
    if (bs->idx == BOOT_STATUS_IDX_0) {
     b08:	2a01      	cmp	r2, #1
     b0a:	f853 3c08 	ldr.w	r3, [r3, #-8]
     b0e:	eba3 0301 	sub.w	r3, r3, r1
     b12:	ee08 3a10 	vmov	s16, r3
     b16:	eba0 0901 	sub.w	r9, r0, r1
     b1a:	d112      	bne.n	b42 <swap_run+0x10a>
        if (bs->source != BOOT_STATUS_SOURCE_PRIMARY_SLOT) {
     b1c:	68e2      	ldr	r2, [r4, #12]
                boot_move_sector_up(idx, sector_sz, state, bs, fap_pri, fap_sec);
     b1e:	9b07      	ldr	r3, [sp, #28]
        if (bs->source != BOOT_STATUS_SOURCE_PRIMARY_SLOT) {
     b20:	2a02      	cmp	r2, #2
     b22:	d00a      	beq.n	b3a <swap_run+0x102>
            rc = swap_erase_trailer_sectors(state, fap_pri);
     b24:	4641      	mov	r1, r8
     b26:	4628      	mov	r0, r5
     b28:	9302      	str	r3, [sp, #8]
     b2a:	f004 f8c0 	bl	4cae <swap_erase_trailer_sectors>
            rc = swap_status_init(state, fap_pri, bs);
     b2e:	4622      	mov	r2, r4
     b30:	4641      	mov	r1, r8
     b32:	4628      	mov	r0, r5
     b34:	f004 f8f0 	bl	4d18 <swap_status_init>
     b38:	9b02      	ldr	r3, [sp, #8]
        rc = swap_erase_trailer_sectors(state, fap_sec);
     b3a:	4619      	mov	r1, r3
     b3c:	4628      	mov	r0, r5
     b3e:	f004 f8b6 	bl	4cae <swap_erase_trailer_sectors>
    rc = boot_erase_region(fap_pri, new_off, sz);
     b42:	4632      	mov	r2, r6
     b44:	4649      	mov	r1, r9
     b46:	4640      	mov	r0, r8
     b48:	f004 f8af 	bl	4caa <boot_erase_region>
    rc = boot_copy_region(state, fap_pri, fap_pri, old_off, new_off, sz);
     b4c:	ee18 3a10 	vmov	r3, s16
     b50:	4642      	mov	r2, r8
     b52:	4641      	mov	r1, r8
     b54:	e9cd 9600 	strd	r9, r6, [sp]
     b58:	4628      	mov	r0, r5
     b5a:	f7ff fd99 	bl	690 <boot_copy_region>
    rc = boot_write_status(state, bs);
     b5e:	4621      	mov	r1, r4
     b60:	4628      	mov	r0, r5
     b62:	f004 f870 	bl	4c46 <boot_write_status>
    bs->idx++;
     b66:	6823      	ldr	r3, [r4, #0]
     b68:	3301      	adds	r3, #1
     b6a:	6023      	str	r3, [r4, #0]
    BOOT_STATUS_ASSERT(rc == 0);
     b6c:	b120      	cbz	r0, b78 <swap_run+0x140>
     b6e:	f8da 3000 	ldr.w	r3, [sl]
     b72:	3301      	adds	r3, #1
     b74:	f8ca 3000 	str.w	r3, [sl]
            idx--;
     b78:	3f01      	subs	r7, #1
     b7a:	e7a0      	b.n	abe <swap_run+0x86>
        if (idx >= bs->idx) {
     b7c:	6823      	ldr	r3, [r4, #0]
     b7e:	42bb      	cmp	r3, r7
     b80:	d857      	bhi.n	c32 <swap_run+0x1fa>
     b82:	6a69      	ldr	r1, [r5, #36]	; 0x24
     b84:	6d28      	ldr	r0, [r5, #80]	; 0x50
     b86:	f851 3037 	ldr.w	r3, [r1, r7, lsl #3]
     b8a:	9303      	str	r3, [sp, #12]
     b8c:	00fa      	lsls	r2, r7, #3
     b8e:	3a08      	subs	r2, #8
     b90:	680b      	ldr	r3, [r1, #0]
     b92:	f850 c002 	ldr.w	ip, [r0, r2]
     b96:	9302      	str	r3, [sp, #8]
     b98:	6803      	ldr	r3, [r0, #0]
    if (bs->state == BOOT_STATUS_STATE_0) {
     b9a:	7920      	ldrb	r0, [r4, #4]
            boot_swap_sectors(idx, sector_sz, state, bs, fap_pri, fap_sec);
     b9c:	f8dd a01c 	ldr.w	sl, [sp, #28]
    if (bs->state == BOOT_STATUS_STATE_0) {
     ba0:	2801      	cmp	r0, #1
     ba2:	ebac 0303 	sub.w	r3, ip, r3
     ba6:	d142      	bne.n	c2e <swap_run+0x1f6>
     ba8:	5889      	ldr	r1, [r1, r2]
     baa:	9305      	str	r3, [sp, #20]
     bac:	9b02      	ldr	r3, [sp, #8]
        rc = boot_erase_region(fap_pri, pri_off, sz);
     bae:	4632      	mov	r2, r6
     bb0:	1ac9      	subs	r1, r1, r3
     bb2:	4648      	mov	r0, r9
     bb4:	9104      	str	r1, [sp, #16]
     bb6:	f004 f878 	bl	4caa <boot_erase_region>
        rc = boot_copy_region(state, fap_sec, fap_pri, sec_off, pri_off, sz);
     bba:	9904      	ldr	r1, [sp, #16]
     bbc:	9b05      	ldr	r3, [sp, #20]
     bbe:	9100      	str	r1, [sp, #0]
     bc0:	464a      	mov	r2, r9
     bc2:	4651      	mov	r1, sl
     bc4:	9601      	str	r6, [sp, #4]
     bc6:	4628      	mov	r0, r5
     bc8:	9304      	str	r3, [sp, #16]
     bca:	f7ff fd61 	bl	690 <boot_copy_region>
        rc = boot_write_status(state, bs);
     bce:	4621      	mov	r1, r4
     bd0:	4628      	mov	r0, r5
     bd2:	f004 f838 	bl	4c46 <boot_write_status>
        bs->state = BOOT_STATUS_STATE_1;
     bd6:	f04f 0302 	mov.w	r3, #2
     bda:	7123      	strb	r3, [r4, #4]
        BOOT_STATUS_ASSERT(rc == 0);
     bdc:	9b04      	ldr	r3, [sp, #16]
     bde:	b120      	cbz	r0, bea <swap_run+0x1b2>
     be0:	f8d8 2000 	ldr.w	r2, [r8]
     be4:	3201      	adds	r2, #1
     be6:	f8c8 2000 	str.w	r2, [r8]
        rc = boot_erase_region(fap_sec, sec_off, sz);
     bea:	4619      	mov	r1, r3
     bec:	4632      	mov	r2, r6
     bee:	4650      	mov	r0, sl
     bf0:	9304      	str	r3, [sp, #16]
     bf2:	f004 f85a 	bl	4caa <boot_erase_region>
        rc = boot_copy_region(state, fap_pri, fap_sec, pri_up_off, sec_off, sz);
     bf6:	9b04      	ldr	r3, [sp, #16]
     bf8:	9300      	str	r3, [sp, #0]
     bfa:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     bfe:	4649      	mov	r1, r9
     c00:	1a9b      	subs	r3, r3, r2
     c02:	9601      	str	r6, [sp, #4]
     c04:	4652      	mov	r2, sl
     c06:	4628      	mov	r0, r5
     c08:	f7ff fd42 	bl	690 <boot_copy_region>
        rc = boot_write_status(state, bs);
     c0c:	4621      	mov	r1, r4
     c0e:	4628      	mov	r0, r5
     c10:	f004 f819 	bl	4c46 <boot_write_status>
        bs->idx++;
     c14:	6823      	ldr	r3, [r4, #0]
     c16:	3301      	adds	r3, #1
     c18:	6023      	str	r3, [r4, #0]
        bs->state = BOOT_STATUS_STATE_0;
     c1a:	f04f 0301 	mov.w	r3, #1
     c1e:	7123      	strb	r3, [r4, #4]
        BOOT_STATUS_ASSERT(rc == 0);
     c20:	b138      	cbz	r0, c32 <swap_run+0x1fa>
     c22:	f8d8 3000 	ldr.w	r3, [r8]
     c26:	3301      	adds	r3, #1
     c28:	f8c8 3000 	str.w	r3, [r8]
     c2c:	e001      	b.n	c32 <swap_run+0x1fa>
    if (bs->state == BOOT_STATUS_STATE_1) {
     c2e:	2802      	cmp	r0, #2
     c30:	d0db      	beq.n	bea <swap_run+0x1b2>
        idx++;
     c32:	3701      	adds	r7, #1
     c34:	e74e      	b.n	ad4 <swap_run+0x9c>
     c36:	bf00      	nop
     c38:	20000004 	.word	0x20000004
     c3c:	20001518 	.word	0x20001518

00000c40 <cc310_init>:
 */

#include "cc310_glue.h"

int cc310_init(void)
{
     c40:	b570      	push	{r4, r5, r6, lr}
    /* Only initialize once */
    static bool initialized;

    if (!initialized) {
     c42:	4d09      	ldr	r5, [pc, #36]	; (c68 <cc310_init+0x28>)
     c44:	782b      	ldrb	r3, [r5, #0]
     c46:	b953      	cbnz	r3, c5e <cc310_init+0x1e>
    NRF_CRYPTOCELL->ENABLE=1;
     c48:	4c08      	ldr	r4, [pc, #32]	; (c6c <cc310_init+0x2c>)
     c4a:	2601      	movs	r6, #1
     c4c:	f8c4 6500 	str.w	r6, [r4, #1280]	; 0x500
        nrf_cc310_enable();
        if (nrf_cc310_bl_init() != 0) {
     c50:	f002 fe40 	bl	38d4 <nrf_cc310_bl_init>
     c54:	b928      	cbnz	r0, c62 <cc310_init+0x22>
            return -1;
        }
        initialized = true;
     c56:	702e      	strb	r6, [r5, #0]
    NRF_CRYPTOCELL->ENABLE=0;
     c58:	f8c4 0500 	str.w	r0, [r4, #1280]	; 0x500
        nrf_cc310_disable();
    }

    return 0;
}
     c5c:	bd70      	pop	{r4, r5, r6, pc}
    return 0;
     c5e:	2000      	movs	r0, #0
     c60:	e7fc      	b.n	c5c <cc310_init+0x1c>
            return -1;
     c62:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
     c66:	e7f9      	b.n	c5c <cc310_init+0x1c>
     c68:	20001768 	.word	0x20001768
     c6c:	5002a000 	.word	0x5002a000

00000c70 <cc310_ecdsa_verify_secp256r1>:

int cc310_ecdsa_verify_secp256r1(uint8_t *hash,
                                 uint8_t *public_key,
                                 uint8_t *signature,
                                 size_t hash_len)
{
     c70:	b570      	push	{r4, r5, r6, lr}
    NRF_CRYPTOCELL->ENABLE=1;
     c72:	4e0b      	ldr	r6, [pc, #44]	; (ca0 <cc310_ecdsa_verify_secp256r1+0x30>)
     c74:	b0ae      	sub	sp, #184	; 0xb8
     c76:	461d      	mov	r5, r3
     c78:	e9cd 2102 	strd	r2, r1, [sp, #8]
     c7c:	4604      	mov	r4, r0
        int rc;
        nrf_cc310_bl_ecdsa_verify_context_secp256r1_t ctx;
        cc310_init();
     c7e:	f7ff ffdf 	bl	c40 <cc310_init>
     c82:	2301      	movs	r3, #1
     c84:	f8c6 3500 	str.w	r3, [r6, #1280]	; 0x500
        nrf_cc310_enable();
        rc = nrf_cc310_bl_ecdsa_verify_secp256r1(&ctx,
     c88:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
     c8c:	4623      	mov	r3, r4
     c8e:	9500      	str	r5, [sp, #0]
     c90:	a805      	add	r0, sp, #20
     c92:	f004 ffb1 	bl	5bf8 <nrf_cc310_bl_ecdsa_verify_secp256r1>
    NRF_CRYPTOCELL->ENABLE=0;
     c96:	2300      	movs	r3, #0
     c98:	f8c6 3500 	str.w	r3, [r6, #1280]	; 0x500
                                                 (nrf_cc310_bl_ecc_signature_secp256r1_t  *) signature,
                                                 hash,
                                                 hash_len);
        nrf_cc310_disable();
        return rc;
}
     c9c:	b02e      	add	sp, #184	; 0xb8
     c9e:	bd70      	pop	{r4, r5, r6, pc}
     ca0:	5002a000 	.word	0x5002a000

00000ca4 <nrf_cleanup_peripheral>:
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
     ca4:	4a16      	ldr	r2, [pc, #88]	; (d00 <nrf_cleanup_peripheral+0x5c>)
    p_reg->EVTENSET = mask;
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
     ca6:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
     caa:	2101      	movs	r1, #1
     cac:	6051      	str	r1, [r2, #4]
    p_reg->EVTENCLR = mask;
     cae:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
    p_reg->INTENCLR = mask;
     cb2:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
     cb6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000
     cba:	6051      	str	r1, [r2, #4]
    p_reg->EVTENCLR = mask;
     cbc:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
    p_reg->INTENCLR = mask;
     cc0:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
     cc4:	f502 3298 	add.w	r2, r2, #77824	; 0x13000
     cc8:	6051      	str	r1, [r2, #4]
    p_reg->EVTENCLR = mask;
     cca:	f8c2 3348 	str.w	r3, [r2, #840]	; 0x348
    p_reg->INTENCLR = mask;
     cce:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
}

NRF_STATIC_INLINE void nrf_uarte_disable(NRF_UARTE_Type * p_reg)
{
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
     cd2:	f5a2 3208 	sub.w	r2, r2, #139264	; 0x22000
     cd6:	2100      	movs	r1, #0
     cd8:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_reg->INTENCLR = mask;
     cdc:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Disabled;
     ce0:	f502 3218 	add.w	r2, r2, #155648	; 0x26000
     ce4:	f8c2 1500 	str.w	r1, [r2, #1280]	; 0x500
    p_reg->INTENCLR = mask;
     ce8:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    }
}

NRF_STATIC_INLINE void nrf_ppi_channels_disable_all(NRF_PPI_Type * p_reg)
{
    p_reg->CHENCLR = ((uint32_t)0xFFFFFFFFuL);
     cec:	f5a2 4210 	sub.w	r2, r2, #36864	; 0x9000
     cf0:	f8c2 3508 	str.w	r3, [r2, #1288]	; 0x508
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
     cf4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
     cf8:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
#endif
#if defined(NRF_DPPIC)
    nrf_dppi_channels_disable_all(NRF_DPPIC);
#endif
    nrf_cleanup_clock();
}
     cfc:	4770      	bx	lr
     cfe:	bf00      	nop
     d00:	4000b000 	.word	0x4000b000

00000d04 <process_event>:
 * regions.
 */
static void process_event(struct onoff_manager *mgr,
			  int evt,
			  k_spinlock_key_t key)
{
     d04:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	sys_slist_t clients;
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     d08:	f8b0 9018 	ldrh.w	r9, [r0, #24]
	__ASSERT_NO_MSG(evt != EVT_NOP);

	/* If this is a nested call record the event for processing in
	 * the top invocation.
	 */
	if (processing) {
     d0c:	f019 0808 	ands.w	r8, r9, #8
{
     d10:	4604      	mov	r4, r0
     d12:	4693      	mov	fp, r2
	if (processing) {
     d14:	d00e      	beq.n	d34 <process_event+0x30>
		if (evt == EVT_COMPLETE) {
     d16:	2901      	cmp	r1, #1
			mgr->flags |= ONOFF_FLAG_COMPLETE;
     d18:	bf0c      	ite	eq
     d1a:	f049 0910 	orreq.w	r9, r9, #16
		} else {
			__ASSERT_NO_MSG(evt == EVT_RECHECK);

			mgr->flags |= ONOFF_FLAG_RECHECK;
     d1e:	f049 0920 	orrne.w	r9, r9, #32
     d22:	f8a0 9018 	strh.w	r9, [r0, #24]
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
     d26:	f38b 8811 	msr	BASEPRI, fp
     d2a:	f3bf 8f6f 	isb	sy
		state = mgr->flags & ONOFF_STATE_MASK;
	} while (evt != EVT_NOP);

out:
	k_spin_unlock(&mgr->lock, key);
}
     d2e:	b003      	add	sp, #12
     d30:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				transit(mgr, transition_complete);
     d34:	f8df a190 	ldr.w	sl, [pc, #400]	; ec8 <process_event+0x1c4>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     d38:	f009 0907 	and.w	r9, r9, #7
		if (evt == EVT_RECHECK) {
     d3c:	2902      	cmp	r1, #2
     d3e:	d107      	bne.n	d50 <process_event+0x4c>
			evt = process_recheck(mgr);
     d40:	4620      	mov	r0, r4
     d42:	f004 fa14 	bl	516e <process_recheck>
		if (evt == EVT_NOP) {
     d46:	2800      	cmp	r0, #0
     d48:	d0ed      	beq.n	d26 <process_event+0x22>
		if (evt == EVT_COMPLETE) {
     d4a:	2801      	cmp	r0, #1
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     d4c:	8b23      	ldrh	r3, [r4, #24]
		if (evt == EVT_COMPLETE) {
     d4e:	d14b      	bne.n	de8 <process_event+0xe4>
			res = mgr->last_res;
     d50:	6967      	ldr	r7, [r4, #20]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     d52:	8b21      	ldrh	r1, [r4, #24]
	if (res < 0) {
     d54:	2f00      	cmp	r7, #0
     d56:	da15      	bge.n	d84 <process_event+0x80>
		*clients = mgr->clients;
     d58:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     d5a:	f021 0107 	bic.w	r1, r1, #7
 * @param list A pointer on the list to initialize
 */
static inline void sys_slist_init(sys_slist_t *list)
{
	list->head = NULL;
	list->tail = NULL;
     d5e:	e9c4 8800 	strd	r8, r8, [r4]
     d62:	f041 0101 	orr.w	r1, r1, #1
	mgr->flags = (state & ONOFF_STATE_MASK)
     d66:	8321      	strh	r1, [r4, #24]
		onoff_transition_fn transit = NULL;
     d68:	2600      	movs	r6, #0
		bool do_monitors = (state != (mgr->flags & ONOFF_STATE_MASK))
     d6a:	8b21      	ldrh	r1, [r4, #24]
     d6c:	f001 0207 	and.w	r2, r1, #7
				   && !sys_slist_is_empty(&mgr->monitors);
     d70:	454a      	cmp	r2, r9
     d72:	d002      	beq.n	d7a <process_event+0x76>
		if (do_monitors
     d74:	68a3      	ldr	r3, [r4, #8]
     d76:	2b00      	cmp	r3, #0
     d78:	d157      	bne.n	e2a <process_event+0x126>
		    || !sys_slist_is_empty(&clients)
     d7a:	b90d      	cbnz	r5, d80 <process_event+0x7c>
		    || (transit != NULL)) {
     d7c:	2e00      	cmp	r6, #0
     d7e:	d06f      	beq.n	e60 <process_event+0x15c>
     d80:	2300      	movs	r3, #0
     d82:	e053      	b.n	e2c <process_event+0x128>
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
     d84:	f001 0307 	and.w	r3, r1, #7
		   || (state == ONOFF_STATE_RESETTING)) {
     d88:	1f5a      	subs	r2, r3, #5
	} else if ((state == ONOFF_STATE_TO_ON)
     d8a:	2a01      	cmp	r2, #1
     d8c:	d81d      	bhi.n	dca <process_event+0xc6>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     d8e:	f021 0107 	bic.w	r1, r1, #7
		if (state == ONOFF_STATE_TO_ON) {
     d92:	2b06      	cmp	r3, #6
		*clients = mgr->clients;
     d94:	6825      	ldr	r5, [r4, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     d96:	b289      	uxth	r1, r1
     d98:	e9c4 8800 	strd	r8, r8, [r4]
		if (state == ONOFF_STATE_TO_ON) {
     d9c:	d10a      	bne.n	db4 <process_event+0xb0>
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     d9e:	b13d      	cbz	r5, db0 <process_event+0xac>
     da0:	8b63      	ldrh	r3, [r4, #26]
     da2:	462a      	mov	r2, r5

#define SYS_SLIST_STATIC_INIT(ptr_to_list) {NULL, NULL}

static inline sys_snode_t *z_snode_next_peek(sys_snode_t *node)
{
	return node->next;
     da4:	6812      	ldr	r2, [r2, #0]
				mgr->refs += 1U;
     da6:	3301      	adds	r3, #1
     da8:	b29b      	uxth	r3, r3
			SYS_SLIST_FOR_EACH_CONTAINER(clients, cp, node) {
     daa:	2a00      	cmp	r2, #0
     dac:	d1fa      	bne.n	da4 <process_event+0xa0>
     dae:	8363      	strh	r3, [r4, #26]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     db0:	f041 0102 	orr.w	r1, r1, #2
	mgr->flags = (state & ONOFF_STATE_MASK)
     db4:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
     db6:	4620      	mov	r0, r4
     db8:	f004 f9d9 	bl	516e <process_recheck>
     dbc:	2800      	cmp	r0, #0
     dbe:	d0d3      	beq.n	d68 <process_event+0x64>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     dc0:	8b23      	ldrh	r3, [r4, #24]
     dc2:	f043 0320 	orr.w	r3, r3, #32
     dc6:	8323      	strh	r3, [r4, #24]
     dc8:	e7ce      	b.n	d68 <process_event+0x64>
	} else if (state == ONOFF_STATE_TO_OFF) {
     dca:	2b04      	cmp	r3, #4
     dcc:	d10a      	bne.n	de4 <process_event+0xe0>
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     dce:	f021 0107 	bic.w	r1, r1, #7
     dd2:	b289      	uxth	r1, r1
	mgr->flags = (state & ONOFF_STATE_MASK)
     dd4:	8321      	strh	r1, [r4, #24]
		if (process_recheck(mgr) != EVT_NOP) {
     dd6:	4620      	mov	r0, r4
     dd8:	f004 f9c9 	bl	516e <process_recheck>
     ddc:	b110      	cbz	r0, de4 <process_event+0xe0>
			mgr->flags |= ONOFF_FLAG_RECHECK;
     dde:	f041 0120 	orr.w	r1, r1, #32
     de2:	8321      	strh	r1, [r4, #24]
     de4:	2500      	movs	r5, #0
     de6:	e7bf      	b.n	d68 <process_event+0x64>
		} else if (evt == EVT_START) {
     de8:	2803      	cmp	r0, #3
     dea:	d109      	bne.n	e00 <process_event+0xfc>
			transit = mgr->transitions->start;
     dec:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     dee:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->start;
     df2:	6816      	ldr	r6, [r2, #0]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     df4:	f043 0306 	orr.w	r3, r3, #6
	mgr->flags = (state & ONOFF_STATE_MASK)
     df8:	8323      	strh	r3, [r4, #24]
}
     dfa:	2500      	movs	r5, #0
		res = 0;
     dfc:	462f      	mov	r7, r5
     dfe:	e7b4      	b.n	d6a <process_event+0x66>
		} else if (evt == EVT_STOP) {
     e00:	2804      	cmp	r0, #4
     e02:	d106      	bne.n	e12 <process_event+0x10e>
			transit = mgr->transitions->stop;
     e04:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     e06:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->stop;
     e0a:	6856      	ldr	r6, [r2, #4]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     e0c:	f043 0304 	orr.w	r3, r3, #4
     e10:	e7f2      	b.n	df8 <process_event+0xf4>
		} else if (evt == EVT_RESET) {
     e12:	2805      	cmp	r0, #5
     e14:	d106      	bne.n	e24 <process_event+0x120>
			transit = mgr->transitions->reset;
     e16:	6922      	ldr	r2, [r4, #16]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     e18:	f023 0307 	bic.w	r3, r3, #7
			transit = mgr->transitions->reset;
     e1c:	6896      	ldr	r6, [r2, #8]
		     | (mgr->flags & ~ONOFF_STATE_MASK);
     e1e:	f043 0305 	orr.w	r3, r3, #5
     e22:	e7e9      	b.n	df8 <process_event+0xf4>
     e24:	2500      	movs	r5, #0
		onoff_transition_fn transit = NULL;
     e26:	462e      	mov	r6, r5
     e28:	e7e8      	b.n	dfc <process_event+0xf8>
				   && !sys_slist_is_empty(&mgr->monitors);
     e2a:	2301      	movs	r3, #1
			uint32_t flags = mgr->flags | ONOFF_FLAG_PROCESSING;
     e2c:	f041 0108 	orr.w	r1, r1, #8
			mgr->flags = flags;
     e30:	8321      	strh	r1, [r4, #24]
     e32:	f38b 8811 	msr	BASEPRI, fp
     e36:	f3bf 8f6f 	isb	sy
			if (do_monitors) {
     e3a:	bb03      	cbnz	r3, e7e <process_event+0x17a>
	while (!sys_slist_is_empty(list)) {
     e3c:	2d00      	cmp	r5, #0
     e3e:	d131      	bne.n	ea4 <process_event+0x1a0>
			if (transit != NULL) {
     e40:	b116      	cbz	r6, e48 <process_event+0x144>
				transit(mgr, transition_complete);
     e42:	4651      	mov	r1, sl
     e44:	4620      	mov	r0, r4
     e46:	47b0      	blx	r6
	__asm__ volatile(
     e48:	f04f 0320 	mov.w	r3, #32
     e4c:	f3ef 8b11 	mrs	fp, BASEPRI
     e50:	f383 8812 	msr	BASEPRI_MAX, r3
     e54:	f3bf 8f6f 	isb	sy
			mgr->flags &= ~ONOFF_FLAG_PROCESSING;
     e58:	8b23      	ldrh	r3, [r4, #24]
     e5a:	f023 0308 	bic.w	r3, r3, #8
     e5e:	8323      	strh	r3, [r4, #24]
		if ((mgr->flags & ONOFF_FLAG_COMPLETE) != 0) {
     e60:	8b23      	ldrh	r3, [r4, #24]
     e62:	06da      	lsls	r2, r3, #27
     e64:	d527      	bpl.n	eb6 <process_event+0x1b2>
			mgr->flags &= ~ONOFF_FLAG_COMPLETE;
     e66:	f023 0310 	bic.w	r3, r3, #16
     e6a:	8323      	strh	r3, [r4, #24]
			evt = EVT_COMPLETE;
     e6c:	2101      	movs	r1, #1
		state = mgr->flags & ONOFF_STATE_MASK;
     e6e:	f8b4 9018 	ldrh.w	r9, [r4, #24]
     e72:	f009 0907 	and.w	r9, r9, #7
	} while (evt != EVT_NOP);
     e76:	2900      	cmp	r1, #0
     e78:	f47f af60 	bne.w	d3c <process_event+0x38>
out:
     e7c:	e753      	b.n	d26 <process_event+0x22>
 *
 * @return A pointer on the first node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_head(sys_slist_t *list)
{
	return list->head;
     e7e:	68a1      	ldr	r1, [r4, #8]
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
     e80:	2900      	cmp	r1, #0
     e82:	d0db      	beq.n	e3c <process_event+0x138>
	return node->next;
     e84:	f8d1 9000 	ldr.w	r9, [r1]
		mon->callback(mgr, mon, state, res);
     e88:	f8d1 b004 	ldr.w	fp, [r1, #4]
     e8c:	9201      	str	r2, [sp, #4]
     e8e:	463b      	mov	r3, r7
     e90:	4620      	mov	r0, r4
     e92:	47d8      	blx	fp
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(mlist, mon, tmp, node) {
     e94:	9a01      	ldr	r2, [sp, #4]
     e96:	f1b9 0f00 	cmp.w	r9, #0
     e9a:	d0cf      	beq.n	e3c <process_event+0x138>
     e9c:	4649      	mov	r1, r9
     e9e:	f8d9 9000 	ldr.w	r9, [r9]
     ea2:	e7f1      	b.n	e88 <process_event+0x184>
     ea4:	4629      	mov	r1, r5
		notify_one(mgr, cli, state, res);
     ea6:	463b      	mov	r3, r7
     ea8:	4620      	mov	r0, r4
     eaa:	9201      	str	r2, [sp, #4]
     eac:	682d      	ldr	r5, [r5, #0]
     eae:	f004 f97a 	bl	51a6 <notify_one>
	while (!sys_slist_is_empty(list)) {
     eb2:	9a01      	ldr	r2, [sp, #4]
     eb4:	e7c2      	b.n	e3c <process_event+0x138>
		} else if ((mgr->flags & ONOFF_FLAG_RECHECK) != 0) {
     eb6:	f013 0120 	ands.w	r1, r3, #32
			mgr->flags &= ~ONOFF_FLAG_RECHECK;
     eba:	bf1e      	ittt	ne
     ebc:	f023 0320 	bicne.w	r3, r3, #32
     ec0:	8323      	strhne	r3, [r4, #24]
			evt = EVT_RECHECK;
     ec2:	2102      	movne	r1, #2
     ec4:	e7d3      	b.n	e6e <process_event+0x16a>
     ec6:	bf00      	nop
     ec8:	000051d3 	.word	0x000051d3

00000ecc <flash_area_open>:

int flash_area_open(uint8_t id, const struct flash_area **fap)
{
	const struct flash_area *area;

	if (flash_map == NULL) {
     ecc:	4b0c      	ldr	r3, [pc, #48]	; (f00 <flash_area_open+0x34>)
     ece:	681b      	ldr	r3, [r3, #0]
{
     ed0:	b570      	push	{r4, r5, r6, lr}
	if (flash_map == NULL) {
     ed2:	b173      	cbz	r3, ef2 <flash_area_open+0x26>
extern const struct flash_area *flash_map;
extern const int flash_map_entries;

static inline struct flash_area const *get_flash_area_from_id(int idx)
{
	for (int i = 0; i < flash_map_entries; i++) {
     ed4:	4a0b      	ldr	r2, [pc, #44]	; (f04 <flash_area_open+0x38>)
     ed6:	6815      	ldr	r5, [r2, #0]
     ed8:	2200      	movs	r2, #0
     eda:	42aa      	cmp	r2, r5
     edc:	db02      	blt.n	ee4 <flash_area_open+0x18>
		return -EACCES;
	}

	area = get_flash_area_from_id(id);
	if (area == NULL) {
		return -ENOENT;
     ede:	f06f 0001 	mvn.w	r0, #1
	}

	*fap = area;
	return 0;
}
     ee2:	bd70      	pop	{r4, r5, r6, pc}
		if (flash_map[i].fa_id == idx) {
     ee4:	461c      	mov	r4, r3
     ee6:	f813 6b10 	ldrb.w	r6, [r3], #16
     eea:	4286      	cmp	r6, r0
     eec:	d004      	beq.n	ef8 <flash_area_open+0x2c>
	for (int i = 0; i < flash_map_entries; i++) {
     eee:	3201      	adds	r2, #1
     ef0:	e7f3      	b.n	eda <flash_area_open+0xe>
		return -EACCES;
     ef2:	f06f 000c 	mvn.w	r0, #12
     ef6:	e7f4      	b.n	ee2 <flash_area_open+0x16>
	*fap = area;
     ef8:	600c      	str	r4, [r1, #0]
	return 0;
     efa:	2000      	movs	r0, #0
     efc:	e7f1      	b.n	ee2 <flash_area_open+0x16>
     efe:	bf00      	nop
     f00:	20000008 	.word	0x20000008
     f04:	00005f38 	.word	0x00005f38

00000f08 <flash_area_get_sectors>:

	return true;
}

int flash_area_get_sectors(int idx, uint32_t *cnt, struct flash_sector *ret)
{
     f08:	b570      	push	{r4, r5, r6, lr}
     f0a:	b088      	sub	sp, #32
     f0c:	4605      	mov	r5, r0
     f0e:	460c      	mov	r4, r1
	int rc = flash_area_open(idx, &fa);
     f10:	b2c0      	uxtb	r0, r0
     f12:	4669      	mov	r1, sp
{
     f14:	4616      	mov	r6, r2
	int rc = flash_area_open(idx, &fa);
     f16:	f7ff ffd9 	bl	ecc <flash_area_open>
	if (rc < 0 || fa == NULL) {
     f1a:	2800      	cmp	r0, #0
     f1c:	db1f      	blt.n	f5e <flash_area_get_sectors+0x56>
     f1e:	9b00      	ldr	r3, [sp, #0]
     f20:	b1eb      	cbz	r3, f5e <flash_area_get_sectors+0x56>
	cb_data->area_off = fa->fa_off;
     f22:	685a      	ldr	r2, [r3, #4]
     f24:	9202      	str	r2, [sp, #8]
	cb_data->area_len = fa->fa_size;
     f26:	689a      	ldr	r2, [r3, #8]
	cb_data->ret_len = *cnt;
     f28:	6821      	ldr	r1, [r4, #0]
	flash_dev = device_get_binding(fa->fa_dev_name);
     f2a:	68d8      	ldr	r0, [r3, #12]
	cb_data->area_idx = idx;
     f2c:	9501      	str	r5, [sp, #4]
	cb_data->ret = ret;
     f2e:	e9cd 2603 	strd	r2, r6, [sp, #12]
	cb_data->ret_idx = 0U;
     f32:	2200      	movs	r2, #0
	cb_data->status = 0;
     f34:	e9cd 1206 	strd	r1, r2, [sp, #24]
	cb_data->ret_idx = 0U;
     f38:	9205      	str	r2, [sp, #20]
     f3a:	f002 f815 	bl	2f68 <z_impl_device_get_binding>
     f3e:	4605      	mov	r5, r0
	flash_area_close(fa);
     f40:	9800      	ldr	r0, [sp, #0]
     f42:	f004 f9c1 	bl	52c8 <flash_area_close>
	if (flash_dev == NULL) {
     f46:	b16d      	cbz	r5, f64 <flash_area_get_sectors+0x5c>
	flash_page_foreach(flash_dev, cb, cb_data);
     f48:	4628      	mov	r0, r5
     f4a:	4908      	ldr	r1, [pc, #32]	; (f6c <flash_area_get_sectors+0x64>)
     f4c:	aa01      	add	r2, sp, #4
     f4e:	f004 fbb6 	bl	56be <flash_page_foreach>
	if (cb_data->status == 0) {
     f52:	9807      	ldr	r0, [sp, #28]
     f54:	b908      	cbnz	r0, f5a <flash_area_get_sectors+0x52>
		*cnt = cb_data->ret_idx;
     f56:	9b05      	ldr	r3, [sp, #20]
     f58:	6023      	str	r3, [r4, #0]
	struct layout_data data;

	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
}
     f5a:	b008      	add	sp, #32
     f5c:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
     f5e:	f06f 0015 	mvn.w	r0, #21
     f62:	e7fa      	b.n	f5a <flash_area_get_sectors+0x52>
		return -ENODEV;
     f64:	f06f 0012 	mvn.w	r0, #18
	return flash_area_layout(idx, cnt, ret, get_sectors_cb, &data);
     f68:	e7f7      	b.n	f5a <flash_area_get_sectors+0x52>
     f6a:	bf00      	nop
     f6c:	0000538d 	.word	0x0000538d

00000f70 <nrf_cc3xx_platform_abort_init>:

/** @brief Function to initialize the nrf_cc3xx_platform abort APIs.
 */
void nrf_cc3xx_platform_abort_init(void)
{
	nrf_cc3xx_platform_set_abort(&apis);
     f70:	4801      	ldr	r0, [pc, #4]	; (f78 <nrf_cc3xx_platform_abort_init+0x8>)
     f72:	f002 b965 	b.w	3240 <nrf_cc3xx_platform_set_abort>
     f76:	bf00      	nop
     f78:	00005f3c 	.word	0x00005f3c

00000f7c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
     f7c:	4901      	ldr	r1, [pc, #4]	; (f84 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
     f7e:	2210      	movs	r2, #16
	str	r2, [r1]
     f80:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
     f82:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
     f84:	e000ed10 	.word	0xe000ed10

00000f88 <arch_cpu_atomic_idle>:

	/*
	 * Lock PRIMASK while sleeping: wfe will still get interrupted by
	 * incoming interrupts but the CPU will not service them right away.
	 */
	cpsid	i
     f88:	b672      	cpsid	i
	cpsie	i
_irq_disabled:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* r1: zero, for setting BASEPRI (needs a register) */
	eors.n	r1, r1
     f8a:	4049      	eors	r1, r1

	/* unlock BASEPRI so wfe gets interrupted by incoming interrupts */
	msr	BASEPRI, r1
     f8c:	f381 8811 	msr	BASEPRI, r1

	wfe
     f90:	bf20      	wfe

	msr	BASEPRI, r0
     f92:	f380 8811 	msr	BASEPRI, r0
	cpsie	i
     f96:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
	bx	lr
     f98:	4770      	bx	lr
     f9a:	bf00      	nop

00000f9c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
     f9c:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
     f9e:	2b00      	cmp	r3, #0
     fa0:	db08      	blt.n	fb4 <arch_irq_enable+0x18>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     fa2:	2201      	movs	r2, #1
     fa4:	f000 001f 	and.w	r0, r0, #31
     fa8:	fa02 f000 	lsl.w	r0, r2, r0
     fac:	095b      	lsrs	r3, r3, #5
     fae:	4a02      	ldr	r2, [pc, #8]	; (fb8 <arch_irq_enable+0x1c>)
     fb0:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
     fb4:	4770      	bx	lr
     fb6:	bf00      	nop
     fb8:	e000e100 	.word	0xe000e100

00000fbc <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
     fbc:	b243      	sxtb	r3, r0
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
     fbe:	2b00      	cmp	r3, #0
     fc0:	db0d      	blt.n	fde <arch_irq_disable+0x22>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
     fc2:	2201      	movs	r2, #1
     fc4:	095b      	lsrs	r3, r3, #5
     fc6:	f000 001f 	and.w	r0, r0, #31
     fca:	fa02 f000 	lsl.w	r0, r2, r0
     fce:	3320      	adds	r3, #32
     fd0:	4a03      	ldr	r2, [pc, #12]	; (fe0 <arch_irq_disable+0x24>)
     fd2:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  __ASM volatile ("dsb 0xF":::"memory");
     fd6:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
     fda:	f3bf 8f6f 	isb	sy
}
     fde:	4770      	bx	lr
     fe0:	e000e100 	.word	0xe000e100

00000fe4 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
     fe4:	4b05      	ldr	r3, [pc, #20]	; (ffc <arch_irq_is_enabled+0x18>)
     fe6:	0942      	lsrs	r2, r0, #5
     fe8:	f000 001f 	and.w	r0, r0, #31
     fec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
     ff0:	2301      	movs	r3, #1
     ff2:	fa03 f000 	lsl.w	r0, r3, r0
}
     ff6:	4010      	ands	r0, r2
     ff8:	4770      	bx	lr
     ffa:	bf00      	nop
     ffc:	e000e100 	.word	0xe000e100

00001000 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d for %d irq! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET, irq,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
    1000:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
    1002:	2b00      	cmp	r3, #0
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1004:	bfa8      	it	ge
    1006:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
		prio += _IRQ_PRIO_OFFSET;
    100a:	f101 0101 	add.w	r1, r1, #1
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    100e:	bfb8      	it	lt
    1010:	4b06      	ldrlt	r3, [pc, #24]	; (102c <z_arm_irq_priority_set+0x2c>)
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1012:	ea4f 1141 	mov.w	r1, r1, lsl #5
    1016:	bfac      	ite	ge
    1018:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    101c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1020:	b2c9      	uxtb	r1, r1
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1022:	bfb4      	ite	lt
    1024:	5419      	strblt	r1, [r3, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    1026:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
}
    102a:	4770      	bx	lr
    102c:	e000ed14 	.word	0xe000ed14

00001030 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
    1030:	bf30      	wfi
    b z_SysNmiOnReset
    1032:	f7ff bffd 	b.w	1030 <z_SysNmiOnReset>
    1036:	bf00      	nop

00001038 <z_arm_prep_c>:

#define VECTOR_ADDRESS ((uintptr_t)_vector_start)

static inline void relocate_vector_table(void)
{
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    1038:	4a14      	ldr	r2, [pc, #80]	; (108c <z_arm_prep_c+0x54>)
 *
 * This routine prepares for the execution of and runs C code.
 *
 */
void z_arm_prep_c(void)
{
    103a:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
    103c:	4b14      	ldr	r3, [pc, #80]	; (1090 <z_arm_prep_c+0x58>)
    103e:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
    1042:	609a      	str	r2, [r3, #8]
  __ASM volatile ("dsb 0xF":::"memory");
    1044:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1048:	f3bf 8f6f 	isb	sy
	SCB->CPACR &= (~(CPACR_CP10_Msk | CPACR_CP11_Msk));
    104c:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    1050:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    1054:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	SCB->CPACR |= CPACR_CP10_PRIV_ACCESS | CPACR_CP11_PRIV_ACCESS;
    1058:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    105c:	f442 02a0 	orr.w	r2, r2, #5242880	; 0x500000
    1060:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	FPU->FPCCR = FPU_FPCCR_ASPEN_Msk | FPU_FPCCR_LSPEN_Msk;
    1064:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
    1068:	f8c3 2234 	str.w	r2, [r3, #564]	; 0x234
  __ASM volatile ("dsb 0xF":::"memory");
    106c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1070:	f3bf 8f6f 	isb	sy
     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
#if __has_builtin(__builtin_arm_set_fpscr)
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  __builtin_arm_set_fpscr(fpscr);
    1074:	2300      	movs	r3, #0
    1076:	eee1 3a10 	vmsr	fpscr, r3
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
    107a:	f001 ffb7 	bl	2fec <z_bss_zero>
	z_data_copy();
    107e:	f001 fffb 	bl	3078 <z_data_copy>
#if ((defined(CONFIG_ARMV7_R) || defined(CONFIG_ARMV7_A)) && defined(CONFIG_INIT_STACKS))
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
    1082:	f000 f95d 	bl	1340 <z_arm_interrupt_init>
	z_cstart();
    1086:	f001 ffbd 	bl	3004 <z_cstart>
    108a:	bf00      	nop
    108c:	00000000 	.word	0x00000000
    1090:	e000ed00 	.word	0xe000ed00

00001094 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #_EXC_RETURN_SPSEL_Msk /* did we come from thread mode ? */
    1094:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
    1098:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
    109a:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
    109e:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
    10a2:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
    10a4:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
    10a8:	2902      	cmp	r1, #2
    beq _oops
    10aa:	d0ff      	beq.n	10ac <_oops>

000010ac <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
    10ac:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
    10ae:	f004 f98f 	bl	53d0 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
    10b2:	bd01      	pop	{r0, pc}

000010b4 <z_check_thread_stack_fail>:
			fault_addr, psp)) {
		/* Thread stack corruption */
		return thread->stack_info.start;
	}
#else
	if (IS_MPU_GUARD_VIOLATION((uint32_t)z_main_stack,
    10b4:	f110 0f16 	cmn.w	r0, #22
    10b8:	4b07      	ldr	r3, [pc, #28]	; (10d8 <z_check_thread_stack_fail+0x24>)
    10ba:	d008      	beq.n	10ce <z_check_thread_stack_fail+0x1a>
    10bc:	4298      	cmp	r0, r3
    10be:	d308      	bcc.n	10d2 <z_check_thread_stack_fail+0x1e>
    10c0:	3320      	adds	r3, #32
    10c2:	4283      	cmp	r3, r0
    10c4:	d905      	bls.n	10d2 <z_check_thread_stack_fail+0x1e>
    10c6:	428b      	cmp	r3, r1
    10c8:	d903      	bls.n	10d2 <z_check_thread_stack_fail+0x1e>
			guard_len,
			fault_addr, psp)) {
		/* Thread stack corruption */
		return (uint32_t)Z_THREAD_STACK_BUFFER(z_main_stack);
    10ca:	4804      	ldr	r0, [pc, #16]	; (10dc <z_check_thread_stack_fail+0x28>)
    10cc:	4770      	bx	lr
	if (IS_MPU_GUARD_VIOLATION((uint32_t)z_main_stack,
    10ce:	3320      	adds	r3, #32
    10d0:	e7f9      	b.n	10c6 <z_check_thread_stack_fail+0x12>
	}
#endif
#endif /* CONFIG_USERSPACE */

	return 0;
    10d2:	2000      	movs	r0, #0
}
    10d4:	4770      	bx	lr
    10d6:	bf00      	nop
    10d8:	20001780 	.word	0x20001780
    10dc:	200017a0 	.word	0x200017a0

000010e0 <z_arm_switch_to_main_no_multithreading>:

#if !defined(CONFIG_MULTITHREADING) && defined(CONFIG_CPU_CORTEX_M)

FUNC_NORETURN void z_arm_switch_to_main_no_multithreading(
	k_thread_entry_t main_entry, void *p1, void *p2, void *p3)
{
    10e0:	4604      	mov	r4, r0
    10e2:	4608      	mov	r0, r1
    10e4:	4611      	mov	r1, r2
    10e6:	461a      	mov	r2, r3
    10e8:	2300      	movs	r3, #0
    10ea:	eee1 3a10 	vmsr	fpscr, r3
	 */
	register void *p1_inreg __asm__("r0") = p1;
	register void *p2_inreg __asm__("r1") = p2;
	register void *p3_inreg __asm__("r2") = p3;

	__asm__ volatile (
    10ee:	4b08      	ldr	r3, [pc, #32]	; (1110 <loop+0x2>)
    10f0:	2520      	movs	r5, #32
    10f2:	f383 8809 	msr	PSP, r3
    10f6:	b663      	cpsie	if
    10f8:	f04f 0300 	mov.w	r3, #0
    10fc:	f383 8811 	msr	BASEPRI, r3
    1100:	f3bf 8f6f 	isb	sy
    1104:	47a0      	blx	r4
    1106:	f385 8811 	msr	BASEPRI, r5
    110a:	f3bf 8f6f 	isb	sy

0000110e <loop>:
    110e:	e7fe      	b.n	110e <loop>
	, [_psplim]"r" (psplim)
#endif
	:
	);

	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
    1110:	20003fa0 	.word	0x20003fa0

00001114 <_isr_wrapper>:
 *
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
    1114:	b501      	push	{r0, lr}
#endif

#endif /* CONFIG_PM */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
    1116:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
    111a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
    111e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	lsl r1, r1, #3
	cmp r0, r1
	bge spurious_continue
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
    1122:	4904      	ldr	r1, [pc, #16]	; (1134 <_isr_wrapper+0x20>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
    1124:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
    1126:	c909      	ldmia	r1!, {r0, r3}
	blx r3		/* call ISR */
    1128:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
    112a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
    112e:	4902      	ldr	r1, [pc, #8]	; (1138 <_isr_wrapper+0x24>)
	bx r1
    1130:	4708      	bx	r1
    1132:	0000      	.short	0x0000
	ldr r1, =_sw_isr_table
    1134:	00005cd4 	.word	0x00005cd4
	ldr r1, =z_arm_int_exit
    1138:	0000113d 	.word	0x0000113d

0000113c <z_arm_exc_exit>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
    113c:	4770      	bx	lr
    113e:	bf00      	nop

00001140 <mem_manage_fault>:
 *
 * @return error code to identify the fatal error reason
 */
static uint32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
			      bool *recoverable)
{
    1140:	b538      	push	{r3, r4, r5, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	uint32_t mmfar = -EINVAL;

	PR_FAULT_INFO("***** MPU FAULT *****");

	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    1142:	4b1c      	ldr	r3, [pc, #112]	; (11b4 <mem_manage_fault+0x74>)
{
    1144:	4614      	mov	r4, r2
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
    1146:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error (context area might be"
			" not valid)");
	}
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
    1148:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    114a:	6a9a      	ldr	r2, [r3, #40]	; 0x28
{
    114c:	4605      	mov	r5, r0
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
    114e:	0790      	lsls	r0, r2, #30
    1150:	d520      	bpl.n	1194 <mem_manage_fault+0x54>
		 * The MMFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another higher
		 * priority exception might change the MMFAR value.
		 */
		uint32_t temp = SCB->MMFAR;
    1152:	6b58      	ldr	r0, [r3, #52]	; 0x34

		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
    1154:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1156:	0612      	lsls	r2, r2, #24
    1158:	d51c      	bpl.n	1194 <mem_manage_fault+0x54>
			mmfar = temp;
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
			if (from_hard_fault != 0) {
    115a:	b119      	cbz	r1, 1164 <mem_manage_fault+0x24>
				/* clear SCB_MMAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
    115c:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    115e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
    1162:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
    1164:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Instruction Access Violation");
	}
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    1166:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	 * crossed into an area beyond the thread stack.]
	 *
	 * Data Access Violation errors may or may not be caused by
	 * thread stack overflows.
	 */
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    1168:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    116a:	06d2      	lsls	r2, r2, #27
    116c:	d415      	bmi.n	119a <mem_manage_fault+0x5a>
		(SCB->CFSR & SCB_CFSR_DACCVIOL_Msk)) {
    116e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) ||
    1170:	079b      	lsls	r3, r3, #30
    1172:	d412      	bmi.n	119a <mem_manage_fault+0x5a>
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    1174:	2000      	movs	r0, #0
	 * lazy stacking Memory Manage fault. At the time of writing, this
	 * can happen when printing.  If that's true, we should clear the
	 * pending flag in addition to the clearing the reason for the fault
	 */
#if defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	if ((SCB->CFSR & SCB_CFSR_MLSPERR_Msk) != 0) {
    1176:	4b0f      	ldr	r3, [pc, #60]	; (11b4 <mem_manage_fault+0x74>)
    1178:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    117a:	0692      	lsls	r2, r2, #26
		SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTPENDED_Msk;
    117c:	bf42      	ittt	mi
    117e:	6a5a      	ldrmi	r2, [r3, #36]	; 0x24
    1180:	f422 5200 	bicmi.w	r2, r2, #8192	; 0x2000
    1184:	625a      	strmi	r2, [r3, #36]	; 0x24
	}
#endif /* CONFIG_ARMV7_M_ARMV8_M_FP */

	/* clear MMFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
    1186:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1188:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
    118c:	629a      	str	r2, [r3, #40]	; 0x28

	/* Assess whether system shall ignore/recover from this MPU fault. */
	*recoverable = memory_fault_recoverable(esf, true);
    118e:	2300      	movs	r3, #0
    1190:	7023      	strb	r3, [r4, #0]

	return reason;
}
    1192:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t mmfar = -EINVAL;
    1194:	f06f 0015 	mvn.w	r0, #21
    1198:	e7e4      	b.n	1164 <mem_manage_fault+0x24>
		if (SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) {
    119a:	4b06      	ldr	r3, [pc, #24]	; (11b4 <mem_manage_fault+0x74>)
    119c:	685b      	ldr	r3, [r3, #4]
    119e:	0519      	lsls	r1, r3, #20
    11a0:	d5e8      	bpl.n	1174 <mem_manage_fault+0x34>
			uint32_t min_stack_ptr = z_check_thread_stack_fail(mmfar,
    11a2:	4629      	mov	r1, r5
    11a4:	f7ff ff86 	bl	10b4 <z_check_thread_stack_fail>
			if (min_stack_ptr) {
    11a8:	2800      	cmp	r0, #0
    11aa:	d0e3      	beq.n	1174 <mem_manage_fault+0x34>
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
    11ac:	f380 8809 	msr	PSP, r0
				reason = K_ERR_STACK_CHK_FAIL;
    11b0:	2002      	movs	r0, #2
    11b2:	e7e0      	b.n	1176 <mem_manage_fault+0x36>
    11b4:	e000ed00 	.word	0xe000ed00

000011b8 <bus_fault.constprop.0>:
{
	uint32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** BUS FAULT *****");

	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
    11b8:	4b0d      	ldr	r3, [pc, #52]	; (11f0 <bus_fault.constprop.0+0x38>)
    11ba:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Stacking error");
	}
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
    11bc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Unstacking error");
	}
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
    11be:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    11c0:	0592      	lsls	r2, r2, #22
    11c2:	d508      	bpl.n	11d6 <bus_fault.constprop.0+0x1e>
		 * The BFAR address is valid only if this bit is 1.
		 *
		 * Software must follow this sequence because another
		 * higher priority exception might change the BFAR value.
		 */
		STORE_xFAR(bfar, SCB->BFAR);
    11c4:	6b9a      	ldr	r2, [r3, #56]	; 0x38

		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
    11c6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    11c8:	0412      	lsls	r2, r2, #16
    11ca:	d504      	bpl.n	11d6 <bus_fault.constprop.0+0x1e>
			PR_EXC("  BFAR Address: 0x%x", bfar);
			if (from_hard_fault != 0) {
    11cc:	b118      	cbz	r0, 11d6 <bus_fault.constprop.0+0x1e>
				/* clear SCB_CFSR_BFAR[VALID] to reset */
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
    11ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    11d0:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
    11d4:	629a      	str	r2, [r3, #40]	; 0x28
			}
		}
	}
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
    11d6:	4b06      	ldr	r3, [pc, #24]	; (11f0 <bus_fault.constprop.0+0x38>)
    11d8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
		PR_FAULT_INFO("  Imprecise data bus error");
	}
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
    11da:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    11dc:	05d2      	lsls	r2, r2, #23
		PR_FAULT_INFO("  Instruction bus error");
#if !defined(CONFIG_ARMV7_M_ARMV8_M_FP)
	}
#else
	} else if (SCB->CFSR & SCB_CFSR_LSPERR_Msk) {
    11de:	bf58      	it	pl
    11e0:	6a9a      	ldrpl	r2, [r3, #40]	; 0x28
		SYSMPU->CESR &= ~sperr;
	}
#endif /* defined(CONFIG_ARM_MPU) && defined(CONFIG_CPU_HAS_NXP_MPU) */

	/* clear BFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    11e2:	6a9a      	ldr	r2, [r3, #40]	; 0x28

	*recoverable = memory_fault_recoverable(esf, true);
    11e4:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
    11e6:	f442 427f 	orr.w	r2, r2, #65280	; 0xff00
    11ea:	629a      	str	r2, [r3, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf, true);
    11ec:	7008      	strb	r0, [r1, #0]

	return reason;
}
    11ee:	4770      	bx	lr
    11f0:	e000ed00 	.word	0xe000ed00

000011f4 <z_arm_fault>:
 * @param callee_regs Callee-saved registers (R4-R11, PSP)
 *
 */
void z_arm_fault(uint32_t msp, uint32_t psp, uint32_t exc_return,
	_callee_saved_t *callee_regs)
{
    11f4:	b570      	push	{r4, r5, r6, lr}
	uint32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    11f6:	4b48      	ldr	r3, [pc, #288]	; (1318 <z_arm_fault+0x124>)
    11f8:	685b      	ldr	r3, [r3, #4]
{
    11fa:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
    11fc:	f3c3 0308 	ubfx	r3, r3, #0, #9
	__asm__ volatile(
    1200:	2600      	movs	r6, #0
    1202:	f386 8811 	msr	BASEPRI, r6
    1206:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
    120a:	f002 447f 	and.w	r4, r2, #4278190080	; 0xff000000
    120e:	f1b4 4f7f 	cmp.w	r4, #4278190080	; 0xff000000
    1212:	d112      	bne.n	123a <z_arm_fault+0x46>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
    1214:	f002 040c 	and.w	r4, r2, #12
    1218:	2c08      	cmp	r4, #8
    121a:	d00e      	beq.n	123a <z_arm_fault+0x46>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
    121c:	0714      	lsls	r4, r2, #28
			ptr_esf =  (z_arch_esf_t *)psp;
    121e:	bf4e      	itee	mi
    1220:	460d      	movmi	r5, r1
			ptr_esf = (z_arch_esf_t *)msp;
    1222:	4605      	movpl	r5, r0
			*nested_exc = true;
    1224:	2601      	movpl	r6, #1
	*recoverable = false;
    1226:	2200      	movs	r2, #0
	switch (fault) {
    1228:	3b03      	subs	r3, #3
	*recoverable = false;
    122a:	f88d 2007 	strb.w	r2, [sp, #7]
	switch (fault) {
    122e:	2b03      	cmp	r3, #3
    1230:	d86b      	bhi.n	130a <z_arm_fault+0x116>
    1232:	e8df f003 	tbb	[pc, r3]
    1236:	5504      	.short	0x5504
    1238:	5d59      	.short	0x5d59
		return NULL;
    123a:	4635      	mov	r5, r6
    123c:	e7f3      	b.n	1226 <z_arm_fault+0x32>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
    123e:	4b36      	ldr	r3, [pc, #216]	; (1318 <z_arm_fault+0x124>)
    1240:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    1242:	f014 0402 	ands.w	r4, r4, #2
    1246:	d160      	bne.n	130a <z_arm_fault+0x116>
	} else if ((SCB->HFSR & SCB_HFSR_DEBUGEVT_Msk) != 0) {
    1248:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    124a:	2a00      	cmp	r2, #0
    124c:	db15      	blt.n	127a <z_arm_fault+0x86>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
    124e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    1250:	0052      	lsls	r2, r2, #1
    1252:	d512      	bpl.n	127a <z_arm_fault+0x86>
	uint16_t fault_insn = *(ret_addr - 1);
    1254:	69aa      	ldr	r2, [r5, #24]
	if (((fault_insn & 0xff00) == _SVC_OPCODE) &&
    1256:	f832 1c02 	ldrh.w	r1, [r2, #-2]
    125a:	f64d 7202 	movw	r2, #57090	; 0xdf02
    125e:	4291      	cmp	r1, r2
    1260:	d00a      	beq.n	1278 <z_arm_fault+0x84>
		} else if (SCB_MMFSR != 0) {
    1262:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
    1266:	b30a      	cbz	r2, 12ac <z_arm_fault+0xb8>
			reason = mem_manage_fault(esf, 1, recoverable);
    1268:	f10d 0207 	add.w	r2, sp, #7
    126c:	2101      	movs	r1, #1
		reason = mem_manage_fault(esf, 0, recoverable);
    126e:	4628      	mov	r0, r5
    1270:	f7ff ff66 	bl	1140 <mem_manage_fault>
		reason = bus_fault(esf, 0, recoverable);
    1274:	4604      	mov	r4, r0
		break;
    1276:	e000      	b.n	127a <z_arm_fault+0x86>
			reason = esf->basic.r0;
    1278:	682c      	ldr	r4, [r5, #0]
#ifdef CONFIG_DEBUG_COREDUMP
	z_arm_coredump_fault_sp = POINTER_TO_UINT(esf);
#endif

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
    127a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    127e:	b99b      	cbnz	r3, 12a8 <z_arm_fault+0xb4>
		return;
	}

	/* Copy ESF */
#if !defined(CONFIG_EXTRA_EXCEPTION_INFO)
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
    1280:	2220      	movs	r2, #32
    1282:	4629      	mov	r1, r5
    1284:	a802      	add	r0, sp, #8
    1286:	f004 f8e7 	bl	5458 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
    128a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    128c:	2e00      	cmp	r6, #0
    128e:	d03e      	beq.n	130e <z_arm_fault+0x11a>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
    1290:	f3c3 0208 	ubfx	r2, r3, #0, #9
    1294:	b922      	cbnz	r2, 12a0 <z_arm_fault+0xac>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
    1296:	ea6f 2353 	mvn.w	r3, r3, lsr #9
    129a:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    129e:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
    12a0:	a902      	add	r1, sp, #8
    12a2:	4620      	mov	r0, r4
    12a4:	f004 f892 	bl	53cc <z_arm_fatal_error>
}
    12a8:	b00a      	add	sp, #40	; 0x28
    12aa:	bd70      	pop	{r4, r5, r6, pc}
		} else if (SCB_BFSR != 0) {
    12ac:	f893 2029 	ldrb.w	r2, [r3, #41]	; 0x29
    12b0:	b12a      	cbz	r2, 12be <z_arm_fault+0xca>
			reason = bus_fault(esf, 1, recoverable);
    12b2:	f10d 0107 	add.w	r1, sp, #7
    12b6:	2001      	movs	r0, #1
		reason = bus_fault(esf, 0, recoverable);
    12b8:	f7ff ff7e 	bl	11b8 <bus_fault.constprop.0>
    12bc:	e7da      	b.n	1274 <z_arm_fault+0x80>
		} else if (SCB_UFSR != 0) {
    12be:	8d5a      	ldrh	r2, [r3, #42]	; 0x2a
    12c0:	b292      	uxth	r2, r2
    12c2:	2a00      	cmp	r2, #0
    12c4:	d0d9      	beq.n	127a <z_arm_fault+0x86>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    12c6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    12c8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    12ca:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    12cc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    12ce:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    12d0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    12d2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    12d4:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    12d8:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    12dc:	629a      	str	r2, [r3, #40]	; 0x28
	return reason;
    12de:	e7cc      	b.n	127a <z_arm_fault+0x86>
		reason = mem_manage_fault(esf, 0, recoverable);
    12e0:	f10d 0207 	add.w	r2, sp, #7
    12e4:	2100      	movs	r1, #0
    12e6:	e7c2      	b.n	126e <z_arm_fault+0x7a>
		reason = bus_fault(esf, 0, recoverable);
    12e8:	f10d 0107 	add.w	r1, sp, #7
    12ec:	2000      	movs	r0, #0
    12ee:	e7e3      	b.n	12b8 <z_arm_fault+0xc4>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
    12f0:	4b09      	ldr	r3, [pc, #36]	; (1318 <z_arm_fault+0x124>)
    12f2:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
    12f4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
    12f6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
    12f8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
    12fa:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
    12fc:	6a9a      	ldr	r2, [r3, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
    12fe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
    1300:	ea6f 4202 	mvn.w	r2, r2, lsl #16
    1304:	ea6f 4212 	mvn.w	r2, r2, lsr #16
    1308:	629a      	str	r2, [r3, #40]	; 0x28
	uint32_t reason = K_ERR_CPU_EXCEPTION;
    130a:	2400      	movs	r4, #0
    130c:	e7b5      	b.n	127a <z_arm_fault+0x86>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
    130e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
    1312:	f023 0301 	bic.w	r3, r3, #1
    1316:	e7c2      	b.n	129e <z_arm_fault+0xaa>
    1318:	e000ed00 	.word	0xe000ed00

0000131c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
    131c:	4a02      	ldr	r2, [pc, #8]	; (1328 <z_arm_fault_init+0xc>)
    131e:	6953      	ldr	r3, [r2, #20]
    1320:	f043 0310 	orr.w	r3, r3, #16
    1324:	6153      	str	r3, [r2, #20]
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
#ifdef CONFIG_TRAP_UNALIGNED_ACCESS
	SCB->CCR |= SCB_CCR_UNALIGN_TRP_Msk;
#endif /* CONFIG_TRAP_UNALIGNED_ACCESS */
}
    1326:	4770      	bx	lr
    1328:	e000ed00 	.word	0xe000ed00

0000132c <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
    132c:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
    1330:	f3ef 8109 	mrs	r1, PSP
	push {r0, lr}
    1334:	b501      	push	{r0, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	push {r4-r11}
#endif
	mov  r3, sp /* pointer to _callee_saved_t */
#endif /* CONFIG_EXTRA_EXCEPTION_INFO */
	mov r2, lr /* EXC_RETURN */
    1336:	4672      	mov	r2, lr
	bl z_arm_fault
    1338:	f7ff ff5c 	bl	11f4 <z_arm_fault>
	 * in this routine. Therefore, we can just reset
	 * the MSP to its value prior to entering the function
	 */
	add sp, #40
#endif
	pop {r0, pc}
    133c:	bd01      	pop	{r0, pc}
    133e:	bf00      	nop

00001340 <z_arm_interrupt_init>:
    1340:	4804      	ldr	r0, [pc, #16]	; (1354 <z_arm_interrupt_init+0x14>)
 *
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
    1342:	2300      	movs	r3, #0
    1344:	2120      	movs	r1, #32
    1346:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
    1348:	3301      	adds	r3, #1
    134a:	2b30      	cmp	r3, #48	; 0x30
    134c:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
    1350:	d1f9      	bne.n	1346 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
    1352:	4770      	bx	lr
    1354:	e000e100 	.word	0xe000e100

00001358 <__start>:
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
    /* Reset CONTROL register */
    movs.n r0, #0
    1358:	2000      	movs	r0, #0
    msr CONTROL, r0
    135a:	f380 8814 	msr	CONTROL, r0
    isb
    135e:	f3bf 8f6f 	isb	sy
#endif /* CONFIG_CPU_CORTEX_M_HAS_SPLIM */

#endif /* CONFIG_INIT_ARCH_HW_AT_BOOT */

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_arm_platform_init
    1362:	f004 fc75 	bl	5c50 <z_arm_platform_init>
#endif

#if defined(CONFIG_INIT_ARCH_HW_AT_BOOT)
#if defined(CONFIG_CPU_HAS_ARM_MPU)
    /* Disable MPU */
    movs.n r0, #0
    1366:	2000      	movs	r0, #0
    ldr r1, =_SCS_MPU_CTRL
    1368:	490d      	ldr	r1, [pc, #52]	; (13a0 <__start+0x48>)
    str r0, [r1]
    136a:	6008      	str	r0, [r1, #0]
    dsb
    136c:	f3bf 8f4f 	dsb	sy
#endif /* CONFIG_CPU_HAS_ARM_MPU */
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    1370:	480c      	ldr	r0, [pc, #48]	; (13a4 <__start+0x4c>)
    msr msp, r0
    1372:	f380 8808 	msr	MSP, r0

    /* Initialize core architecture registers and system blocks */
    bl z_arm_init_arch_hw_at_boot
    1376:	f000 f82b 	bl	13d0 <z_arm_init_arch_hw_at_boot>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
    137a:	2020      	movs	r0, #32
    msr BASEPRI, r0
    137c:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
    1380:	4809      	ldr	r0, [pc, #36]	; (13a8 <__start+0x50>)
    ldr r1, =CONFIG_ISR_STACK_SIZE + MPU_GUARD_ALIGN_AND_SIZE
    1382:	f44f 6102 	mov.w	r1, #2080	; 0x820
    adds r0, r0, r1
    1386:	1840      	adds	r0, r0, r1
    msr PSP, r0
    1388:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
    138c:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
    1390:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
    1392:	4308      	orrs	r0, r1
    msr CONTROL, r0
    1394:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
    1398:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
    139c:	f7ff fe4c 	bl	1038 <z_arm_prep_c>
    ldr r1, =_SCS_MPU_CTRL
    13a0:	e000ed94 	.word	0xe000ed94
    ldr r0, =z_main_stack + CONFIG_MAIN_STACK_SIZE
    13a4:	20003f80 	.word	0x20003f80
    ldr r0, =z_interrupt_stacks
    13a8:	20003fa0 	.word	0x20003fa0

000013ac <z_arm_clear_arm_mpu_config>:
void z_arm_clear_arm_mpu_config(void)
{
	int i;

	int num_regions =
		((MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos);
    13ac:	4907      	ldr	r1, [pc, #28]	; (13cc <z_arm_clear_arm_mpu_config+0x20>)
    13ae:	f8d1 2090 	ldr.w	r2, [r1, #144]	; 0x90

	for (i = 0; i < num_regions; i++) {
    13b2:	2300      	movs	r3, #0
	int num_regions =
    13b4:	f3c2 2207 	ubfx	r2, r2, #8, #8
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr)
{
  MPU->RNR = rnr;
  MPU->RASR = 0U;
    13b8:	4618      	mov	r0, r3
	for (i = 0; i < num_regions; i++) {
    13ba:	4293      	cmp	r3, r2
    13bc:	d100      	bne.n	13c0 <z_arm_clear_arm_mpu_config+0x14>
		ARM_MPU_ClrRegion(i);
	}
}
    13be:	4770      	bx	lr
  MPU->RNR = rnr;
    13c0:	f8c1 3098 	str.w	r3, [r1, #152]	; 0x98
  MPU->RASR = 0U;
    13c4:	f8c1 00a0 	str.w	r0, [r1, #160]	; 0xa0
	for (i = 0; i < num_regions; i++) {
    13c8:	3301      	adds	r3, #1
    13ca:	e7f6      	b.n	13ba <z_arm_clear_arm_mpu_config+0xe>
    13cc:	e000ed00 	.word	0xe000ed00

000013d0 <z_arm_init_arch_hw_at_boot>:
 * This routine resets Cortex-M system control block
 * components and core registers.
 *
 */
void z_arm_init_arch_hw_at_boot(void)
{
    13d0:	b508      	push	{r3, lr}
  __ASM volatile ("cpsid i" : : : "memory");
    13d2:	b672      	cpsid	i
  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
    13d4:	2300      	movs	r3, #0
    13d6:	f383 8813 	msr	FAULTMASK, r3

	/* Initialize System Control Block components */

#if defined(CONFIG_CPU_HAS_ARM_MPU) || defined(CONFIG_CPU_HAS_NXP_MPU)
	/* Clear MPU region configuration */
	z_arm_clear_arm_mpu_config();
    13da:	f7ff ffe7 	bl	13ac <z_arm_clear_arm_mpu_config>
#endif /* CONFIG_CPU_HAS_ARM_MPU */

	/* Disable NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICER); i++) {
		NVIC->ICER[i] = 0xFFFFFFFF;
    13de:	4b14      	ldr	r3, [pc, #80]	; (1430 <z_arm_init_arch_hw_at_boot+0x60>)
    13e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    13e4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    13e8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    13ec:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    13f0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
    13f4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    13f8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    13fc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
    1400:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
	}
	/* Clear pending NVIC interrupts */
	for (uint8_t i = 0; i < ARRAY_SIZE(NVIC->ICPR); i++) {
		NVIC->ICPR[i] = 0xFFFFFFFF;
    1404:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    1408:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
    140c:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
    1410:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
    1414:	f8c3 2190 	str.w	r2, [r3, #400]	; 0x190
    1418:	f8c3 2194 	str.w	r2, [r3, #404]	; 0x194
    141c:	f8c3 2198 	str.w	r2, [r3, #408]	; 0x198
    1420:	f8c3 219c 	str.w	r2, [r3, #412]	; 0x19c
  __ASM volatile ("cpsie i" : : : "memory");
    1424:	b662      	cpsie	i
  __ASM volatile ("dsb 0xF":::"memory");
    1426:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    142a:	f3bf 8f6f 	isb	sy
	/* Restore Interrupts */
	__enable_irq();

	__DSB();
	__ISB();
}
    142e:	bd08      	pop	{r3, pc}
    1430:	e000e100 	.word	0xe000e100

00001434 <z_arm_configure_static_mpu_regions>:
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
    1434:	4b02      	ldr	r3, [pc, #8]	; (1440 <z_arm_configure_static_mpu_regions+0xc>)
    1436:	4a03      	ldr	r2, [pc, #12]	; (1444 <z_arm_configure_static_mpu_regions+0x10>)
    1438:	4803      	ldr	r0, [pc, #12]	; (1448 <z_arm_configure_static_mpu_regions+0x14>)
    143a:	2102      	movs	r1, #2
    143c:	f000 b85e 	b.w	14fc <arm_core_mpu_configure_static_mpu_regions>
    1440:	20040000 	.word	0x20040000
    1444:	20000000 	.word	0x20000000
    1448:	00005f44 	.word	0x00005f44

0000144c <mpu_configure_regions>:
 * sanity check of the memory regions to be programmed.
 */
static int mpu_configure_regions(const struct z_arm_mpu_partition
	regions[], uint8_t regions_num, uint8_t start_reg_index,
	bool do_sanity_check)
{
    144c:	b5f0      	push	{r4, r5, r6, r7, lr}
#endif /* CPU_CORTEX_M0PLUS | CPU_CORTEX_M3 | CPU_CORTEX_M4 */
}

static inline void set_region_number(uint32_t index)
{
	MPU->RNR = index;
    144e:	4f1f      	ldr	r7, [pc, #124]	; (14cc <mpu_configure_regions+0x80>)
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
    1450:	2600      	movs	r6, #0
    1452:	428e      	cmp	r6, r1
    1454:	db01      	blt.n	145a <mpu_configure_regions+0xe>
		/* Increment number of programmed MPU indices. */
		reg_index++;
	}

	return reg_index;
}
    1456:	4610      	mov	r0, r2
    1458:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (regions[i].size == 0U) {
    145a:	6844      	ldr	r4, [r0, #4]
    145c:	b39c      	cbz	r4, 14c6 <mpu_configure_regions+0x7a>
		if (do_sanity_check &&
    145e:	b153      	cbz	r3, 1476 <mpu_configure_regions+0x2a>
	 * and greater or equal to the minimum
	 * MPU region size. Start address of the
	 * partition must align with size.
	 */
	int partition_is_valid =
		((part->size & (part->size - 1U)) == 0U)
    1460:	f104 3cff 	add.w	ip, r4, #4294967295	; 0xffffffff
		&&
		(part->size >= CONFIG_ARM_MPU_REGION_MIN_ALIGN_AND_SIZE)
		&&
    1464:	ea14 0f0c 	tst.w	r4, ip
    1468:	d118      	bne.n	149c <mpu_configure_regions+0x50>
		&&
    146a:	2c1f      	cmp	r4, #31
    146c:	d916      	bls.n	149c <mpu_configure_regions+0x50>
		((part->start & (part->size - 1U)) == 0U);
    146e:	6805      	ldr	r5, [r0, #0]
		&&
    1470:	ea1c 0f05 	tst.w	ip, r5
    1474:	d112      	bne.n	149c <mpu_configure_regions+0x50>
 * to that power-of-two value.
 */
static inline uint32_t size_to_mpu_rasr_size(uint32_t size)
{
	/* The minimal supported region size is 32 bytes */
	if (size <= 32U) {
    1476:	2c20      	cmp	r4, #32
	region_conf.base = new_region->start;
    1478:	6805      	ldr	r5, [r0, #0]
#if defined(CONFIG_CPU_AARCH32_CORTEX_R)
	(void) size;

	p_attr->rasr = attr->rasr_attr;
#else
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    147a:	f8d0 c008 	ldr.w	ip, [r0, #8]
		reg_index = mpu_configure_region(reg_index, &regions[i]);
    147e:	b2d2      	uxtb	r2, r2
	if (size <= 32U) {
    1480:	d90f      	bls.n	14a2 <mpu_configure_regions+0x56>
	if (size > (1UL << 31)) {
    1482:	f1b4 4f00 	cmp.w	r4, #2147483648	; 0x80000000
    1486:	d80e      	bhi.n	14a6 <mpu_configure_regions+0x5a>
	return ((32 - __builtin_clz(size - 1U) - 2 + 1) << MPU_RASR_SIZE_Pos) &
    1488:	3c01      	subs	r4, #1
    148a:	fab4 f484 	clz	r4, r4
    148e:	f1c4 041f 	rsb	r4, r4, #31
    1492:	0064      	lsls	r4, r4, #1
	if (index > (get_num_regions() - 1U)) {
    1494:	2a07      	cmp	r2, #7
	p_attr->rasr = attr->rasr_attr | size_to_mpu_rasr_size(size);
    1496:	ea4c 0404 	orr.w	r4, ip, r4
    149a:	d906      	bls.n	14aa <mpu_configure_regions+0x5e>
			return -EINVAL;
    149c:	f06f 0215 	mvn.w	r2, #21
    14a0:	e7d9      	b.n	1456 <mpu_configure_regions+0xa>
		return REGION_32B;
    14a2:	2408      	movs	r4, #8
    14a4:	e7f6      	b.n	1494 <mpu_configure_regions+0x48>
		return REGION_4G;
    14a6:	243e      	movs	r4, #62	; 0x3e
    14a8:	e7f4      	b.n	1494 <mpu_configure_regions+0x48>
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    14aa:	f025 051f 	bic.w	r5, r5, #31
				| MPU_RBAR_VALID_Msk | index;
    14ae:	4315      	orrs	r5, r2
    14b0:	f045 0510 	orr.w	r5, r5, #16
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    14b4:	f044 0401 	orr.w	r4, r4, #1
    14b8:	f8c7 2098 	str.w	r2, [r7, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    14bc:	f8c7 509c 	str.w	r5, [r7, #156]	; 0x9c
		reg_index++;
    14c0:	3201      	adds	r2, #1
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    14c2:	f8c7 40a0 	str.w	r4, [r7, #160]	; 0xa0
	for (i = 0; i < regions_num; i++) {
    14c6:	3601      	adds	r6, #1
    14c8:	300c      	adds	r0, #12
    14ca:	e7c2      	b.n	1452 <mpu_configure_regions+0x6>
    14cc:	e000ed00 	.word	0xe000ed00

000014d0 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
    14d0:	4b04      	ldr	r3, [pc, #16]	; (14e4 <arm_core_mpu_enable+0x14>)
    14d2:	2205      	movs	r2, #5
    14d4:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  __ASM volatile ("dsb 0xF":::"memory");
    14d8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    14dc:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
    14e0:	4770      	bx	lr
    14e2:	bf00      	nop
    14e4:	e000ed00 	.word	0xe000ed00

000014e8 <arm_core_mpu_disable>:
  __ASM volatile ("dmb 0xF":::"memory");
    14e8:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
    14ec:	4b02      	ldr	r3, [pc, #8]	; (14f8 <arm_core_mpu_disable+0x10>)
    14ee:	2200      	movs	r2, #0
    14f0:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    14f4:	4770      	bx	lr
    14f6:	bf00      	nop
    14f8:	e000ed00 	.word	0xe000ed00

000014fc <arm_core_mpu_configure_static_mpu_regions>:
 * @brief configure fixed (static) MPU regions.
 */
void arm_core_mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_start, const uint32_t background_area_end)
{
    14fc:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct z_arm_mpu_partition
	static_regions[], const uint8_t regions_num,
	const uint32_t background_area_base,
	const uint32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
    14fe:	4c03      	ldr	r4, [pc, #12]	; (150c <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * programmed on top of SRAM region configuration.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions(static_regions,
    1500:	2301      	movs	r3, #1
    1502:	7822      	ldrb	r2, [r4, #0]
    1504:	f7ff ffa2 	bl	144c <mpu_configure_regions>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
    1508:	7020      	strb	r0, [r4, #0]
					       background_area_start, background_area_end) == -EINVAL) {

		__ASSERT(0, "Configuring %u static MPU regions failed\n",
			regions_num);
	}
}
    150a:	bd10      	pop	{r4, pc}
    150c:	20001769 	.word	0x20001769

00001510 <z_arm_mpu_init>:
 */
int z_arm_mpu_init(void)
{
	uint32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
    1510:	4914      	ldr	r1, [pc, #80]	; (1564 <z_arm_mpu_init+0x54>)
    1512:	6808      	ldr	r0, [r1, #0]
    1514:	2808      	cmp	r0, #8
{
    1516:	b510      	push	{r4, lr}
	if (mpu_config.num_regions > get_num_regions()) {
    1518:	d821      	bhi.n	155e <z_arm_mpu_init+0x4e>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
    151a:	f7ff ffe5 	bl	14e8 <arm_core_mpu_disable>
    151e:	4c12      	ldr	r4, [pc, #72]	; (1568 <z_arm_mpu_init+0x58>)
    1520:	6849      	ldr	r1, [r1, #4]

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    1522:	2200      	movs	r2, #0
    1524:	4290      	cmp	r0, r2
    1526:	f101 010c 	add.w	r1, r1, #12
    152a:	d105      	bne.n	1538 <z_arm_mpu_init+0x28>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
    152c:	4b0f      	ldr	r3, [pc, #60]	; (156c <z_arm_mpu_init+0x5c>)
    152e:	7018      	strb	r0, [r3, #0]


	arm_core_mpu_enable();
    1530:	f7ff ffce 	bl	14d0 <arm_core_mpu_enable>
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */

	return 0;
    1534:	2000      	movs	r0, #0
}
    1536:	bd10      	pop	{r4, pc}
    1538:	f8c4 2098 	str.w	r2, [r4, #152]	; 0x98
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    153c:	f851 3c0c 	ldr.w	r3, [r1, #-12]
    1540:	f023 031f 	bic.w	r3, r3, #31
				| MPU_RBAR_VALID_Msk | index;
    1544:	4313      	orrs	r3, r2
    1546:	f043 0310 	orr.w	r3, r3, #16
	MPU->RBAR = (region_conf->base & MPU_RBAR_ADDR_Msk)
    154a:	f8c4 309c 	str.w	r3, [r4, #156]	; 0x9c
	MPU->RASR = region_conf->attr.rasr | MPU_RASR_ENABLE_Msk;
    154e:	f851 3c04 	ldr.w	r3, [r1, #-4]
    1552:	f043 0301 	orr.w	r3, r3, #1
    1556:	f8c4 30a0 	str.w	r3, [r4, #160]	; 0xa0
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
    155a:	3201      	adds	r2, #1
    155c:	e7e2      	b.n	1524 <z_arm_mpu_init+0x14>
		return -1;
    155e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    1562:	e7e8      	b.n	1536 <z_arm_mpu_init+0x26>
    1564:	00005f5c 	.word	0x00005f5c
    1568:	e000ed00 	.word	0xe000ed00
    156c:	20001769 	.word	0x20001769

00001570 <nordicsemi_nrf52_init>:
	nrf_power_gpregret_set(NRF_POWER, (uint8_t)type);
	NVIC_SystemReset();
}

static int nordicsemi_nrf52_init(const struct device *arg)
{
    1570:	b510      	push	{r4, lr}
	__asm__ volatile(
    1572:	f04f 0320 	mov.w	r3, #32
    1576:	f3ef 8011 	mrs	r0, BASEPRI
    157a:	f383 8812 	msr	BASEPRI_MAX, r3
    157e:	f3bf 8f6f 	isb	sy
#endif

#if NRF_POWER_HAS_DCDCEN
NRF_STATIC_INLINE void nrf_power_dcdcen_set(NRF_POWER_Type * p_reg, bool enable)
{
    p_reg->DCDCEN = (enable ? POWER_DCDCEN_DCDCEN_Enabled : POWER_DCDCEN_DCDCEN_Disabled) <<
    1582:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1586:	2201      	movs	r2, #1
{
    #ifndef NRF52_SERIES
        return false;
    #else
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    1588:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    158c:	f8c3 2578 	str.w	r2, [r3, #1400]	; 0x578
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    1590:	f8d1 4130 	ldr.w	r4, [r1, #304]	; 0x130
    1594:	2c08      	cmp	r4, #8
    1596:	d108      	bne.n	15aa <nordicsemi_nrf52_init+0x3a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    1598:	f8d1 1134 	ldr.w	r1, [r1, #308]	; 0x134
            {
                switch(var2)
    159c:	2905      	cmp	r1, #5
    159e:	d804      	bhi.n	15aa <nordicsemi_nrf52_init+0x3a>
#endif // defined(POWER_RAM_POWER_S0POWER_Msk)

#if NRF_POWER_HAS_DCDCEN_VDDH
NRF_STATIC_INLINE void nrf_power_dcdcen_vddh_set(NRF_POWER_Type * p_reg, bool enable)
{
    if (enable && nrf52_errata_197())
    15a0:	4c07      	ldr	r4, [pc, #28]	; (15c0 <nordicsemi_nrf52_init+0x50>)
    15a2:	5c61      	ldrb	r1, [r4, r1]
    15a4:	b109      	cbz	r1, 15aa <nordicsemi_nrf52_init+0x3a>
    {
        // Workaround for anomaly 197 "POWER: DCDC of REG0 not functional".
        *(volatile uint32_t *)0x40000638ul = 1ul;
    15a6:	f8c3 2638 	str.w	r2, [r3, #1592]	; 0x638
    }
    p_reg->DCDCEN0 = (enable ? POWER_DCDCEN0_DCDCEN_Enabled : POWER_DCDCEN0_DCDCEN_Disabled) <<
    15aa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    15ae:	2201      	movs	r2, #1
    15b0:	f8c3 2580 	str.w	r2, [r3, #1408]	; 0x580
	__asm__ volatile(
    15b4:	f380 8811 	msr	BASEPRI, r0
    15b8:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
    15bc:	2000      	movs	r0, #0
    15be:	bd10      	pop	{r4, pc}
    15c0:	00006284 	.word	0x00006284

000015c4 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
    15c4:	b120      	cbz	r0, 15d0 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
    15c6:	4b03      	ldr	r3, [pc, #12]	; (15d4 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
    15c8:	0180      	lsls	r0, r0, #6
    15ca:	f043 0301 	orr.w	r3, r3, #1
    15ce:	4718      	bx	r3

void arch_busy_wait(uint32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
    15d0:	4770      	bx	lr
    15d2:	bf00      	nop
    15d4:	00005e90 	.word	0x00005e90

000015d8 <onoff_stop>:
}

static clock_control_subsys_t get_subsys(struct onoff_manager *mgr)
{
	struct nrf_clock_control_data *data = CLOCK_DEVICE->data;
	size_t offset = (size_t)(mgr - data->mgr);
    15d8:	4b08      	ldr	r3, [pc, #32]	; (15fc <onoff_stop+0x24>)
	return (clock_control_subsys_t)offset;
}

static void onoff_stop(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    15da:	b570      	push	{r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    15dc:	1ac3      	subs	r3, r0, r3
{
    15de:	460d      	mov	r5, r1
	int res;

	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    15e0:	4907      	ldr	r1, [pc, #28]	; (1600 <onoff_stop+0x28>)
	size_t offset = (size_t)(mgr - data->mgr);
    15e2:	109b      	asrs	r3, r3, #2
{
    15e4:	4604      	mov	r4, r0
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    15e6:	4359      	muls	r1, r3
    15e8:	4806      	ldr	r0, [pc, #24]	; (1604 <onoff_stop+0x2c>)
    15ea:	2240      	movs	r2, #64	; 0x40
    15ec:	f003 ff64 	bl	54b8 <stop>
	notify(mgr, res);
    15f0:	462b      	mov	r3, r5
	res = stop(CLOCK_DEVICE, get_subsys(mgr), CTX_ONOFF);
    15f2:	4601      	mov	r1, r0
	notify(mgr, res);
    15f4:	4620      	mov	r0, r4
}
    15f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	notify(mgr, res);
    15fa:	4718      	bx	r3
    15fc:	2000152c 	.word	0x2000152c
    1600:	b6db6db7 	.word	0xb6db6db7
    1604:	00005c8c 	.word	0x00005c8c

00001608 <onoff_start>:
	notify(mgr, 0);
}

static void onoff_start(struct onoff_manager *mgr,
			onoff_notify_fn notify)
{
    1608:	b573      	push	{r0, r1, r4, r5, r6, lr}
	size_t offset = (size_t)(mgr - data->mgr);
    160a:	4c0c      	ldr	r4, [pc, #48]	; (163c <onoff_start+0x34>)
	int err;

	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    160c:	4a0c      	ldr	r2, [pc, #48]	; (1640 <onoff_start+0x38>)
    160e:	2340      	movs	r3, #64	; 0x40
	size_t offset = (size_t)(mgr - data->mgr);
    1610:	1b04      	subs	r4, r0, r4
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1612:	9300      	str	r3, [sp, #0]
{
    1614:	460d      	mov	r5, r1
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1616:	460b      	mov	r3, r1
    1618:	490a      	ldr	r1, [pc, #40]	; (1644 <onoff_start+0x3c>)
	size_t offset = (size_t)(mgr - data->mgr);
    161a:	10a4      	asrs	r4, r4, #2
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    161c:	4361      	muls	r1, r4
{
    161e:	4606      	mov	r6, r0
	err = async_start(CLOCK_DEVICE, get_subsys(mgr),
    1620:	4809      	ldr	r0, [pc, #36]	; (1648 <onoff_start+0x40>)
    1622:	f003 ff75 	bl	5510 <async_start>
			  onoff_started_callback, notify, CTX_ONOFF);
	if (err < 0) {
    1626:	1e01      	subs	r1, r0, #0
    1628:	da05      	bge.n	1636 <onoff_start+0x2e>
		notify(mgr, err);
    162a:	4630      	mov	r0, r6
    162c:	462b      	mov	r3, r5
	}
}
    162e:	b002      	add	sp, #8
    1630:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		notify(mgr, err);
    1634:	4718      	bx	r3
}
    1636:	b002      	add	sp, #8
    1638:	bd70      	pop	{r4, r5, r6, pc}
    163a:	bf00      	nop
    163c:	2000152c 	.word	0x2000152c
    1640:	00005585 	.word	0x00005585
    1644:	b6db6db7 	.word	0xb6db6db7
    1648:	00005c8c 	.word	0x00005c8c

0000164c <clk_init>:
	static const struct onoff_transitions transitions = {
		.start = onoff_start,
		.stop = onoff_stop
	};

	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    164c:	2200      	movs	r2, #0
{
    164e:	b570      	push	{r4, r5, r6, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    1650:	2101      	movs	r1, #1
{
    1652:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
    1654:	4610      	mov	r0, r2
    1656:	f7ff fcd3 	bl	1000 <z_arm_irq_priority_set>
		    nrfx_isr, nrfx_power_clock_irq_handler, 0);

	nrfx_err = nrfx_clock_init(clock_event_handler);
    165a:	480f      	ldr	r0, [pc, #60]	; (1698 <clk_init+0x4c>)
    165c:	f001 f8f6 	bl	284c <nrfx_clock_init>
	if (nrfx_err != NRFX_SUCCESS) {
    1660:	4b0e      	ldr	r3, [pc, #56]	; (169c <clk_init+0x50>)
    1662:	4298      	cmp	r0, r3
    1664:	d115      	bne.n	1692 <clk_init+0x46>
		struct nrf_clock_control_data *data = dev->data;

		z_nrf_clock_calibration_init(data->mgr);
	}

	nrfx_clock_enable();
    1666:	f004 fa1e 	bl	5aa6 <nrfx_clock_enable>
	struct nrf_clock_control_data *data = dev->data;
    166a:	6926      	ldr	r6, [r4, #16]
	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		struct nrf_clock_control_sub_data *subdata =
						get_sub_data(dev, i);

		err = onoff_manager_init(get_onoff_manager(dev, i),
    166c:	490c      	ldr	r1, [pc, #48]	; (16a0 <clk_init+0x54>)
    166e:	4630      	mov	r0, r6
    1670:	f003 fdcd 	bl	520e <onoff_manager_init>
					 &transitions);
		if (err < 0) {
    1674:	2800      	cmp	r0, #0
    1676:	db0b      	blt.n	1690 <clk_init+0x44>
	struct nrf_clock_control_data *data = dev->data;
    1678:	6924      	ldr	r4, [r4, #16]
		err = onoff_manager_init(get_onoff_manager(dev, i),
    167a:	4909      	ldr	r1, [pc, #36]	; (16a0 <clk_init+0x54>)
			return err;
		}

		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    167c:	2501      	movs	r5, #1
    167e:	6435      	str	r5, [r6, #64]	; 0x40
		err = onoff_manager_init(get_onoff_manager(dev, i),
    1680:	f104 001c 	add.w	r0, r4, #28
    1684:	f003 fdc3 	bl	520e <onoff_manager_init>
		if (err < 0) {
    1688:	2800      	cmp	r0, #0
    168a:	db01      	blt.n	1690 <clk_init+0x44>
		subdata->flags = CLOCK_CONTROL_STATUS_OFF;
    168c:	64e5      	str	r5, [r4, #76]	; 0x4c
	}

	return 0;
    168e:	2000      	movs	r0, #0
}
    1690:	bd70      	pop	{r4, r5, r6, pc}
		return -EIO;
    1692:	f06f 0004 	mvn.w	r0, #4
    1696:	e7fb      	b.n	1690 <clk_init+0x44>
    1698:	000016e1 	.word	0x000016e1
    169c:	0bad0000 	.word	0x0bad0000
    16a0:	00005fa4 	.word	0x00005fa4

000016a4 <clkstarted_handle.constprop.0>:
static void clkstarted_handle(const struct device *dev,
    16a4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	clock_control_cb_t callback = sub_data->cb;
    16a6:	230c      	movs	r3, #12
static void clkstarted_handle(const struct device *dev,
    16a8:	4601      	mov	r1, r0
	clock_control_cb_t callback = sub_data->cb;
    16aa:	480b      	ldr	r0, [pc, #44]	; (16d8 <clkstarted_handle.constprop.0+0x34>)
    16ac:	434b      	muls	r3, r1
    16ae:	18c4      	adds	r4, r0, r3
	void *user_data = sub_data->user_data;
    16b0:	e9d4 520e 	ldrd	r5, r2, [r4, #56]	; 0x38
	sub_data->cb = NULL;
    16b4:	2600      	movs	r6, #0
	set_on_state(&sub_data->flags);
    16b6:	3340      	adds	r3, #64	; 0x40
	sub_data->cb = NULL;
    16b8:	63a6      	str	r6, [r4, #56]	; 0x38
	set_on_state(&sub_data->flags);
    16ba:	4418      	add	r0, r3
	void *user_data = sub_data->user_data;
    16bc:	9201      	str	r2, [sp, #4]
	set_on_state(&sub_data->flags);
    16be:	f003 fee8 	bl	5492 <set_on_state>
	if (callback) {
    16c2:	b135      	cbz	r5, 16d2 <clkstarted_handle.constprop.0+0x2e>
		callback(dev, (clock_control_subsys_t)type, user_data);
    16c4:	9a01      	ldr	r2, [sp, #4]
    16c6:	4805      	ldr	r0, [pc, #20]	; (16dc <clkstarted_handle.constprop.0+0x38>)
    16c8:	462b      	mov	r3, r5
}
    16ca:	b002      	add	sp, #8
    16cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		callback(dev, (clock_control_subsys_t)type, user_data);
    16d0:	4718      	bx	r3
}
    16d2:	b002      	add	sp, #8
    16d4:	bd70      	pop	{r4, r5, r6, pc}
    16d6:	bf00      	nop
    16d8:	2000152c 	.word	0x2000152c
    16dc:	00005c8c 	.word	0x00005c8c

000016e0 <clock_event_handler>:
	switch (event) {
    16e0:	b110      	cbz	r0, 16e8 <clock_event_handler+0x8>
    16e2:	2801      	cmp	r0, #1
    16e4:	d004      	beq.n	16f0 <clock_event_handler+0x10>
    16e6:	4770      	bx	lr
		if (GET_STATUS(data->flags) == CLOCK_CONTROL_STATUS_STARTING) {
    16e8:	4b03      	ldr	r3, [pc, #12]	; (16f8 <clock_event_handler+0x18>)
    16ea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    16ec:	075b      	lsls	r3, r3, #29
    16ee:	d101      	bne.n	16f4 <clock_event_handler+0x14>
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
    16f0:	f7ff bfd8 	b.w	16a4 <clkstarted_handle.constprop.0>
}
    16f4:	4770      	bx	lr
    16f6:	bf00      	nop
    16f8:	2000152c 	.word	0x2000152c

000016fc <generic_hfclk_start>:
{
    16fc:	b508      	push	{r3, lr}
	__asm__ volatile(
    16fe:	f04f 0320 	mov.w	r3, #32
    1702:	f3ef 8111 	mrs	r1, BASEPRI
    1706:	f383 8812 	msr	BASEPRI_MAX, r3
    170a:	f3bf 8f6f 	isb	sy
	hfclk_users |= HF_USER_GENERIC;
    170e:	4a12      	ldr	r2, [pc, #72]	; (1758 <generic_hfclk_start+0x5c>)
    1710:	6813      	ldr	r3, [r2, #0]
    1712:	f043 0002 	orr.w	r0, r3, #2
	if (hfclk_users & HF_USER_BT) {
    1716:	f013 0301 	ands.w	r3, r3, #1
	hfclk_users |= HF_USER_GENERIC;
    171a:	6010      	str	r0, [r2, #0]
	if (hfclk_users & HF_USER_BT) {
    171c:	d00c      	beq.n	1738 <generic_hfclk_start+0x3c>
            break;
        case NRF_CLOCK_DOMAIN_HFCLK:
            if (p_clk_src != NULL)
            {
                (*(nrf_clock_hfclk_t *)p_clk_src) =
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    171e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    1722:	f8d2 340c 	ldr.w	r3, [r2, #1036]	; 0x40c
                                        >> CLOCK_HFCLKSTAT_SRC_Pos);
            }
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    1726:	f8d2 240c 	ldr.w	r2, [r2, #1036]	; 0x40c
		if (type == NRF_CLOCK_HFCLK_HIGH_ACCURACY) {
    172a:	f013 0301 	ands.w	r3, r3, #1
    172e:	d003      	beq.n	1738 <generic_hfclk_start+0x3c>
			set_on_state(get_hf_flags());
    1730:	480a      	ldr	r0, [pc, #40]	; (175c <generic_hfclk_start+0x60>)
    1732:	f003 feae 	bl	5492 <set_on_state>
			already_started = true;
    1736:	2301      	movs	r3, #1
	__asm__ volatile(
    1738:	f381 8811 	msr	BASEPRI, r1
    173c:	f3bf 8f6f 	isb	sy
	if (already_started) {
    1740:	b123      	cbz	r3, 174c <generic_hfclk_start+0x50>
}
    1742:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(CLOCK_DEVICE,
    1746:	2000      	movs	r0, #0
    1748:	f7ff bfac 	b.w	16a4 <clkstarted_handle.constprop.0>
}
    174c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_start(void)
{
    nrfx_clock_start(NRF_CLOCK_DOMAIN_HFCLK);
    1750:	2001      	movs	r0, #1
    1752:	f004 b9b5 	b.w	5ac0 <nrfx_clock_start>
    1756:	bf00      	nop
    1758:	2000157c 	.word	0x2000157c
    175c:	2000156c 	.word	0x2000156c

00001760 <generic_hfclk_stop>:
 *
 * @return Previous value of @a target.
 */
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    1760:	4b09      	ldr	r3, [pc, #36]	; (1788 <generic_hfclk_stop+0x28>)
    1762:	f3bf 8f5b 	dmb	ish
    1766:	e853 2f00 	ldrex	r2, [r3]
    176a:	f022 0102 	bic.w	r1, r2, #2
    176e:	e843 1000 	strex	r0, r1, [r3]
    1772:	2800      	cmp	r0, #0
    1774:	d1f7      	bne.n	1766 <generic_hfclk_stop+0x6>
    1776:	f3bf 8f5b 	dmb	ish
	if (atomic_and(&hfclk_users, ~HF_USER_GENERIC) & HF_USER_BT) {
    177a:	07d3      	lsls	r3, r2, #31
    177c:	d402      	bmi.n	1784 <generic_hfclk_stop+0x24>
}

NRFX_STATIC_INLINE void nrfx_clock_hfclk_stop(void)
{
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_HFCLK);
    177e:	2001      	movs	r0, #1
    1780:	f004 b9db 	b.w	5b3a <nrfx_clock_stop>
}
    1784:	4770      	bx	lr
    1786:	bf00      	nop
    1788:	2000157c 	.word	0x2000157c

0000178c <z_nrf_clock_control_lf_on>:
{
    178c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
    1790:	4937      	ldr	r1, [pc, #220]	; (1870 <z_nrf_clock_control_lf_on+0xe4>)
    1792:	f3bf 8f5b 	dmb	ish
    1796:	4607      	mov	r7, r0
    1798:	2201      	movs	r2, #1
    179a:	e851 3f00 	ldrex	r3, [r1]
    179e:	e841 2000 	strex	r0, r2, [r1]
    17a2:	2800      	cmp	r0, #0
    17a4:	d1f9      	bne.n	179a <z_nrf_clock_control_lf_on+0xe>
    17a6:	f3bf 8f5b 	dmb	ish
	if (atomic_set(&on, 1) == 0) {
    17aa:	b933      	cbnz	r3, 17ba <z_nrf_clock_control_lf_on+0x2e>
 */
static inline void sys_notify_init_spinwait(struct sys_notify *notify)
{
	__ASSERT_NO_MSG(notify != NULL);

	*notify = (struct sys_notify){
    17ac:	4931      	ldr	r1, [pc, #196]	; (1874 <z_nrf_clock_control_lf_on+0xe8>)
		err = onoff_request(mgr, &cli);
    17ae:	4832      	ldr	r0, [pc, #200]	; (1878 <z_nrf_clock_control_lf_on+0xec>)
    17b0:	604b      	str	r3, [r1, #4]
    17b2:	60cb      	str	r3, [r1, #12]
    17b4:	608a      	str	r2, [r1, #8]
    17b6:	f003 fd3d 	bl	5234 <onoff_request>
	switch (start_mode) {
    17ba:	1e7b      	subs	r3, r7, #1
    17bc:	2b01      	cmp	r3, #1
    17be:	d831      	bhi.n	1824 <z_nrf_clock_control_lf_on+0x98>
	if ((mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE) &&
    17c0:	2f01      	cmp	r7, #1
    17c2:	d107      	bne.n	17d4 <z_nrf_clock_control_lf_on+0x48>
    return clk_src;
}

NRF_STATIC_INLINE nrf_clock_lfclk_t nrf_clock_lf_srccopy_get(NRF_CLOCK_Type const * p_reg)
{
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    17c4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    17c8:	f8d3 341c 	ldr.w	r3, [r3, #1052]	; 0x41c
    17cc:	f003 0303 	and.w	r3, r3, #3
	    (target_type == NRF_CLOCK_LFCLK_Xtal) &&
    17d0:	2b01      	cmp	r3, #1
    17d2:	d027      	beq.n	1824 <z_nrf_clock_control_lf_on+0x98>
	bool isr_mode = k_is_in_isr() || k_is_pre_kernel();
    17d4:	f004 fa04 	bl	5be0 <k_is_in_isr>
    17d8:	4604      	mov	r4, r0
    17da:	b918      	cbnz	r0, 17e4 <z_nrf_clock_control_lf_on+0x58>
 */
static inline bool k_is_pre_kernel(void)
{
	extern bool z_sys_post_kernel; /* in init.c */

	return !z_sys_post_kernel;
    17dc:	4b27      	ldr	r3, [pc, #156]	; (187c <z_nrf_clock_control_lf_on+0xf0>)
	int key = isr_mode ? irq_lock() : 0;
    17de:	781b      	ldrb	r3, [r3, #0]
    17e0:	2b00      	cmp	r3, #0
    17e2:	d13d      	bne.n	1860 <z_nrf_clock_control_lf_on+0xd4>
	__asm__ volatile(
    17e4:	f04f 0320 	mov.w	r3, #32
    17e8:	f3ef 8611 	mrs	r6, BASEPRI
    17ec:	f383 8812 	msr	BASEPRI_MAX, r3
    17f0:	f3bf 8f6f 	isb	sy
    17f4:	2401      	movs	r4, #1
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    17f6:	f8df 9088 	ldr.w	r9, [pc, #136]	; 1880 <z_nrf_clock_control_lf_on+0xf4>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    17fa:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    p_reg->LFCLKSRC = (uint32_t)(source);
    17fe:	f04f 0801 	mov.w	r8, #1
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    1802:	f8d5 3418 	ldr.w	r3, [r5, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    1806:	f8d5 2418 	ldr.w	r2, [r5, #1048]	; 0x418
    180a:	03d2      	lsls	r2, r2, #15
    180c:	d50c      	bpl.n	1828 <z_nrf_clock_control_lf_on+0x9c>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    180e:	f003 0303 	and.w	r3, r3, #3
	while (!(nrfx_clock_is_running(d, (void *)&type)
    1812:	2b01      	cmp	r3, #1
    1814:	d001      	beq.n	181a <z_nrf_clock_control_lf_on+0x8e>
		     || (mode == CLOCK_CONTROL_NRF_LF_START_AVAILABLE)))) {
    1816:	2f01      	cmp	r7, #1
    1818:	d106      	bne.n	1828 <z_nrf_clock_control_lf_on+0x9c>
	if (isr_mode) {
    181a:	b1dc      	cbz	r4, 1854 <z_nrf_clock_control_lf_on+0xc8>
	__asm__ volatile(
    181c:	f386 8811 	msr	BASEPRI, r6
    1820:	f3bf 8f6f 	isb	sy
}
    1824:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 *
 * @param key Interrupt locking key obtained from irq_lock().
 */
static inline void k_cpu_atomic_idle(unsigned int key)
{
	arch_cpu_atomic_idle(key);
    1828:	4630      	mov	r0, r6
    182a:	f7ff fbad 	bl	f88 <arch_cpu_atomic_idle>
    return (nrf_clock_lfclk_t)(p_reg->LFCLKSRC);
    182e:	f8d5 3518 	ldr.w	r3, [r5, #1304]	; 0x518
		if ((target_type ==  NRF_CLOCK_LFCLK_Xtal)
    1832:	2b00      	cmp	r3, #0
    1834:	d1e5      	bne.n	1802 <z_nrf_clock_control_lf_on+0x76>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    1836:	f8d5 2104 	ldr.w	r2, [r5, #260]	; 0x104
		    && nrf_clock_event_check(NRF_CLOCK,
    183a:	2a00      	cmp	r2, #0
    183c:	d0e1      	beq.n	1802 <z_nrf_clock_control_lf_on+0x76>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    183e:	f8c5 3104 	str.w	r3, [r5, #260]	; 0x104
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_event_readback(void * p_event_reg)
{
#if NRFX_CHECK(NRFX_EVENT_READBACK_ENABLED) && !defined(NRF51)
    (void)*((volatile uint32_t *)(p_event_reg));
    1842:	f8d5 3104 	ldr.w	r3, [r5, #260]	; 0x104
    p_reg->LFCLKSRC = (uint32_t)(source);
    1846:	f8c5 8518 	str.w	r8, [r5, #1304]	; 0x518
    184a:	f8c9 8180 	str.w	r8, [r9, #384]	; 0x180
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    184e:	f8c5 8008 	str.w	r8, [r5, #8]
}
    1852:	e7d6      	b.n	1802 <z_nrf_clock_control_lf_on+0x76>
    p_reg->INTENSET = mask;
    1854:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1858:	2202      	movs	r2, #2
    185a:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
}
    185e:	e7e1      	b.n	1824 <z_nrf_clock_control_lf_on+0x98>
    p_reg->INTENCLR = mask;
    1860:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    1864:	2202      	movs	r2, #2
    1866:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
	int key = isr_mode ? irq_lock() : 0;
    186a:	4606      	mov	r6, r0
}
    186c:	e7c3      	b.n	17f6 <z_nrf_clock_control_lf_on+0x6a>
    186e:	bf00      	nop
    1870:	20001580 	.word	0x20001580
    1874:	2000151c 	.word	0x2000151c
    1878:	20001548 	.word	0x20001548
    187c:	2000176d 	.word	0x2000176d
    1880:	e000e100 	.word	0xe000e100

00001884 <qspi_get_zephyr_ret_code>:
/**
 * @brief Converts NRFX return codes to the zephyr ones
 */
static inline int qspi_get_zephyr_ret_code(nrfx_err_t res)
{
	switch (res) {
    1884:	f100 4074 	add.w	r0, r0, #4093640704	; 0xf4000000
    1888:	f500 00a6 	add.w	r0, r0, #5439488	; 0x530000
    188c:	280a      	cmp	r0, #10
    188e:	bf9a      	itte	ls
    1890:	4b02      	ldrls	r3, [pc, #8]	; (189c <qspi_get_zephyr_ret_code+0x18>)
    1892:	f933 0010 	ldrshls.w	r0, [r3, r0, lsl #1]
{
    1896:	f06f 000f 	mvnhi.w	r0, #15
	case NRFX_ERROR_BUSY:
	case NRFX_ERROR_TIMEOUT:
	default:
		return -EBUSY;
	}
}
    189a:	4770      	bx	lr
    189c:	000061c8 	.word	0x000061c8

000018a0 <qspi_nor_pages_layout>:

static void qspi_nor_pages_layout(const struct device *dev,
				  const struct flash_pages_layout **layout,
				  size_t *layout_size)
{
	*layout = &dev_layout;
    18a0:	4b02      	ldr	r3, [pc, #8]	; (18ac <qspi_nor_pages_layout+0xc>)
    18a2:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
    18a4:	2301      	movs	r3, #1
    18a6:	6013      	str	r3, [r2, #0]
}
    18a8:	4770      	bx	lr
    18aa:	bf00      	nop
    18ac:	00005fdc 	.word	0x00005fdc

000018b0 <qspi_flash_get_parameters>:
		.write_block_size = 4,
		.erase_value = 0xff,
	};

	return &qspi_flash_parameters;
}
    18b0:	4800      	ldr	r0, [pc, #0]	; (18b4 <qspi_flash_get_parameters+0x4>)
    18b2:	4770      	bx	lr
    18b4:	00005fe4 	.word	0x00005fe4

000018b8 <qspi_device_init>:
{
    18b8:	b510      	push	{r4, lr}
	if (!qspi_initialized) {
    18ba:	4c08      	ldr	r4, [pc, #32]	; (18dc <qspi_device_init+0x24>)
    18bc:	7823      	ldrb	r3, [r4, #0]
    18be:	b95b      	cbnz	r3, 18d8 <qspi_device_init+0x20>
		res = nrfx_qspi_init(&dev_config->nrfx_cfg,
    18c0:	6902      	ldr	r2, [r0, #16]
    18c2:	4907      	ldr	r1, [pc, #28]	; (18e0 <qspi_device_init+0x28>)
    18c4:	6840      	ldr	r0, [r0, #4]
    18c6:	f001 f929 	bl	2b1c <nrfx_qspi_init>
		ret = qspi_get_zephyr_ret_code(res);
    18ca:	f7ff ffdb 	bl	1884 <qspi_get_zephyr_ret_code>
		qspi_initialized = (ret == 0);
    18ce:	fab0 f380 	clz	r3, r0
    18d2:	095b      	lsrs	r3, r3, #5
    18d4:	7023      	strb	r3, [r4, #0]
}
    18d6:	bd10      	pop	{r4, pc}
	int ret = 0;
    18d8:	2000      	movs	r0, #0
	return ret;
    18da:	e7fc      	b.n	18d6 <qspi_device_init+0x1e>
    18dc:	2000176a 	.word	0x2000176a
    18e0:	000055a5 	.word	0x000055a5

000018e4 <qspi_device_uninit.constprop.0>:
static void qspi_device_uninit(const struct device *dev)
    18e4:	b510      	push	{r4, lr}
		while (nrfx_qspi_mem_busy_check() != NRFX_SUCCESS) {
    18e6:	4c08      	ldr	r4, [pc, #32]	; (1908 <qspi_device_uninit.constprop.0+0x24>)
    18e8:	f001 fa40 	bl	2d6c <nrfx_qspi_mem_busy_check>
    18ec:	42a0      	cmp	r0, r4
    18ee:	d105      	bne.n	18fc <qspi_device_uninit.constprop.0+0x18>
		nrfx_qspi_uninit();
    18f0:	f001 fa60 	bl	2db4 <nrfx_qspi_uninit>
		qspi_initialized = false;
    18f4:	4b05      	ldr	r3, [pc, #20]	; (190c <qspi_device_uninit.constprop.0+0x28>)
    18f6:	2200      	movs	r2, #0
    18f8:	701a      	strb	r2, [r3, #0]
}
    18fa:	bd10      	pop	{r4, pc}
		(void) arch_syscall_invoke1(parm0.x, K_SYSCALL_K_BUSY_WAIT);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_busy_wait(usec_to_wait);
    18fc:	f24c 3050 	movw	r0, #50000	; 0xc350
    1900:	f004 f974 	bl	5bec <z_impl_k_busy_wait>
}
    1904:	e7f0      	b.n	18e8 <qspi_device_uninit.constprop.0+0x4>
    1906:	bf00      	nop
    1908:	0bad0000 	.word	0x0bad0000
    190c:	2000176a 	.word	0x2000176a

00001910 <qspi_wait_for_completion.isra.0>:
	if (res == NRFX_SUCCESS) {
    1910:	4b0c      	ldr	r3, [pc, #48]	; (1944 <qspi_wait_for_completion.isra.0+0x34>)
    1912:	4299      	cmp	r1, r3
static inline void qspi_wait_for_completion(const struct device *dev,
    1914:	b510      	push	{r4, lr}
    1916:	4604      	mov	r4, r0
	if (res == NRFX_SUCCESS) {
    1918:	d110      	bne.n	193c <qspi_wait_for_completion.isra.0+0x2c>
	__asm__ volatile(
    191a:	f04f 0220 	mov.w	r2, #32
    191e:	f3ef 8311 	mrs	r3, BASEPRI
    1922:	f382 8812 	msr	BASEPRI_MAX, r2
    1926:	f3bf 8f6f 	isb	sy
    192a:	4618      	mov	r0, r3
		while (!dev_data->ready) {
    192c:	7823      	ldrb	r3, [r4, #0]
    192e:	b133      	cbz	r3, 193e <qspi_wait_for_completion.isra.0+0x2e>
		dev_data->ready = false;
    1930:	2300      	movs	r3, #0
    1932:	7023      	strb	r3, [r4, #0]
	__asm__ volatile(
    1934:	f380 8811 	msr	BASEPRI, r0
    1938:	f3bf 8f6f 	isb	sy
}
    193c:	bd10      	pop	{r4, pc}
    193e:	f7ff fb23 	bl	f88 <arch_cpu_atomic_idle>
    1942:	e7ea      	b.n	191a <qspi_wait_for_completion.isra.0+0xa>
    1944:	0bad0000 	.word	0x0bad0000

00001948 <qspi_nor_read>:
{
    1948:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    194c:	4680      	mov	r8, r0
    194e:	b085      	sub	sp, #20
    1950:	460f      	mov	r7, r1
    1952:	461c      	mov	r4, r3
	if (!dest) {
    1954:	4616      	mov	r6, r2
    1956:	2a00      	cmp	r2, #0
    1958:	f000 8092 	beq.w	1a80 <qspi_nor_read+0x138>
	if (!size) {
    195c:	2b00      	cmp	r3, #0
    195e:	f000 808d 	beq.w	1a7c <qspi_nor_read+0x134>
	if (addr < 0 ||
    1962:	2900      	cmp	r1, #0
	const struct qspi_nor_config *params = dev->config;
    1964:	6842      	ldr	r2, [r0, #4]
	if (addr < 0 ||
    1966:	f2c0 808b 	blt.w	1a80 <qspi_nor_read+0x138>
    196a:	6992      	ldr	r2, [r2, #24]
	    (addr + size) > params->size) {
    196c:	18cb      	adds	r3, r1, r3
	if (addr < 0 ||
    196e:	4293      	cmp	r3, r2
    1970:	f200 8086 	bhi.w	1a80 <qspi_nor_read+0x138>
	int rc = qspi_device_init(dev);
    1974:	f7ff ffa0 	bl	18b8 <qspi_device_init>
	if (rc != 0) {
    1978:	4605      	mov	r5, r0
    197a:	2800      	cmp	r0, #0
    197c:	d176      	bne.n	1a6c <qspi_nor_read+0x124>
	if (flash_prefix > size) {
    197e:	427d      	negs	r5, r7
    1980:	f005 0503 	and.w	r5, r5, #3
    1984:	42a5      	cmp	r5, r4
    1986:	bf28      	it	cs
    1988:	4625      	movcs	r5, r4
	off_t dest_prefix = (WORD_SIZE - (off_t)dptr % WORD_SIZE) % WORD_SIZE;
    198a:	4273      	negs	r3, r6
    198c:	f003 0303 	and.w	r3, r3, #3
    1990:	f006 0b03 	and.w	fp, r6, #3
    1994:	bf58      	it	pl
    1996:	f1c3 0b00 	rsbpl	fp, r3, #0
    199a:	f1cb 0b00 	rsb	fp, fp, #0
    199e:	f00b 0b03 	and.w	fp, fp, #3
    19a2:	45a3      	cmp	fp, r4
    19a4:	bf28      	it	cs
    19a6:	46a3      	movcs	fp, r4
	off_t flash_suffix = (size - flash_prefix) % WORD_SIZE;
    19a8:	1b63      	subs	r3, r4, r5
			    (size - dest_prefix) % WORD_SIZE;
    19aa:	eba4 040b 	sub.w	r4, r4, fp
	off_t dest_middle = size - dest_prefix -
    19ae:	f024 0403 	bic.w	r4, r4, #3
	off_t flash_middle = size - flash_prefix - flash_suffix;
    19b2:	f023 0903 	bic.w	r9, r3, #3
	if (flash_middle > dest_middle) {
    19b6:	45a1      	cmp	r9, r4
		flash_suffix = size - flash_prefix - flash_middle;
    19b8:	bfc8      	it	gt
    19ba:	46a1      	movgt	r9, r4
	off_t flash_suffix = (size - flash_prefix) % WORD_SIZE;
    19bc:	f003 0a03 	and.w	sl, r3, #3
		flash_suffix = size - flash_prefix - flash_middle;
    19c0:	bfc8      	it	gt
    19c2:	eba3 0a04 	subgt.w	sl, r3, r4
	if (flash_middle != 0) {
    19c6:	f1b9 0f00 	cmp.w	r9, #0
    19ca:	d018      	beq.n	19fe <qspi_nor_read+0xb6>
		res = nrfx_qspi_read(dptr + dest_prefix, flash_middle,
    19cc:	eb06 030b 	add.w	r3, r6, fp
    19d0:	197a      	adds	r2, r7, r5
    19d2:	4649      	mov	r1, r9
    19d4:	4618      	mov	r0, r3
    19d6:	9301      	str	r3, [sp, #4]
    19d8:	f004 f8d0 	bl	5b7c <nrfx_qspi_read>
    19dc:	4604      	mov	r4, r0
		qspi_wait_for_completion(dev, res);
    19de:	4601      	mov	r1, r0
    19e0:	f8d8 0010 	ldr.w	r0, [r8, #16]
    19e4:	f7ff ff94 	bl	1910 <qspi_wait_for_completion.isra.0>
		if (res != NRFX_SUCCESS) {
    19e8:	4a27      	ldr	r2, [pc, #156]	; (1a88 <qspi_nor_read+0x140>)
    19ea:	4294      	cmp	r4, r2
    19ec:	d13a      	bne.n	1a64 <qspi_nor_read+0x11c>
		if (flash_prefix != dest_prefix) {
    19ee:	455d      	cmp	r5, fp
    19f0:	d005      	beq.n	19fe <qspi_nor_read+0xb6>
			memmove(dptr + flash_prefix, dptr + dest_prefix, flash_middle);
    19f2:	9b01      	ldr	r3, [sp, #4]
    19f4:	464a      	mov	r2, r9
    19f6:	4619      	mov	r1, r3
    19f8:	1970      	adds	r0, r6, r5
    19fa:	f003 fd15 	bl	5428 <memmove>
	if (flash_prefix != 0) {
    19fe:	b1bd      	cbz	r5, 1a30 <qspi_nor_read+0xe8>
				     (WORD_SIZE - flash_prefix));
    1a00:	f1c5 0b04 	rsb	fp, r5, #4
		res = nrfx_qspi_read(buf, WORD_SIZE, addr -
    1a04:	eba7 020b 	sub.w	r2, r7, fp
    1a08:	2104      	movs	r1, #4
    1a0a:	a802      	add	r0, sp, #8
    1a0c:	f004 f8b6 	bl	5b7c <nrfx_qspi_read>
    1a10:	4604      	mov	r4, r0
		qspi_wait_for_completion(dev, res);
    1a12:	4601      	mov	r1, r0
    1a14:	f8d8 0010 	ldr.w	r0, [r8, #16]
    1a18:	f7ff ff7a 	bl	1910 <qspi_wait_for_completion.isra.0>
		if (res != NRFX_SUCCESS) {
    1a1c:	4b1a      	ldr	r3, [pc, #104]	; (1a88 <qspi_nor_read+0x140>)
    1a1e:	429c      	cmp	r4, r3
    1a20:	d120      	bne.n	1a64 <qspi_nor_read+0x11c>
		memcpy(dptr, buf + WORD_SIZE - flash_prefix, flash_prefix);
    1a22:	ab02      	add	r3, sp, #8
    1a24:	462a      	mov	r2, r5
    1a26:	eb03 010b 	add.w	r1, r3, fp
    1a2a:	4630      	mov	r0, r6
    1a2c:	f003 fd14 	bl	5458 <memcpy>
	if (flash_suffix != 0) {
    1a30:	f1ba 0f00 	cmp.w	sl, #0
    1a34:	d020      	beq.n	1a78 <qspi_nor_read+0x130>
		res = nrfx_qspi_read(buf, WORD_SIZE * 2,
    1a36:	2108      	movs	r1, #8
				     addr + flash_prefix + flash_middle);
    1a38:	197a      	adds	r2, r7, r5
		res = nrfx_qspi_read(buf, WORD_SIZE * 2,
    1a3a:	444a      	add	r2, r9
    1a3c:	eb0d 0001 	add.w	r0, sp, r1
    1a40:	f004 f89c 	bl	5b7c <nrfx_qspi_read>
    1a44:	4604      	mov	r4, r0
		qspi_wait_for_completion(dev, res);
    1a46:	4601      	mov	r1, r0
    1a48:	f8d8 0010 	ldr.w	r0, [r8, #16]
    1a4c:	f7ff ff60 	bl	1910 <qspi_wait_for_completion.isra.0>
		if (res != NRFX_SUCCESS) {
    1a50:	4b0d      	ldr	r3, [pc, #52]	; (1a88 <qspi_nor_read+0x140>)
    1a52:	429c      	cmp	r4, r3
    1a54:	d106      	bne.n	1a64 <qspi_nor_read+0x11c>
		memcpy(dptr + flash_prefix + flash_middle, buf, flash_suffix);
    1a56:	eb09 0005 	add.w	r0, r9, r5
    1a5a:	4652      	mov	r2, sl
    1a5c:	a902      	add	r1, sp, #8
    1a5e:	4430      	add	r0, r6
    1a60:	f003 fcfa 	bl	5458 <memcpy>
	rc = qspi_get_zephyr_ret_code(res);
    1a64:	4620      	mov	r0, r4
    1a66:	f7ff ff0d 	bl	1884 <qspi_get_zephyr_ret_code>
    1a6a:	4605      	mov	r5, r0
	qspi_device_uninit(dev);
    1a6c:	f7ff ff3a 	bl	18e4 <qspi_device_uninit.constprop.0>
}
    1a70:	4628      	mov	r0, r5
    1a72:	b005      	add	sp, #20
    1a74:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	return res;
    1a78:	4c03      	ldr	r4, [pc, #12]	; (1a88 <qspi_nor_read+0x140>)
    1a7a:	e7f3      	b.n	1a64 <qspi_nor_read+0x11c>
		return 0;
    1a7c:	461d      	mov	r5, r3
    1a7e:	e7f7      	b.n	1a70 <qspi_nor_read+0x128>
		return -EINVAL;
    1a80:	f06f 0515 	mvn.w	r5, #21
    1a84:	e7f4      	b.n	1a70 <qspi_nor_read+0x128>
    1a86:	bf00      	nop
    1a88:	0bad0000 	.word	0x0bad0000

00001a8c <qspi_nor_write>:
{
    1a8c:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    1a90:	4605      	mov	r5, r0
    1a92:	460f      	mov	r7, r1
    1a94:	461e      	mov	r6, r3
	if (!src) {
    1a96:	4690      	mov	r8, r2
    1a98:	2a00      	cmp	r2, #0
    1a9a:	d06d      	beq.n	1b78 <qspi_nor_write+0xec>
	if ((size == 0)
    1a9c:	2b00      	cmp	r3, #0
    1a9e:	d06b      	beq.n	1b78 <qspi_nor_write+0xec>
	    || ((size > 4) && ((size % 4U) != 0))) {
    1aa0:	2b04      	cmp	r3, #4
    1aa2:	d901      	bls.n	1aa8 <qspi_nor_write+0x1c>
    1aa4:	079a      	lsls	r2, r3, #30
    1aa6:	d167      	bne.n	1b78 <qspi_nor_write+0xec>
	if ((addr % 4U) != 0) {
    1aa8:	07bb      	lsls	r3, r7, #30
    1aaa:	d165      	bne.n	1b78 <qspi_nor_write+0xec>
	if (addr < 0 ||
    1aac:	2f00      	cmp	r7, #0
	const struct qspi_nor_config *params = dev->config;
    1aae:	686a      	ldr	r2, [r5, #4]
	if (addr < 0 ||
    1ab0:	db62      	blt.n	1b78 <qspi_nor_write+0xec>
    1ab2:	6992      	ldr	r2, [r2, #24]
	    (addr + size) > params->size) {
    1ab4:	19bb      	adds	r3, r7, r6
	if (addr < 0 ||
    1ab6:	4293      	cmp	r3, r2
    1ab8:	d85e      	bhi.n	1b78 <qspi_nor_write+0xec>
	int rc = qspi_device_init(dev);
    1aba:	4628      	mov	r0, r5
    1abc:	f7ff fefc 	bl	18b8 <qspi_device_init>
	if (rc != 0) {
    1ac0:	4604      	mov	r4, r0
    1ac2:	2800      	cmp	r0, #0
    1ac4:	d14e      	bne.n	1b64 <qspi_nor_write+0xd8>
	res = qspi_nor_write_protection_set(dev, false);
    1ac6:	f003 fdbe 	bl	5646 <qspi_nor_write_protection_set.isra.0>
	if (!res) {
    1aca:	4604      	mov	r4, r0
    1acc:	2800      	cmp	r0, #0
    1ace:	d140      	bne.n	1b52 <qspi_nor_write+0xc6>
		if (size < 4U) {
    1ad0:	2e03      	cmp	r6, #3
    1ad2:	d81c      	bhi.n	1b0e <qspi_nor_write+0x82>
	res = nrfx_qspi_read(buf, sizeof(buf), addr);
    1ad4:	463a      	mov	r2, r7
    1ad6:	2104      	movs	r1, #4
    1ad8:	4668      	mov	r0, sp
    1ada:	f004 f84f 	bl	5b7c <nrfx_qspi_read>
    1ade:	4604      	mov	r4, r0
	qspi_wait_for_completion(dev, res);
    1ae0:	4601      	mov	r1, r0
    1ae2:	6928      	ldr	r0, [r5, #16]
    1ae4:	f7ff ff14 	bl	1910 <qspi_wait_for_completion.isra.0>
	if (res == NRFX_SUCCESS) {
    1ae8:	4b25      	ldr	r3, [pc, #148]	; (1b80 <qspi_nor_write+0xf4>)
    1aea:	429c      	cmp	r4, r3
    1aec:	d131      	bne.n	1b52 <qspi_nor_write+0xc6>
		memcpy(buf, sptr, slen);
    1aee:	4632      	mov	r2, r6
    1af0:	4641      	mov	r1, r8
    1af2:	4668      	mov	r0, sp
    1af4:	f003 fcb0 	bl	5458 <memcpy>
		res = nrfx_qspi_write(buf, sizeof(buf), addr);
    1af8:	463a      	mov	r2, r7
    1afa:	2104      	movs	r1, #4
    1afc:	4668      	mov	r0, sp
			res = nrfx_qspi_write(src, size, addr);
    1afe:	f004 f83a 	bl	5b76 <nrfx_qspi_write>
    1b02:	4604      	mov	r4, r0
			qspi_wait_for_completion(dev, res);
    1b04:	4601      	mov	r1, r0
    1b06:	6928      	ldr	r0, [r5, #16]
    1b08:	f7ff ff02 	bl	1910 <qspi_wait_for_completion.isra.0>
    1b0c:	e021      	b.n	1b52 <qspi_nor_write+0xc6>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrfx_is_in_ram(void const * p_object)
{
    return ((((uint32_t)p_object) & 0xE0000000u) == 0x20000000u);
    1b0e:	f008 4360 	and.w	r3, r8, #3758096384	; 0xe0000000
		} else if (!nrfx_is_in_ram(src)) {
    1b12:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
    1b16:	d02b      	beq.n	1b70 <qspi_nor_write+0xe4>
			if (res == NRFX_SUCCESS) {
    1b18:	f8df a064 	ldr.w	sl, [pc, #100]	; 1b80 <qspi_nor_write+0xf4>
			size_t len = MIN(slen, sizeof(buf));
    1b1c:	2e10      	cmp	r6, #16
    1b1e:	46b1      	mov	r9, r6
    1b20:	bf28      	it	cs
    1b22:	f04f 0910 	movcs.w	r9, #16
			memcpy(buf, sp, len);
    1b26:	464a      	mov	r2, r9
    1b28:	4641      	mov	r1, r8
    1b2a:	4668      	mov	r0, sp
    1b2c:	f003 fc94 	bl	5458 <memcpy>
			res = nrfx_qspi_write(buf, sizeof(buf), addr);
    1b30:	463a      	mov	r2, r7
    1b32:	2110      	movs	r1, #16
    1b34:	4668      	mov	r0, sp
    1b36:	f004 f81e 	bl	5b76 <nrfx_qspi_write>
    1b3a:	4604      	mov	r4, r0
			qspi_wait_for_completion(dev, res);
    1b3c:	4601      	mov	r1, r0
    1b3e:	6928      	ldr	r0, [r5, #16]
    1b40:	f7ff fee6 	bl	1910 <qspi_wait_for_completion.isra.0>
			if (res == NRFX_SUCCESS) {
    1b44:	4554      	cmp	r4, sl
    1b46:	d104      	bne.n	1b52 <qspi_nor_write+0xc6>
		while ((slen > 0) && (res == NRFX_SUCCESS)) {
    1b48:	ebb6 0609 	subs.w	r6, r6, r9
				sp += len;
    1b4c:	44c8      	add	r8, r9
				addr += len;
    1b4e:	444f      	add	r7, r9
		while ((slen > 0) && (res == NRFX_SUCCESS)) {
    1b50:	d1e4      	bne.n	1b1c <qspi_nor_write+0x90>
	int res2 = qspi_nor_write_protection_set(dev, true);
    1b52:	2001      	movs	r0, #1
    1b54:	f003 fd77 	bl	5646 <qspi_nor_write_protection_set.isra.0>
	rc = qspi_get_zephyr_ret_code(res);
    1b58:	2c00      	cmp	r4, #0
    1b5a:	bf18      	it	ne
    1b5c:	4620      	movne	r0, r4
    1b5e:	f7ff fe91 	bl	1884 <qspi_get_zephyr_ret_code>
    1b62:	4604      	mov	r4, r0
	qspi_device_uninit(dev);
    1b64:	f7ff febe 	bl	18e4 <qspi_device_uninit.constprop.0>
}
    1b68:	4620      	mov	r0, r4
    1b6a:	b004      	add	sp, #16
    1b6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			res = nrfx_qspi_write(src, size, addr);
    1b70:	463a      	mov	r2, r7
    1b72:	4631      	mov	r1, r6
    1b74:	4640      	mov	r0, r8
    1b76:	e7c2      	b.n	1afe <qspi_nor_write+0x72>
		return -EINVAL;
    1b78:	f06f 0415 	mvn.w	r4, #21
    1b7c:	e7f4      	b.n	1b68 <qspi_nor_write+0xdc>
    1b7e:	bf00      	nop
    1b80:	0bad0000 	.word	0x0bad0000

00001b84 <qspi_nor_erase>:
{
    1b84:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (addr < 0 ||
    1b88:	1e0e      	subs	r6, r1, #0
	const struct qspi_nor_config *params = dev->config;
    1b8a:	f8d0 9004 	ldr.w	r9, [r0, #4]
{
    1b8e:	4680      	mov	r8, r0
    1b90:	4617      	mov	r7, r2
	if (addr < 0 ||
    1b92:	db58      	blt.n	1c46 <qspi_nor_erase+0xc2>
    1b94:	f8d9 3018 	ldr.w	r3, [r9, #24]
	    (addr + size) > params->size) {
    1b98:	18b2      	adds	r2, r6, r2
	if (addr < 0 ||
    1b9a:	429a      	cmp	r2, r3
    1b9c:	d853      	bhi.n	1c46 <qspi_nor_erase+0xc2>
	if ((size == 0) || (size % QSPI_SECTOR_SIZE) != 0) {
    1b9e:	2f00      	cmp	r7, #0
    1ba0:	d051      	beq.n	1c46 <qspi_nor_erase+0xc2>
    1ba2:	ea46 0307 	orr.w	r3, r6, r7
    1ba6:	f3c3 030b 	ubfx	r3, r3, #0, #12
    1baa:	2b00      	cmp	r3, #0
    1bac:	d14b      	bne.n	1c46 <qspi_nor_erase+0xc2>
	rv = qspi_device_init(dev);
    1bae:	f7ff fe83 	bl	18b8 <qspi_device_init>
	if (rv != 0) {
    1bb2:	4604      	mov	r4, r0
    1bb4:	b9f8      	cbnz	r0, 1bf6 <qspi_nor_erase+0x72>
	rv = qspi_nor_write_protection_set(dev, false);
    1bb6:	f003 fd46 	bl	5646 <qspi_nor_write_protection_set.isra.0>
	if (rv != 0) {
    1bba:	4604      	mov	r4, r0
    1bbc:	b9d8      	cbnz	r0, 1bf6 <qspi_nor_erase+0x72>
			res = NRFX_ERROR_INVALID_PARAM;
    1bbe:	f8df a090 	ldr.w	sl, [pc, #144]	; 1c50 <qspi_nor_erase+0xcc>
		if (size == params->size) {
    1bc2:	f8d9 3018 	ldr.w	r3, [r9, #24]
    1bc6:	42bb      	cmp	r3, r7
    1bc8:	d11a      	bne.n	1c00 <qspi_nor_erase+0x7c>
			res = nrfx_qspi_chip_erase();
    1bca:	f003 ffda 	bl	5b82 <nrfx_qspi_chip_erase>
    1bce:	46bb      	mov	fp, r7
    1bd0:	4605      	mov	r5, r0
		qspi_wait_for_completion(dev, res);
    1bd2:	f8d8 0010 	ldr.w	r0, [r8, #16]
    1bd6:	4629      	mov	r1, r5
    1bd8:	f7ff fe9a 	bl	1910 <qspi_wait_for_completion.isra.0>
		if (res == NRFX_SUCCESS) {
    1bdc:	4b1b      	ldr	r3, [pc, #108]	; (1c4c <qspi_nor_erase+0xc8>)
    1bde:	429d      	cmp	r5, r3
    1be0:	d12c      	bne.n	1c3c <qspi_nor_erase+0xb8>
	while (size > 0) {
    1be2:	ebb7 070b 	subs.w	r7, r7, fp
			addr += adj;
    1be6:	445e      	add	r6, fp
	while (size > 0) {
    1be8:	d1eb      	bne.n	1bc2 <qspi_nor_erase+0x3e>
	int rv2 = qspi_nor_write_protection_set(dev, true);
    1bea:	2001      	movs	r0, #1
    1bec:	f003 fd2b 	bl	5646 <qspi_nor_write_protection_set.isra.0>
		rv = rv2;
    1bf0:	2c00      	cmp	r4, #0
    1bf2:	bf08      	it	eq
    1bf4:	4604      	moveq	r4, r0
	qspi_device_uninit(dev);
    1bf6:	f7ff fe75 	bl	18e4 <qspi_device_uninit.constprop.0>
}
    1bfa:	4620      	mov	r0, r4
    1bfc:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if ((size >= QSPI_BLOCK_SIZE) &&
    1c00:	f5b7 3f80 	cmp.w	r7, #65536	; 0x10000
    1c04:	d309      	bcc.n	1c1a <qspi_nor_erase+0x96>
			   QSPI_IS_BLOCK_ALIGNED(addr)) {
    1c06:	b2b3      	uxth	r3, r6
		} else if ((size >= QSPI_BLOCK_SIZE) &&
    1c08:	b93b      	cbnz	r3, 1c1a <qspi_nor_erase+0x96>
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_64KB, addr);
    1c0a:	4631      	mov	r1, r6
    1c0c:	2001      	movs	r0, #1
    1c0e:	f001 f925 	bl	2e5c <nrfx_qspi_erase>
			adj = QSPI_BLOCK_SIZE;
    1c12:	f44f 3b80 	mov.w	fp, #65536	; 0x10000
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_64KB, addr);
    1c16:	4605      	mov	r5, r0
			adj = QSPI_BLOCK_SIZE;
    1c18:	e7db      	b.n	1bd2 <qspi_nor_erase+0x4e>
		} else if ((size >= QSPI_SECTOR_SIZE) &&
    1c1a:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
    1c1e:	d309      	bcc.n	1c34 <qspi_nor_erase+0xb0>
			   QSPI_IS_SECTOR_ALIGNED(addr)) {
    1c20:	f3c6 000b 	ubfx	r0, r6, #0, #12
		} else if ((size >= QSPI_SECTOR_SIZE) &&
    1c24:	b930      	cbnz	r0, 1c34 <qspi_nor_erase+0xb0>
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_4KB, addr);
    1c26:	4631      	mov	r1, r6
    1c28:	f001 f918 	bl	2e5c <nrfx_qspi_erase>
			adj = QSPI_SECTOR_SIZE;
    1c2c:	f44f 5b80 	mov.w	fp, #4096	; 0x1000
			res = nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_4KB, addr);
    1c30:	4605      	mov	r5, r0
			adj = QSPI_SECTOR_SIZE;
    1c32:	e7ce      	b.n	1bd2 <qspi_nor_erase+0x4e>
		uint32_t adj = 0;
    1c34:	f04f 0b00 	mov.w	fp, #0
			res = NRFX_ERROR_INVALID_PARAM;
    1c38:	4655      	mov	r5, sl
    1c3a:	e7ca      	b.n	1bd2 <qspi_nor_erase+0x4e>
			rv = qspi_get_zephyr_ret_code(res);
    1c3c:	4628      	mov	r0, r5
    1c3e:	f7ff fe21 	bl	1884 <qspi_get_zephyr_ret_code>
    1c42:	4604      	mov	r4, r0
			break;
    1c44:	e7d1      	b.n	1bea <qspi_nor_erase+0x66>
		return -EINVAL;
    1c46:	f06f 0415 	mvn.w	r4, #21
    1c4a:	e7d6      	b.n	1bfa <qspi_nor_erase+0x76>
    1c4c:	0bad0000 	.word	0x0bad0000
    1c50:	0bad0004 	.word	0x0bad0004

00001c54 <qspi_nor_init>:
{
    1c54:	b530      	push	{r4, r5, lr}
	int ret = pinctrl_apply_state(dev_config->pcfg, PINCTRL_STATE_DEFAULT);
    1c56:	6843      	ldr	r3, [r0, #4]
    1c58:	6a1d      	ldr	r5, [r3, #32]
{
    1c5a:	b087      	sub	sp, #28
    1c5c:	4604      	mov	r4, r0
				      uint8_t id)
{
	int ret;
	const struct pinctrl_state *state;

	ret = pinctrl_lookup_state(config, id, &state);
    1c5e:	aa03      	add	r2, sp, #12
    1c60:	2100      	movs	r1, #0
    1c62:	4628      	mov	r0, r5
    1c64:	f003 fd5a 	bl	571c <pinctrl_lookup_state>
	if (ret < 0) {
    1c68:	2800      	cmp	r0, #0
    1c6a:	db4d      	blt.n	1d08 <qspi_nor_init+0xb4>
		return ret;
	}

	return pinctrl_apply_state_direct(config, state);
    1c6c:	9b03      	ldr	r3, [sp, #12]
	return pinctrl_configure_pins(state->pins, state->pin_cnt, reg);
    1c6e:	682a      	ldr	r2, [r5, #0]
    1c70:	7919      	ldrb	r1, [r3, #4]
    1c72:	6818      	ldr	r0, [r3, #0]
    1c74:	f003 fd6f 	bl	5756 <pinctrl_configure_pins>
	if (ret < 0) {
    1c78:	2800      	cmp	r0, #0
    1c7a:	db45      	blt.n	1d08 <qspi_nor_init+0xb4>
	IRQ_CONNECT(DT_IRQN(QSPI_NODE), DT_IRQ(QSPI_NODE, priority),
    1c7c:	2200      	movs	r2, #0
    1c7e:	2101      	movs	r1, #1
    1c80:	2029      	movs	r0, #41	; 0x29
    1c82:	f7ff f9bd 	bl	1000 <z_arm_irq_priority_set>
	const struct qspi_nor_config *dev_config = dev->config;
    1c86:	6865      	ldr	r5, [r4, #4]
	nrfx_err_t res = nrfx_qspi_init(&dev_config->nrfx_cfg,
    1c88:	6922      	ldr	r2, [r4, #16]
    1c8a:	492f      	ldr	r1, [pc, #188]	; (1d48 <qspi_nor_init+0xf4>)
    1c8c:	4628      	mov	r0, r5
    1c8e:	f000 ff45 	bl	2b1c <nrfx_qspi_init>
	int ret = qspi_get_zephyr_ret_code(res);
    1c92:	f7ff fdf7 	bl	1884 <qspi_get_zephyr_ret_code>
	if (ret < 0) {
    1c96:	2800      	cmp	r0, #0
    1c98:	db36      	blt.n	1d08 <qspi_nor_init+0xb4>
		bool qe_value = (prot_if->writeoc == NRF_QSPI_WRITEOC_PP4IO) ||
    1c9a:	7aeb      	ldrb	r3, [r5, #11]
				(prot_if->readoc == NRF_QSPI_READOC_READ4IO) ||
    1c9c:	3b02      	subs	r3, #2
    1c9e:	2b01      	cmp	r3, #1
    1ca0:	d934      	bls.n	1d0c <qspi_nor_init+0xb8>
    1ca2:	7aad      	ldrb	r5, [r5, #10]
    1ca4:	3d03      	subs	r5, #3
    1ca6:	2d01      	cmp	r5, #1
    1ca8:	bf8c      	ite	hi
    1caa:	2500      	movhi	r5, #0
    1cac:	2501      	movls	r5, #1
		ret = qspi_rdsr(dev, sr_num);
    1cae:	f003 fcaf 	bl	5610 <qspi_rdsr.constprop.0.isra.0>
		if (ret < 0) {
    1cb2:	2800      	cmp	r0, #0
    1cb4:	db28      	blt.n	1d08 <qspi_nor_init+0xb4>
		uint8_t sr = (uint8_t)ret;
    1cb6:	b2c2      	uxtb	r2, r0
		if (qe_state != qe_value) {
    1cb8:	f3c0 1080 	ubfx	r0, r0, #6, #1
    1cbc:	4285      	cmp	r5, r0
    1cbe:	ad01      	add	r5, sp, #4
    1cc0:	d126      	bne.n	1d10 <qspi_nor_init+0xbc>
	qspi_device_uninit(dev);
    1cc2:	f7ff fe0f 	bl	18e4 <qspi_device_uninit.constprop.0>
	const struct qspi_cmd cmd = {
    1cc6:	2300      	movs	r3, #0
    1cc8:	2203      	movs	r2, #3
    1cca:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1cce:	9304      	str	r3, [sp, #16]
	int ret = qspi_device_init(dev);
    1cd0:	4620      	mov	r0, r4
	const struct qspi_cmd cmd = {
    1cd2:	239f      	movs	r3, #159	; 0x9f
    1cd4:	9505      	str	r5, [sp, #20]
	const struct qspi_buf rx_buf = {
    1cd6:	f8cd d004 	str.w	sp, [sp, #4]
	const struct qspi_cmd cmd = {
    1cda:	f88d 300c 	strb.w	r3, [sp, #12]
	int ret = qspi_device_init(dev);
    1cde:	f7ff fdeb 	bl	18b8 <qspi_device_init>
	if (ret == 0) {
    1ce2:	4605      	mov	r5, r0
    1ce4:	b920      	cbnz	r0, 1cf0 <qspi_nor_init+0x9c>
		ret = qspi_send_cmd(dev, &cmd, false);
    1ce6:	4601      	mov	r1, r0
    1ce8:	a803      	add	r0, sp, #12
    1cea:	f003 fc5f 	bl	55ac <qspi_send_cmd.constprop.0>
    1cee:	4605      	mov	r5, r0
	qspi_device_uninit(dev);
    1cf0:	f7ff fdf8 	bl	18e4 <qspi_device_uninit.constprop.0>
	if (ret != 0) {
    1cf4:	b935      	cbnz	r5, 1d04 <qspi_nor_init+0xb0>
	if (memcmp(qnc->id, id, SPI_NOR_MAX_ID_LEN) != 0) {
    1cf6:	6860      	ldr	r0, [r4, #4]
    1cf8:	2203      	movs	r2, #3
    1cfa:	4669      	mov	r1, sp
    1cfc:	301c      	adds	r0, #28
    1cfe:	f003 fb82 	bl	5406 <memcmp>
    1d02:	b108      	cbz	r0, 1d08 <qspi_nor_init+0xb4>
		return -ENODEV;
    1d04:	f06f 0012 	mvn.w	r0, #18
}
    1d08:	b007      	add	sp, #28
    1d0a:	bd30      	pop	{r4, r5, pc}
				(prot_if->readoc == NRF_QSPI_READOC_READ4IO) ||
    1d0c:	2501      	movs	r5, #1
    1d0e:	e7ce      	b.n	1cae <qspi_nor_init+0x5a>
	uint8_t sr_array[2] = {0};
    1d10:	2300      	movs	r3, #0
	const struct qspi_buf sr_buf = {
    1d12:	2101      	movs	r1, #1
			sr ^= qe_mask;
    1d14:	f082 0240 	eor.w	r2, r2, #64	; 0x40
	ret = qspi_send_cmd(dev, &cmd, true);
    1d18:	a803      	add	r0, sp, #12
	struct qspi_cmd cmd = {
    1d1a:	e9cd 1302 	strd	r1, r3, [sp, #8]
	uint8_t sr_array[2] = {0};
    1d1e:	f8ad 3000 	strh.w	r3, [sp]
	const struct qspi_buf sr_buf = {
    1d22:	f8cd d004 	str.w	sp, [sp, #4]
		sr_array[0] = sr_val;
    1d26:	f88d 2000 	strb.w	r2, [sp]
	struct qspi_cmd cmd = {
    1d2a:	9305      	str	r3, [sp, #20]
    1d2c:	f88d 100c 	strb.w	r1, [sp, #12]
    1d30:	9504      	str	r5, [sp, #16]
	ret = qspi_send_cmd(dev, &cmd, true);
    1d32:	f003 fc3b 	bl	55ac <qspi_send_cmd.constprop.0>
	if (ret == 0) {
    1d36:	2800      	cmp	r0, #0
    1d38:	d1e6      	bne.n	1d08 <qspi_nor_init+0xb4>
		ret = qspi_rdsr(dev, 1);
    1d3a:	f003 fc69 	bl	5610 <qspi_rdsr.constprop.0.isra.0>
		 && ((ret & SPI_NOR_WIP_BIT) != 0U));
    1d3e:	2800      	cmp	r0, #0
    1d40:	dbe2      	blt.n	1d08 <qspi_nor_init+0xb4>
    1d42:	07c3      	lsls	r3, r0, #31
    1d44:	d4f9      	bmi.n	1d3a <qspi_nor_init+0xe6>
    1d46:	e7bc      	b.n	1cc2 <qspi_nor_init+0x6e>
    1d48:	000055a5 	.word	0x000055a5

00001d4c <flash_nrf_pages_layout>:

static void flash_nrf_pages_layout(const struct device *dev,
				     const struct flash_pages_layout **layout,
				     size_t *layout_size)
{
	*layout = &dev_layout;
    1d4c:	4b02      	ldr	r3, [pc, #8]	; (1d58 <flash_nrf_pages_layout+0xc>)
    1d4e:	600b      	str	r3, [r1, #0]
	*layout_size = 1;
    1d50:	2301      	movs	r3, #1
    1d52:	6013      	str	r3, [r2, #0]
}
    1d54:	4770      	bx	lr
    1d56:	bf00      	nop
    1d58:	20001584 	.word	0x20001584

00001d5c <flash_nrf_get_parameters>:
flash_nrf_get_parameters(const struct device *dev)
{
	ARG_UNUSED(dev);

	return &flash_nrf_parameters;
}
    1d5c:	4800      	ldr	r0, [pc, #0]	; (1d60 <flash_nrf_get_parameters+0x4>)
    1d5e:	4770      	bx	lr
    1d60:	00006038 	.word	0x00006038

00001d64 <nrf_flash_init>:
	.page_layout = flash_nrf_pages_layout,
#endif
};

static int nrf_flash_init(const struct device *dev)
{
    1d64:	b510      	push	{r4, lr}
#ifndef CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE
	nrf_flash_sync_init();
#endif /* !CONFIG_SOC_FLASH_NRF_RADIO_SYNC_NONE */

#if defined(CONFIG_FLASH_PAGE_LAYOUT)
	dev_layout.pages_count = nrfx_nvmc_flash_page_count_get();
    1d66:	f003 fef4 	bl	5b52 <nrfx_nvmc_flash_page_count_get>
    1d6a:	4c03      	ldr	r4, [pc, #12]	; (1d78 <nrf_flash_init+0x14>)
    1d6c:	6020      	str	r0, [r4, #0]
	dev_layout.pages_size = nrfx_nvmc_flash_page_size_get();
    1d6e:	f003 feec 	bl	5b4a <nrfx_nvmc_flash_page_size_get>
    1d72:	6060      	str	r0, [r4, #4]
#endif

	return 0;
}
    1d74:	2000      	movs	r0, #0
    1d76:	bd10      	pop	{r4, pc}
    1d78:	20001584 	.word	0x20001584

00001d7c <restore_pofwarn.part.0>:
    uint32_t pofcon = p_reg->POFCON;
    1d7c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    1d80:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
    uint32_t pofcon = p_reg->POFCON;
    1d84:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
        (((uint32_t)thr) << POWER_POFCON_THRESHOLD_Pos) |
    1d88:	f001 011e 	and.w	r1, r1, #30
    pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
    1d8c:	f023 031f 	bic.w	r3, r3, #31
    1d90:	430b      	orrs	r3, r1
    pofcon |=
    1d92:	f043 0301 	orr.w	r3, r3, #1
    p_reg->POFCON = pofcon;
    1d96:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510

	if (pofcon_enabled) {
		pof_thr = nrf_power_pofcon_get(NRF_POWER, NULL);

		nrf_power_pofcon_set(NRF_POWER, true, pof_thr);
		pofcon_enabled = false;
    1d9a:	4b02      	ldr	r3, [pc, #8]	; (1da4 <restore_pofwarn.part.0+0x28>)
    1d9c:	2200      	movs	r2, #0
    1d9e:	701a      	strb	r2, [r3, #0]
	}
}
    1da0:	4770      	bx	lr
    1da2:	bf00      	nop
    1da4:	2000176c 	.word	0x2000176c

00001da8 <suspend_pofwarn>:
    #else
        #if defined (NRF52805_XXAA) || defined (DEVELOP_IN_NRF52805)\
         || defined (NRF52810_XXAA) || defined (DEVELOP_IN_NRF52810)\
         || defined (NRF52811_XXAA) || defined (DEVELOP_IN_NRF52811)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    1da8:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            uint32_t var2 = *(uint32_t *)0x10000134ul;
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    1dac:	f8d3 3130 	ldr.w	r3, [r3, #304]	; 0x130
    1db0:	2b08      	cmp	r3, #8
    1db2:	d122      	bne.n	1dfa <suspend_pofwarn+0x52>
    uint32_t pofcon = p_reg->POFCON;
    1db4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    1db8:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
	if (enabled) {
    1dbc:	f011 0001 	ands.w	r0, r1, #1
    1dc0:	d01c      	beq.n	1dfc <suspend_pofwarn+0x54>
    uint32_t pofcon = p_reg->POFCON;
    1dc2:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
        (((uint32_t)thr) << POWER_POFCON_THRESHOLD_Pos) |
    1dc6:	f001 011e 	and.w	r1, r1, #30
    pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
    1dca:	f020 001f 	bic.w	r0, r0, #31
    pofcon |=
    1dce:	4308      	orrs	r0, r1
    p_reg->POFCON = pofcon;
    1dd0:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    1dd4:	f8d2 0108 	ldr.w	r0, [r2, #264]	; 0x108
		if (nrf_power_event_check(NRF_POWER, NRF_POWER_EVENT_POFWARN)) {
    1dd8:	b158      	cbz	r0, 1df2 <suspend_pofwarn+0x4a>
    uint32_t pofcon = p_reg->POFCON;
    1dda:	f8d2 3510 	ldr.w	r3, [r2, #1296]	; 0x510
    pofcon &= ~(POWER_POFCON_THRESHOLD_Msk | POWER_POFCON_POF_Msk);
    1dde:	f023 031f 	bic.w	r3, r3, #31
    1de2:	430b      	orrs	r3, r1
    pofcon |=
    1de4:	f043 0301 	orr.w	r3, r3, #1
    p_reg->POFCON = pofcon;
    1de8:	f8c2 3510 	str.w	r3, [r2, #1296]	; 0x510
			return -ECANCELED;
    1dec:	f06f 008b 	mvn.w	r0, #139	; 0x8b
    1df0:	4770      	bx	lr
		pofcon_enabled = enabled;
    1df2:	4b03      	ldr	r3, [pc, #12]	; (1e00 <suspend_pofwarn+0x58>)
    1df4:	2201      	movs	r2, #1
    1df6:	701a      	strb	r2, [r3, #0]
    1df8:	4770      	bx	lr
		return 0;
    1dfa:	2000      	movs	r0, #0
}
    1dfc:	4770      	bx	lr
    1dfe:	bf00      	nop
    1e00:	2000176c 	.word	0x2000176c

00001e04 <flash_nrf_write>:
{
    1e04:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    1e08:	460e      	mov	r6, r1
	if (is_regular_addr_valid(addr, len)) {
    1e0a:	4630      	mov	r0, r6
    1e0c:	4619      	mov	r1, r3
{
    1e0e:	4617      	mov	r7, r2
    1e10:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
    1e12:	f003 fc2d 	bl	5670 <is_regular_addr_valid>
    1e16:	b330      	cbz	r0, 1e66 <flash_nrf_write+0x62>
	return (data & 0x3) ? false : true;
    1e18:	ea46 0504 	orr.w	r5, r6, r4
	if (!is_aligned_32(addr) || (len % sizeof(uint32_t))) {
    1e1c:	f015 0503 	ands.w	r5, r5, #3
    1e20:	d121      	bne.n	1e66 <flash_nrf_write+0x62>
	if (!len) {
    1e22:	b31c      	cbz	r4, 1e6c <flash_nrf_write+0x68>
	if (pofcon_enabled) {
    1e24:	f8df 904c 	ldr.w	r9, [pc, #76]	; 1e74 <flash_nrf_write+0x70>
	while (w_ctx->len >= sizeof(uint32_t)) {
    1e28:	192b      	adds	r3, r5, r4
    1e2a:	2b03      	cmp	r3, #3
    1e2c:	eba6 0805 	sub.w	r8, r6, r5
    1e30:	d807      	bhi.n	1e42 <flash_nrf_write+0x3e>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE bool nrf_nvmc_ready_check(NRF_NVMC_Type const * p_reg)
{
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    1e32:	4a0f      	ldr	r2, [pc, #60]	; (1e70 <flash_nrf_write+0x6c>)
    1e34:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
	while (!nrfx_nvmc_write_done_check()) {
    1e38:	07db      	lsls	r3, r3, #31
    1e3a:	d5fb      	bpl.n	1e34 <flash_nrf_write+0x30>
	return FLASH_OP_DONE;
    1e3c:	2000      	movs	r0, #0
}
    1e3e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (SUSPEND_POFWARN()) {
    1e42:	f7ff ffb1 	bl	1da8 <suspend_pofwarn>
    1e46:	b958      	cbnz	r0, 1e60 <flash_nrf_write+0x5c>
				     UNALIGNED_GET((uint32_t *)w_ctx->data_addr));
    1e48:	1b7b      	subs	r3, r7, r5
		nrfx_nvmc_word_write(w_ctx->flash_addr,
    1e4a:	4640      	mov	r0, r8
    1e4c:	6819      	ldr	r1, [r3, #0]
    1e4e:	f000 fd6d 	bl	292c <nrfx_nvmc_word_write>
	if (pofcon_enabled) {
    1e52:	f899 3000 	ldrb.w	r3, [r9]
    1e56:	b10b      	cbz	r3, 1e5c <flash_nrf_write+0x58>
    1e58:	f7ff ff90 	bl	1d7c <restore_pofwarn.part.0>
	w_ctx->len -= shift;
    1e5c:	3d04      	subs	r5, #4
}
    1e5e:	e7e3      	b.n	1e28 <flash_nrf_write+0x24>
			return -ECANCELED;
    1e60:	f06f 008b 	mvn.w	r0, #139	; 0x8b
	return ret;
    1e64:	e7eb      	b.n	1e3e <flash_nrf_write+0x3a>
		return -EINVAL;
    1e66:	f06f 0015 	mvn.w	r0, #21
    1e6a:	e7e8      	b.n	1e3e <flash_nrf_write+0x3a>
		return 0;
    1e6c:	4620      	mov	r0, r4
    1e6e:	e7e6      	b.n	1e3e <flash_nrf_write+0x3a>
    1e70:	4001e000 	.word	0x4001e000
    1e74:	2000176c 	.word	0x2000176c

00001e78 <flash_nrf_erase>:
{
    1e78:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1e7c:	460d      	mov	r5, r1
    1e7e:	4616      	mov	r6, r2
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
    1e80:	f003 fe63 	bl	5b4a <nrfx_nvmc_flash_page_size_get>
	if (is_regular_addr_valid(addr, size)) {
    1e84:	4631      	mov	r1, r6
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
    1e86:	4607      	mov	r7, r0
	if (is_regular_addr_valid(addr, size)) {
    1e88:	4628      	mov	r0, r5
    1e8a:	f003 fbf1 	bl	5670 <is_regular_addr_valid>
    1e8e:	b328      	cbz	r0, 1edc <flash_nrf_erase+0x64>
		if (((addr % pg_size) != 0) || ((size % pg_size) != 0)) {
    1e90:	fbb5 f3f7 	udiv	r3, r5, r7
    1e94:	fb07 5313 	mls	r3, r7, r3, r5
    1e98:	bb03      	cbnz	r3, 1edc <flash_nrf_erase+0x64>
    1e9a:	fbb6 f4f7 	udiv	r4, r6, r7
    1e9e:	fb07 6414 	mls	r4, r7, r4, r6
    1ea2:	b9dc      	cbnz	r4, 1edc <flash_nrf_erase+0x64>
		if (!n_pages) {
    1ea4:	42be      	cmp	r6, r7
    1ea6:	d313      	bcc.n	1ed0 <flash_nrf_erase+0x58>
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
    1ea8:	f003 fe4f 	bl	5b4a <nrfx_nvmc_flash_page_size_get>
	if (pofcon_enabled) {
    1eac:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1ee4 <flash_nrf_erase+0x6c>
	uint32_t pg_size = nrfx_nvmc_flash_page_size_get();
    1eb0:	4607      	mov	r7, r0
		if (SUSPEND_POFWARN()) {
    1eb2:	f7ff ff79 	bl	1da8 <suspend_pofwarn>
    1eb6:	4604      	mov	r4, r0
    1eb8:	b968      	cbnz	r0, 1ed6 <flash_nrf_erase+0x5e>
		(void)nrfx_nvmc_page_erase(e_ctx->flash_addr);
    1eba:	4628      	mov	r0, r5
    1ebc:	f000 fd16 	bl	28ec <nrfx_nvmc_page_erase>
	if (pofcon_enabled) {
    1ec0:	f898 3000 	ldrb.w	r3, [r8]
    1ec4:	b10b      	cbz	r3, 1eca <flash_nrf_erase+0x52>
    1ec6:	f7ff ff59 	bl	1d7c <restore_pofwarn.part.0>
	} while (e_ctx->len > 0);
    1eca:	1bf6      	subs	r6, r6, r7
    1ecc:	443d      	add	r5, r7
    1ece:	d1f0      	bne.n	1eb2 <flash_nrf_erase+0x3a>
}
    1ed0:	4620      	mov	r0, r4
    1ed2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			return -ECANCELED;
    1ed6:	f06f 048b 	mvn.w	r4, #139	; 0x8b
	return ret;
    1eda:	e7f9      	b.n	1ed0 <flash_nrf_erase+0x58>
		return -EINVAL;
    1edc:	f06f 0415 	mvn.w	r4, #21
    1ee0:	e7f6      	b.n	1ed0 <flash_nrf_erase+0x58>
    1ee2:	bf00      	nop
    1ee4:	2000176c 	.word	0x2000176c

00001ee8 <compare_int_lock>:
	return 0;
#endif
}

static bool compare_int_lock(int32_t chan)
{
    1ee8:	b510      	push	{r4, lr}
	atomic_val_t prev = atomic_and(&int_mask, ~BIT(chan));
    1eea:	2301      	movs	r3, #1
    1eec:	4083      	lsls	r3, r0
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    1eee:	4a11      	ldr	r2, [pc, #68]	; (1f34 <compare_int_lock+0x4c>)
    1ef0:	f3bf 8f5b 	dmb	ish
    1ef4:	43dc      	mvns	r4, r3
    1ef6:	e852 1f00 	ldrex	r1, [r2]
    1efa:	ea01 0c04 	and.w	ip, r1, r4
    1efe:	e842 ce00 	strex	lr, ip, [r2]
    1f02:	f1be 0f00 	cmp.w	lr, #0
    1f06:	d1f6      	bne.n	1ef6 <compare_int_lock+0xe>
    1f08:	f3bf 8f5b 	dmb	ish

	nrf_rtc_int_disable(RTC, RTC_CHANNEL_INT_MASK(chan));
    1f0c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    1f10:	fa02 f000 	lsl.w	r0, r2, r0
    1f14:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    1f18:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    1f1c:	f8c2 0308 	str.w	r0, [r2, #776]	; 0x308
    1f20:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("isb 0xF":::"memory");
    1f24:	f3bf 8f6f 	isb	sy

	__DMB();
	__ISB();

	return prev & BIT(chan);
    1f28:	420b      	tst	r3, r1
}
    1f2a:	bf14      	ite	ne
    1f2c:	2001      	movne	r0, #1
    1f2e:	2000      	moveq	r0, #0
    1f30:	bd10      	pop	{r4, pc}
    1f32:	bf00      	nop
    1f34:	20001590 	.word	0x20001590

00001f38 <compare_int_unlock>:
	return compare_int_lock(chan);
}

static void compare_int_unlock(int32_t chan, bool key)
{
	if (key) {
    1f38:	b319      	cbz	r1, 1f82 <compare_int_unlock+0x4a>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    1f3a:	f3bf 8f5b 	dmb	ish
		atomic_or(&int_mask, BIT(chan));
    1f3e:	2301      	movs	r3, #1
    1f40:	4a10      	ldr	r2, [pc, #64]	; (1f84 <compare_int_unlock+0x4c>)
    1f42:	4083      	lsls	r3, r0
    1f44:	e852 1f00 	ldrex	r1, [r2]
    1f48:	4319      	orrs	r1, r3
    1f4a:	e842 1c00 	strex	ip, r1, [r2]
    1f4e:	f1bc 0f00 	cmp.w	ip, #0
    1f52:	d1f7      	bne.n	1f44 <compare_int_unlock+0xc>
    1f54:	f3bf 8f5b 	dmb	ish
    p_reg->INTENSET = mask;
    1f58:	4a0b      	ldr	r2, [pc, #44]	; (1f88 <compare_int_unlock+0x50>)
		nrf_rtc_int_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    1f5a:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    1f5e:	4083      	lsls	r3, r0
    1f60:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
    1f64:	4b09      	ldr	r3, [pc, #36]	; (1f8c <compare_int_unlock+0x54>)
    1f66:	f3bf 8f5b 	dmb	ish
    1f6a:	681b      	ldr	r3, [r3, #0]
    1f6c:	f3bf 8f5b 	dmb	ish
		if (atomic_get(&force_isr_mask) & BIT(chan)) {
    1f70:	fa23 f000 	lsr.w	r0, r3, r0
    1f74:	07c3      	lsls	r3, r0, #31
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    1f76:	bf42      	ittt	mi
    1f78:	4b05      	ldrmi	r3, [pc, #20]	; (1f90 <compare_int_unlock+0x58>)
    1f7a:	f44f 3200 	movmi.w	r2, #131072	; 0x20000
    1f7e:	f8c3 2100 	strmi.w	r2, [r3, #256]	; 0x100
			NVIC_SetPendingIRQ(RTC_IRQn);
		}
	}
}
    1f82:	4770      	bx	lr
    1f84:	20001590 	.word	0x20001590
    1f88:	40011000 	.word	0x40011000
    1f8c:	2000158c 	.word	0x2000158c
    1f90:	e000e100 	.word	0xe000e100

00001f94 <z_nrf_rtc_timer_read>:
	compare_int_unlock(chan, key);
}

uint64_t z_nrf_rtc_timer_read(void)
{
	uint64_t val = ((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH;
    1f94:	4b0d      	ldr	r3, [pc, #52]	; (1fcc <z_nrf_rtc_timer_read+0x38>)
    1f96:	6818      	ldr	r0, [r3, #0]
    1f98:	0a01      	lsrs	r1, r0, #8
    1f9a:	0600      	lsls	r0, r0, #24
  __ASM volatile ("dmb 0xF":::"memory");
    1f9c:	f3bf 8f5f 	dmb	sy
     return p_reg->COUNTER;
    1fa0:	4b0b      	ldr	r3, [pc, #44]	; (1fd0 <z_nrf_rtc_timer_read+0x3c>)
    1fa2:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504

	__DMB();

	uint32_t cntr = counter();

	val += cntr;
    1fa6:	1818      	adds	r0, r3, r0
    1fa8:	f141 0100 	adc.w	r1, r1, #0

	if (cntr < OVERFLOW_RISK_RANGE_END) {
    1fac:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    1fb0:	d20a      	bcs.n	1fc8 <z_nrf_rtc_timer_read+0x34>
		 * due to possibility that this code preempted overflow interrupt before final write
		 * of `overflow_cnt`. Update of `anchor` occurs far in time from this moment, so
		 * `anchor` is considered valid and stable. Because of this timing there is no risk
		 * of incorrect `anchor` value caused by non-atomic read of 64-bit `anchor`.
		 */
		if (val < anchor) {
    1fb2:	4b08      	ldr	r3, [pc, #32]	; (1fd4 <z_nrf_rtc_timer_read+0x40>)
    1fb4:	e9d3 2300 	ldrd	r2, r3, [r3]
    1fb8:	4290      	cmp	r0, r2
    1fba:	eb71 0303 	sbcs.w	r3, r1, r3
    1fbe:	d203      	bcs.n	1fc8 <z_nrf_rtc_timer_read+0x34>
			/* Unhandled overflow, detected, let's add correction */
			val += COUNTER_SPAN;
    1fc0:	f110 7080 	adds.w	r0, r0, #16777216	; 0x1000000
    1fc4:	f141 0100 	adc.w	r1, r1, #0
		 * check validity using `anchor`
		 */
	}

	return val;
}
    1fc8:	4770      	bx	lr
    1fca:	bf00      	nop
    1fcc:	20001594 	.word	0x20001594
    1fd0:	40011000 	.word	0x40011000
    1fd4:	20000088 	.word	0x20000088

00001fd8 <compare_set>:
{
    1fd8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1fdc:	ed2d 8b02 	vpush	{d8}
    1fe0:	b085      	sub	sp, #20
    1fe2:	4616      	mov	r6, r2
    1fe4:	4698      	mov	r8, r3
    1fe6:	4605      	mov	r5, r0
	key = compare_int_lock(chan);
    1fe8:	f7ff ff7e 	bl	1ee8 <compare_int_lock>
    1fec:	ee08 0a10 	vmov	s16, r0
	uint64_t curr_time = z_nrf_rtc_timer_read();
    1ff0:	f7ff ffd0 	bl	1f94 <z_nrf_rtc_timer_read>
	if (curr_time < target_time) {
    1ff4:	42b0      	cmp	r0, r6
    1ff6:	eb71 0308 	sbcs.w	r3, r1, r8
    1ffa:	d27b      	bcs.n	20f4 <compare_set+0x11c>
		if (target_time - curr_time > COUNTER_SPAN) {
    1ffc:	4b47      	ldr	r3, [pc, #284]	; (211c <compare_set+0x144>)
    1ffe:	1a30      	subs	r0, r6, r0
    2000:	eb68 0101 	sbc.w	r1, r8, r1
    2004:	4298      	cmp	r0, r3
    2006:	f171 0300 	sbcs.w	r3, r1, #0
    200a:	f080 8084 	bcs.w	2116 <compare_set+0x13e>
		if (target_time != cc_data[chan].target_time) {
    200e:	4b44      	ldr	r3, [pc, #272]	; (2120 <compare_set+0x148>)
    2010:	eb03 1305 	add.w	r3, r3, r5, lsl #4
    2014:	e9d3 ab02 	ldrd	sl, fp, [r3, #8]
    2018:	45d8      	cmp	r8, fp
    201a:	bf08      	it	eq
    201c:	4556      	cmpeq	r6, sl
    201e:	d051      	beq.n	20c4 <compare_set+0xec>
    2020:	ea4f 0985 	mov.w	r9, r5, lsl #2
    2024:	f109 4980 	add.w	r9, r9, #1073741824	; 0x40000000
	nrf_rtc_event_clear(RTC, RTC_CHANNEL_EVENT_ADDR(chan));
    2028:	f105 0750 	add.w	r7, r5, #80	; 0x50
    202c:	f509 3988 	add.w	r9, r9, #69632	; 0x11000
    2030:	00bf      	lsls	r7, r7, #2
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2032:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    2036:	fa01 f305 	lsl.w	r3, r1, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    203a:	b2bf      	uxth	r7, r7
	return absolute_time & COUNTER_MAX;
    203c:	f026 427f 	bic.w	r2, r6, #4278190080	; 0xff000000
    2040:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    2044:	9301      	str	r3, [sp, #4]
    return p_reg->CC[ch];
    2046:	f8d9 0540 	ldr.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
    204a:	4b36      	ldr	r3, [pc, #216]	; (2124 <compare_set+0x14c>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    204c:	f507 3788 	add.w	r7, r7, #69632	; 0x11000
	uint32_t cc_val = abs_val & COUNTER_MAX;
    2050:	4614      	mov	r4, r2
     return p_reg->COUNTER;
    2052:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
    2056:	1a40      	subs	r0, r0, r1
    2058:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    205c:	f021 4c7f 	bic.w	ip, r1, #4278190080	; 0xff000000
		if (counter_sub(prev_cc, now) == 1) {
    2060:	2801      	cmp	r0, #1
    p_reg->CC[ch] = cc_val;
    2062:	f8c9 c540 	str.w	ip, [r9, #1344]	; 0x540
    2066:	d107      	bne.n	2078 <compare_set+0xa0>
    2068:	e9cd 2102 	strd	r2, r1, [sp, #8]
	z_impl_k_busy_wait(usec_to_wait);
    206c:	2013      	movs	r0, #19
    206e:	f003 fdbd 	bl	5bec <z_impl_k_busy_wait>
    2072:	e9dd 2102 	ldrd	r2, r1, [sp, #8]
    2076:	4b2b      	ldr	r3, [pc, #172]	; (2124 <compare_set+0x14c>)
		if (counter_sub(cc_val, now + 2) > COUNTER_HALF_SPAN) {
    2078:	f101 0c02 	add.w	ip, r1, #2
	return (a - b) & COUNTER_MAX;
    207c:	eba4 000c 	sub.w	r0, r4, ip
    2080:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			cc_val = now + 2;
    2084:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    2088:	bf88      	it	hi
    208a:	4664      	movhi	r4, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    208c:	2000      	movs	r0, #0
    208e:	6038      	str	r0, [r7, #0]
    2090:	6838      	ldr	r0, [r7, #0]
    p_reg->EVTENSET = mask;
    2092:	9801      	ldr	r0, [sp, #4]
    2094:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
	nrf_rtc_cc_set(RTC, chan, cyc & COUNTER_MAX);
    2098:	f024 407f 	bic.w	r0, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
    209c:	f8c9 0540 	str.w	r0, [r9, #1344]	; 0x540
     return p_reg->COUNTER;
    20a0:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		 (counter_sub(cc_val, now2 + 2) > COUNTER_HALF_SPAN));
    20a4:	4281      	cmp	r1, r0
    20a6:	d006      	beq.n	20b6 <compare_set+0xde>
	return (a - b) & COUNTER_MAX;
    20a8:	1a20      	subs	r0, r4, r0
    20aa:	3802      	subs	r0, #2
    20ac:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	} while ((now2 != now) &&
    20b0:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
    20b4:	d81c      	bhi.n	20f0 <compare_set+0x118>
	return (a - b) & COUNTER_MAX;
    20b6:	1aa4      	subs	r4, r4, r2
    20b8:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
			target_time += counter_sub(cc_set, cc_value);
    20bc:	eb14 0a06 	adds.w	sl, r4, r6
    20c0:	f148 0b00 	adc.w	fp, r8, #0
	cc_data[chan].target_time = target_time;
    20c4:	4916      	ldr	r1, [pc, #88]	; (2120 <compare_set+0x148>)
	cc_data[chan].callback = handler;
    20c6:	9810      	ldr	r0, [sp, #64]	; 0x40
	cc_data[chan].target_time = target_time;
    20c8:	012b      	lsls	r3, r5, #4
    20ca:	eb01 1205 	add.w	r2, r1, r5, lsl #4
    20ce:	e9c2 ab02 	strd	sl, fp, [r2, #8]
	cc_data[chan].callback = handler;
    20d2:	50c8      	str	r0, [r1, r3]
	cc_data[chan].user_context = user_data;
    20d4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    20d6:	6053      	str	r3, [r2, #4]
	return ret;
    20d8:	2400      	movs	r4, #0
	compare_int_unlock(chan, key);
    20da:	4628      	mov	r0, r5
    20dc:	ee18 1a10 	vmov	r1, s16
    20e0:	f7ff ff2a 	bl	1f38 <compare_int_unlock>
}
    20e4:	4620      	mov	r0, r4
    20e6:	b005      	add	sp, #20
    20e8:	ecbd 8b02 	vpop	{d8}
    20ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    20f0:	4620      	mov	r0, r4
    20f2:	e7ae      	b.n	2052 <compare_set+0x7a>
		atomic_or(&force_isr_mask, BIT(chan));
    20f4:	2301      	movs	r3, #1
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
    20f6:	4a0c      	ldr	r2, [pc, #48]	; (2128 <compare_set+0x150>)
    20f8:	f3bf 8f5b 	dmb	ish
    20fc:	40ab      	lsls	r3, r5
    20fe:	e852 1f00 	ldrex	r1, [r2]
    2102:	4319      	orrs	r1, r3
    2104:	e842 1000 	strex	r0, r1, [r2]
    2108:	2800      	cmp	r0, #0
    210a:	d1f8      	bne.n	20fe <compare_set+0x126>
    210c:	f3bf 8f5b 	dmb	ish
    2110:	46b2      	mov	sl, r6
    2112:	46c3      	mov	fp, r8
    2114:	e7d6      	b.n	20c4 <compare_set+0xec>
			return -EINVAL;
    2116:	f06f 0415 	mvn.w	r4, #21
    211a:	e7de      	b.n	20da <compare_set+0x102>
    211c:	01000001 	.word	0x01000001
    2120:	20000090 	.word	0x20000090
    2124:	40011000 	.word	0x40011000
    2128:	2000158c 	.word	0x2000158c

0000212c <sys_clock_driver_init>:
{
	return (uint32_t)z_nrf_rtc_timer_read();
}

static int sys_clock_driver_init(const struct device *dev)
{
    212c:	b573      	push	{r0, r1, r4, r5, r6, lr}
			CLOCK_CONTROL_NRF_LF_START_STABLE);

	/* TODO: replace with counter driver to access RTC */
	nrf_rtc_prescaler_set(RTC, 0);
	for (int32_t chan = 0; chan < CHAN_COUNT; chan++) {
		cc_data[chan].target_time = TARGET_TIME_INVALID;
    212e:	4b1a      	ldr	r3, [pc, #104]	; (2198 <sys_clock_driver_init+0x6c>)
    p_reg->PRESCALER = val;
    2130:	4d1a      	ldr	r5, [pc, #104]	; (219c <sys_clock_driver_init+0x70>)
    2132:	2400      	movs	r4, #0
    2134:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2138:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    213c:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    2140:	e9c3 0102 	strd	r0, r1, [r3, #8]
    p_reg->INTENSET = mask;
    2144:	f44f 3380 	mov.w	r3, #65536	; 0x10000
    2148:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
    214c:	4b14      	ldr	r3, [pc, #80]	; (21a0 <sys_clock_driver_init+0x74>)
    214e:	2602      	movs	r6, #2
    2150:	f44f 3200 	mov.w	r2, #131072	; 0x20000

	nrf_rtc_int_enable(RTC, NRF_RTC_INT_OVERFLOW_MASK);

	NVIC_ClearPendingIRQ(RTC_IRQn);

	IRQ_CONNECT(RTC_IRQn, DT_IRQ(DT_NODELABEL(RTC_LABEL), priority),
    2154:	2101      	movs	r1, #1
    2156:	f8c5 6304 	str.w	r6, [r5, #772]	; 0x304
    215a:	2011      	movs	r0, #17
    215c:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    2160:	4622      	mov	r2, r4
    2162:	f7fe ff4d 	bl	1000 <z_arm_irq_priority_set>
		    rtc_nrf_isr, 0, 0);
	irq_enable(RTC_IRQn);
    2166:	2011      	movs	r0, #17
    2168:	f7fe ff18 	bl	f9c <arch_irq_enable>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
    216c:	2301      	movs	r3, #1

	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_CLEAR);
	nrf_rtc_task_trigger(RTC, NRF_RTC_TASK_START);

	int_mask = BIT_MASK(CHAN_COUNT);
    216e:	4a0d      	ldr	r2, [pc, #52]	; (21a4 <sys_clock_driver_init+0x78>)
    2170:	60ab      	str	r3, [r5, #8]
    2172:	602b      	str	r3, [r5, #0]
    2174:	6013      	str	r3, [r2, #0]
     return p_reg->COUNTER;
    2176:	f8d5 2504 	ldr.w	r2, [r5, #1284]	; 0x504

	uint32_t initial_timeout = IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
		(COUNTER_HALF_SPAN - 1) :
		(counter() + CYC_PER_TICK);

	compare_set(0, initial_timeout, sys_clock_timeout_handler, NULL);
    217a:	4b0b      	ldr	r3, [pc, #44]	; (21a8 <sys_clock_driver_init+0x7c>)
    217c:	9300      	str	r3, [sp, #0]
    217e:	3201      	adds	r2, #1
    2180:	4623      	mov	r3, r4
    2182:	9401      	str	r4, [sp, #4]
    2184:	4620      	mov	r0, r4
    2186:	f7ff ff27 	bl	1fd8 <compare_set>

	z_nrf_clock_control_lf_on(mode);
    218a:	4630      	mov	r0, r6
    218c:	f7ff fafe 	bl	178c <z_nrf_clock_control_lf_on>

	return 0;
}
    2190:	4620      	mov	r0, r4
    2192:	b002      	add	sp, #8
    2194:	bd70      	pop	{r4, r5, r6, pc}
    2196:	bf00      	nop
    2198:	20000090 	.word	0x20000090
    219c:	40011000 	.word	0x40011000
    21a0:	e000e100 	.word	0xe000e100
    21a4:	20001590 	.word	0x20001590
    21a8:	000021ad 	.word	0x000021ad

000021ac <sys_clock_timeout_handler>:
{
    21ac:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    21b0:	461e      	mov	r6, r3
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    21b2:	4b24      	ldr	r3, [pc, #144]	; (2244 <sys_clock_timeout_handler+0x98>)
	return absolute_time & COUNTER_MAX;
    21b4:	f022 477f 	bic.w	r7, r2, #4278190080	; 0xff000000
	uint64_t dticks = (expire_time - last_count) / CYC_PER_TICK;
    21b8:	e9d3 9800 	ldrd	r9, r8, [r3]
	last_count += dticks * CYC_PER_TICK;
    21bc:	e9c3 2600 	strd	r2, r6, [r3]
	return (cc_value >= ANCHOR_RANGE_START) && (cc_value < ANCHOR_RANGE_END);
    21c0:	f5a7 1300 	sub.w	r3, r7, #2097152	; 0x200000
	if (in_anchor_range(cc_value)) {
    21c4:	f5b3 0f40 	cmp.w	r3, #12582912	; 0xc00000
{
    21c8:	4605      	mov	r5, r0
    21ca:	4614      	mov	r4, r2
	if (in_anchor_range(cc_value)) {
    21cc:	d237      	bcs.n	223e <sys_clock_timeout_handler+0x92>
		anchor = (((uint64_t)overflow_cnt) << COUNTER_BIT_WIDTH) + cc_value;
    21ce:	4b1e      	ldr	r3, [pc, #120]	; (2248 <sys_clock_timeout_handler+0x9c>)
    21d0:	681a      	ldr	r2, [r3, #0]
    21d2:	0a13      	lsrs	r3, r2, #8
    21d4:	0612      	lsls	r2, r2, #24
    21d6:	19d0      	adds	r0, r2, r7
    21d8:	f143 0100 	adc.w	r1, r3, #0
    21dc:	4b1b      	ldr	r3, [pc, #108]	; (224c <sys_clock_timeout_handler+0xa0>)
    21de:	e9c3 0100 	strd	r0, r1, [r3]
		return true;
    21e2:	f04f 0a01 	mov.w	sl, #1
		compare_set(chan, last_count + CYC_PER_TICK,
    21e6:	2300      	movs	r3, #0
    21e8:	1c62      	adds	r2, r4, #1
    21ea:	9301      	str	r3, [sp, #4]
    21ec:	4b18      	ldr	r3, [pc, #96]	; (2250 <sys_clock_timeout_handler+0xa4>)
    21ee:	9300      	str	r3, [sp, #0]
    21f0:	4628      	mov	r0, r5
    21f2:	f146 0300 	adc.w	r3, r6, #0
    21f6:	f7ff feef 	bl	1fd8 <compare_set>
	sys_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ?
    21fa:	45b0      	cmp	r8, r6
    21fc:	bf08      	it	eq
    21fe:	45a1      	cmpeq	r9, r4
    2200:	bf14      	ite	ne
    2202:	2001      	movne	r0, #1
    2204:	2000      	moveq	r0, #0
    2206:	f000 ff83 	bl	3110 <sys_clock_announce>
    return p_reg->CC[ch];
    220a:	00ab      	lsls	r3, r5, #2
    220c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    2210:	f503 3388 	add.w	r3, r3, #69632	; 0x11000
    2214:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	if (cc_value == get_comparator(chan)) {
    2218:	4297      	cmp	r7, r2
    221a:	d10d      	bne.n	2238 <sys_clock_timeout_handler+0x8c>
		if (!anchor_updated) {
    221c:	f1ba 0f00 	cmp.w	sl, #0
    2220:	d103      	bne.n	222a <sys_clock_timeout_handler+0x7e>
    p_reg->CC[ch] = cc_val;
    2222:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
    2226:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->EVTENSET = mask;
    222a:	4b0a      	ldr	r3, [pc, #40]	; (2254 <sys_clock_timeout_handler+0xa8>)
	nrf_rtc_event_enable(RTC, RTC_CHANNEL_INT_MASK(chan));
    222c:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    2230:	fa00 f505 	lsl.w	r5, r0, r5
    2234:	f8c3 5344 	str.w	r5, [r3, #836]	; 0x344
}
    2238:	b002      	add	sp, #8
    223a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	return false;
    223e:	f04f 0a00 	mov.w	sl, #0
    2242:	e7d0      	b.n	21e6 <sys_clock_timeout_handler+0x3a>
    2244:	200000a0 	.word	0x200000a0
    2248:	20001594 	.word	0x20001594
    224c:	20000088 	.word	0x20000088
    2250:	000021ad 	.word	0x000021ad
    2254:	40011000 	.word	0x40011000

00002258 <rtc_nrf_isr>:
{
    2258:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    return p_reg->INTENSET & mask;
    225c:	4c36      	ldr	r4, [pc, #216]	; (2338 <rtc_nrf_isr+0xe0>)
    225e:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, NRF_RTC_INT_OVERFLOW_MASK) &&
    2262:	079a      	lsls	r2, r3, #30
    2264:	d50b      	bpl.n	227e <rtc_nrf_isr+0x26>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2266:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    226a:	b143      	cbz	r3, 227e <rtc_nrf_isr+0x26>
		overflow_cnt++;
    226c:	4a33      	ldr	r2, [pc, #204]	; (233c <rtc_nrf_isr+0xe4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    226e:	2300      	movs	r3, #0
    2270:	f8c4 3104 	str.w	r3, [r4, #260]	; 0x104
    2274:	f8d4 3104 	ldr.w	r3, [r4, #260]	; 0x104
    2278:	6813      	ldr	r3, [r2, #0]
    227a:	3301      	adds	r3, #1
    227c:	6013      	str	r3, [r2, #0]
	__asm__ volatile(
    227e:	f04f 0320 	mov.w	r3, #32
    2282:	f3ef 8211 	mrs	r2, BASEPRI
    2286:	f383 8812 	msr	BASEPRI_MAX, r3
    228a:	f3bf 8f6f 	isb	sy
    return p_reg->INTENSET & mask;
    228e:	f8d4 3304 	ldr.w	r3, [r4, #772]	; 0x304
	if (nrf_rtc_int_enable_check(RTC, RTC_CHANNEL_INT_MASK(chan))) {
    2292:	03db      	lsls	r3, r3, #15
    2294:	d512      	bpl.n	22bc <rtc_nrf_isr+0x64>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
    2296:	f3bf 8f5b 	dmb	ish
    229a:	4b29      	ldr	r3, [pc, #164]	; (2340 <rtc_nrf_isr+0xe8>)
    229c:	e853 1f00 	ldrex	r1, [r3]
    22a0:	f021 0001 	bic.w	r0, r1, #1
    22a4:	e843 0600 	strex	r6, r0, [r3]
    22a8:	2e00      	cmp	r6, #0
    22aa:	d1f7      	bne.n	229c <rtc_nrf_isr+0x44>
    22ac:	f3bf 8f5b 	dmb	ish
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    22b0:	2900      	cmp	r1, #0
    22b2:	d139      	bne.n	2328 <rtc_nrf_isr+0xd0>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    22b4:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		if (result) {
    22b8:	2b00      	cmp	r3, #0
    22ba:	d135      	bne.n	2328 <rtc_nrf_isr+0xd0>
{
    22bc:	2300      	movs	r3, #0
	__asm__ volatile(
    22be:	f382 8811 	msr	BASEPRI, r2
    22c2:	f3bf 8f6f 	isb	sy
	if (channel_processing_check_and_clear(chan)) {
    22c6:	b363      	cbz	r3, 2322 <rtc_nrf_isr+0xca>
		curr_time = z_nrf_rtc_timer_read();
    22c8:	f7ff fe64 	bl	1f94 <z_nrf_rtc_timer_read>
	__asm__ volatile(
    22cc:	f04f 0320 	mov.w	r3, #32
    22d0:	f3ef 8c11 	mrs	ip, BASEPRI
    22d4:	f383 8812 	msr	BASEPRI_MAX, r3
    22d8:	f3bf 8f6f 	isb	sy
		expire_time = cc_data[chan].target_time;
    22dc:	4b19      	ldr	r3, [pc, #100]	; (2344 <rtc_nrf_isr+0xec>)
    22de:	e9d3 6702 	ldrd	r6, r7, [r3, #8]
		if (curr_time >= expire_time) {
    22e2:	42b0      	cmp	r0, r6
    22e4:	eb71 0207 	sbcs.w	r2, r1, r7
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    22e8:	bf28      	it	cs
    22ea:	f04f 38ff 	movcs.w	r8, #4294967295	; 0xffffffff
    22ee:	f04f 0200 	mov.w	r2, #0
    22f2:	bf21      	itttt	cs
    22f4:	f04f 39ff 	movcs.w	r9, #4294967295	; 0xffffffff
			user_context = cc_data[chan].user_context;
    22f8:	e9d3 1500 	ldrdcs	r1, r5, [r3]
			cc_data[chan].target_time = TARGET_TIME_INVALID;
    22fc:	e9c3 8902 	strdcs	r8, r9, [r3, #8]
			cc_data[chan].callback = NULL;
    2300:	601a      	strcs	r2, [r3, #0]
    p_reg->EVTENCLR = mask;
    2302:	bf26      	itte	cs
    2304:	f44f 3380 	movcs.w	r3, #65536	; 0x10000
    2308:	f8c4 3348 	strcs.w	r3, [r4, #840]	; 0x348
		z_nrf_rtc_timer_compare_handler_t handler = NULL;
    230c:	4611      	movcc	r1, r2
	__asm__ volatile(
    230e:	f38c 8811 	msr	BASEPRI, ip
    2312:	f3bf 8f6f 	isb	sy
		if (handler) {
    2316:	b121      	cbz	r1, 2322 <rtc_nrf_isr+0xca>
			handler(chan, expire_time, user_context);
    2318:	9500      	str	r5, [sp, #0]
    231a:	4632      	mov	r2, r6
    231c:	463b      	mov	r3, r7
    231e:	2000      	movs	r0, #0
    2320:	4788      	blx	r1
}
    2322:	b003      	add	sp, #12
    2324:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
    2328:	2300      	movs	r3, #0
    232a:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
    232e:	f8d4 3140 	ldr.w	r3, [r4, #320]	; 0x140
		result = atomic_and(&force_isr_mask, ~BIT(chan)) ||
    2332:	2301      	movs	r3, #1
}
    2334:	e7c3      	b.n	22be <rtc_nrf_isr+0x66>
    2336:	bf00      	nop
    2338:	40011000 	.word	0x40011000
    233c:	20001594 	.word	0x20001594
    2340:	2000158c 	.word	0x2000158c
    2344:	20000090 	.word	0x20000090

00002348 <nrf_gpio_pin_clear>:
}

NRF_STATIC_INLINE uint32_t nrf_gpio_pin_port_number_extract(uint32_t * p_pin)
{
    uint32_t pin_number = *p_pin;
    *p_pin = pin_number & 0x1F;
    2348:	f000 011f 	and.w	r1, r0, #31

    return pin_number >> 5;
    234c:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    234e:	2801      	cmp	r0, #1
    2350:	4b04      	ldr	r3, [pc, #16]	; (2364 <nrf_gpio_pin_clear+0x1c>)
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    2352:	f04f 0201 	mov.w	r2, #1
        case 1: return NRF_P1;
    2356:	bf18      	it	ne
    2358:	f04f 43a0 	movne.w	r3, #1342177280	; 0x50000000
    nrf_gpio_port_out_clear(reg, 1UL << pin_number);
    235c:	408a      	lsls	r2, r1
    p_reg->OUTCLR = clr_mask;
    235e:	f8c3 250c 	str.w	r2, [r3, #1292]	; 0x50c
}
    2362:	4770      	bx	lr
    2364:	50000300 	.word	0x50000300

00002368 <nrf_pin_configure.constprop.0>:
				       nrf_gpio_pin_dir_t dir,
				       nrf_gpio_pin_input_t input,
				       nrf_gpio_pin_drive_t drive)
{
	/* force input direction and disconnected buffer for low power */
	if (NRF_GET_LP(pin) == NRF_LP_ENABLE) {
    2368:	f400 5380 	and.w	r3, r0, #4096	; 0x1000
		dir = NRF_GPIO_PIN_DIR_INPUT;
		input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    236c:	2b00      	cmp	r3, #0
__unused static void nrf_pin_configure(pinctrl_soc_pin_t pin,
    236e:	b530      	push	{r4, r5, lr}
		input = NRF_GPIO_PIN_INPUT_DISCONNECT;
    2370:	bf1c      	itt	ne
    2372:	2100      	movne	r1, #0
    2374:	2201      	movne	r2, #1
	}

	nrf_gpio_cfg(NRF_GET_PIN(pin), dir, input, NRF_GET_PULL(pin),
    2376:	f3c0 1581 	ubfx	r5, r0, #6, #2
    *p_pin = pin_number & 0x1F;
    237a:	f000 041f 	and.w	r4, r0, #31
        case 1: return NRF_P1;
    237e:	f010 0f20 	tst.w	r0, #32
           ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos) |
    2382:	f400 6070 	and.w	r0, r0, #3840	; 0xf00
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    2386:	ea40 0085 	orr.w	r0, r0, r5, lsl #2
        case 1: return NRF_P1;
    238a:	4b06      	ldr	r3, [pc, #24]	; (23a4 <nrf_pin_configure.constprop.0+0x3c>)
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    238c:	ea40 0001 	orr.w	r0, r0, r1
        case 1: return NRF_P1;
    2390:	bf08      	it	eq
    2392:	f04f 43a0 	moveq.w	r3, #1342177280	; 0x50000000
    reg->PIN_CNF[pin_number] = cnf;
    2396:	f504 71e0 	add.w	r1, r4, #448	; 0x1c0
           ((uint32_t)pull << GPIO_PIN_CNF_PULL_Pos)   |
    239a:	ea40 0242 	orr.w	r2, r0, r2, lsl #1
    reg->PIN_CNF[pin_number] = cnf;
    239e:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
		     NRF_GET_DRIVE(pin), NRF_GPIO_PIN_NOSENSE);
}
    23a2:	bd30      	pop	{r4, r5, pc}
    23a4:	50000300 	.word	0x50000300

000023a8 <nrf_gpio_pin_set>:
    *p_pin = pin_number & 0x1F;
    23a8:	f000 011f 	and.w	r1, r0, #31
    return pin_number >> 5;
    23ac:	0940      	lsrs	r0, r0, #5
        case 1: return NRF_P1;
    23ae:	2801      	cmp	r0, #1
    23b0:	4b04      	ldr	r3, [pc, #16]	; (23c4 <nrf_gpio_pin_set+0x1c>)
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    23b2:	f04f 0201 	mov.w	r2, #1
        case 1: return NRF_P1;
    23b6:	bf18      	it	ne
    23b8:	f04f 43a0 	movne.w	r3, #1342177280	; 0x50000000
    nrf_gpio_port_out_set(reg, 1UL << pin_number);
    23bc:	408a      	lsls	r2, r1
    p_reg->OUTSET = set_mask;
    23be:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
}
    23c2:	4770      	bx	lr
    23c4:	50000300 	.word	0x50000300

000023c8 <find_free_region>:
/* Find the first unused ACL region. */
static int find_free_region(uint32_t *region_idx)
{
	static uint32_t idx;

	while (nrf_acl_region_perm_get(NRF_ACL, idx) != 0) {
    23c8:	4a0c      	ldr	r2, [pc, #48]	; (23fc <find_free_region+0x34>)
{
    23ca:	b530      	push	{r4, r5, lr}
    23cc:	6813      	ldr	r3, [r2, #0]
}

NRF_STATIC_INLINE nrf_acl_perm_t nrf_acl_region_perm_get(NRF_ACL_Type const * p_reg,
                                                         uint32_t             region_id)
{
    return (nrf_acl_perm_t)p_reg->ACL[region_id].PERM;
    23ce:	4d0c      	ldr	r5, [pc, #48]	; (2400 <find_free_region+0x38>)
	while (nrf_acl_region_perm_get(NRF_ACL, idx) != 0) {
    23d0:	2400      	movs	r4, #0
    23d2:	eb05 1103 	add.w	r1, r5, r3, lsl #4
    23d6:	f8d1 1808 	ldr.w	r1, [r1, #2056]	; 0x808
    23da:	b2c9      	uxtb	r1, r1
    23dc:	b921      	cbnz	r1, 23e8 <find_free_region+0x20>
    23de:	b104      	cbz	r4, 23e2 <find_free_region+0x1a>
    23e0:	6013      	str	r3, [r2, #0]
		if (idx >= ACL_REGIONS_COUNT) {
			*region_idx = idx;
			return -ENOSPC;
		}
	}
	*region_idx = idx;
    23e2:	6003      	str	r3, [r0, #0]
	return 0;
    23e4:	2000      	movs	r0, #0
    23e6:	e008      	b.n	23fa <find_free_region+0x32>
		idx++;
    23e8:	3301      	adds	r3, #1
		if (idx >= ACL_REGIONS_COUNT) {
    23ea:	2b07      	cmp	r3, #7
    23ec:	f04f 0401 	mov.w	r4, #1
    23f0:	d9ef      	bls.n	23d2 <find_free_region+0xa>
			*region_idx = idx;
    23f2:	6003      	str	r3, [r0, #0]
    23f4:	6013      	str	r3, [r2, #0]
			return -ENOSPC;
    23f6:	f06f 001b 	mvn.w	r0, #27
}
    23fa:	bd30      	pop	{r4, r5, pc}
    23fc:	20001598 	.word	0x20001598
    2400:	4001e000 	.word	0x4001e000

00002404 <boot_write_magic>:
    return rc;
}

int
boot_write_magic(const struct flash_area *fap)
{
    2404:	b530      	push	{r4, r5, lr}
    return flash_area_get_size(fap) - BOOT_MAGIC_SZ;
    2406:	6881      	ldr	r1, [r0, #8]
{
    2408:	b085      	sub	sp, #20
    return flash_area_get_size(fap) - BOOT_MAGIC_SZ;
    240a:	3910      	subs	r1, #16
     * returned by boot_magic_off() is the start of magic which is not the
     * start of the flash write boundary and thus writes to the magic will fail.
     * To account for this change, write to magic is first padded with 0xFF
     * before writing to the trailer.
     */
    pad_off = ALIGN_DOWN(off, BOOT_MAX_ALIGN);
    240c:	f021 0407 	bic.w	r4, r1, #7
{
    2410:	4605      	mov	r5, r0

    erased_val = flash_area_erased_val(fap);
    2412:	f002 ffb2 	bl	537a <flash_area_erased_val>

    memset(&magic[0], erased_val, sizeof(magic));
    2416:	2210      	movs	r2, #16
    erased_val = flash_area_erased_val(fap);
    2418:	4601      	mov	r1, r0
    memset(&magic[0], erased_val, sizeof(magic));
    241a:	4668      	mov	r0, sp
    241c:	f003 f827 	bl	546e <memset>
    memcpy(&magic[BOOT_MAGIC_ALIGN_SIZE - BOOT_MAGIC_SZ], BOOT_IMG_MAGIC, BOOT_MAGIC_SZ);
    2420:	4907      	ldr	r1, [pc, #28]	; (2440 <boot_write_magic+0x3c>)
    2422:	2210      	movs	r2, #16
    2424:	4668      	mov	r0, sp
    2426:	f003 f817 	bl	5458 <memcpy>

    BOOT_LOG_DBG("writing magic; fa_id=%d off=0x%lx (0x%lx)",
                 flash_area_get_id(fap), (unsigned long)off,
                 (unsigned long)(flash_area_get_off(fap) + off));
    rc = flash_area_write(fap, pad_off, &magic[0], BOOT_MAGIC_ALIGN_SIZE);
    242a:	2310      	movs	r3, #16
    242c:	466a      	mov	r2, sp
    242e:	4621      	mov	r1, r4
    2430:	4628      	mov	r0, r5
    2432:	f002 ff66 	bl	5302 <flash_area_write>
    if (rc != 0) {
        return BOOT_EFLASH;
    }

    return 0;
}
    2436:	3800      	subs	r0, #0
    2438:	bf18      	it	ne
    243a:	2001      	movne	r0, #1
    243c:	b005      	add	sp, #20
    243e:	bd30      	pop	{r4, r5, pc}
    2440:	000061de 	.word	0x000061de

00002444 <boot_read_swap_state>:
{
    2444:	b530      	push	{r4, r5, lr}
    2446:	460c      	mov	r4, r1
    return flash_area_get_size(fap) - BOOT_MAGIC_SZ;
    2448:	6881      	ldr	r1, [r0, #8]
{
    244a:	b087      	sub	sp, #28
    rc = flash_area_read(fap, off, magic, BOOT_MAGIC_SZ);
    244c:	2310      	movs	r3, #16
    244e:	aa02      	add	r2, sp, #8
    2450:	3910      	subs	r1, #16
{
    2452:	4605      	mov	r5, r0
    rc = flash_area_read(fap, off, magic, BOOT_MAGIC_SZ);
    2454:	f002 ff39 	bl	52ca <flash_area_read>
    if (rc < 0) {
    2458:	2800      	cmp	r0, #0
    245a:	da02      	bge.n	2462 <boot_read_swap_state+0x1e>
        return BOOT_EFLASH;
    245c:	2001      	movs	r0, #1
}
    245e:	b007      	add	sp, #28
    2460:	bd30      	pop	{r4, r5, pc}
    if (buffer == NULL || len == 0) {
    2462:	2210      	movs	r2, #16
    2464:	a902      	add	r1, sp, #8
    2466:	4628      	mov	r0, r5
    2468:	f003 fa61 	bl	592e <bootutil_buffer_is_erased.part.0>
    if (bootutil_buffer_is_erased(fap, magic, BOOT_MAGIC_SZ)) {
    246c:	b390      	cbz	r0, 24d4 <boot_read_swap_state+0x90>
        state->magic = BOOT_MAGIC_UNSET;
    246e:	2303      	movs	r3, #3
        state->magic = boot_magic_decode(magic);
    2470:	7023      	strb	r3, [r4, #0]
    off = boot_swap_info_off(fap);
    2472:	4628      	mov	r0, r5
    2474:	f003 fa6c 	bl	5950 <boot_swap_info_off>
    rc = flash_area_read(fap, off, &swap_info, sizeof swap_info);
    2478:	2301      	movs	r3, #1
    off = boot_swap_info_off(fap);
    247a:	4601      	mov	r1, r0
    rc = flash_area_read(fap, off, &swap_info, sizeof swap_info);
    247c:	f10d 0207 	add.w	r2, sp, #7
    2480:	4628      	mov	r0, r5
    2482:	f002 ff22 	bl	52ca <flash_area_read>
    if (rc < 0) {
    2486:	2800      	cmp	r0, #0
    2488:	dbe8      	blt.n	245c <boot_read_swap_state+0x18>
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
    248a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    248e:	f003 020f 	and.w	r2, r3, #15
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
    2492:	091b      	lsrs	r3, r3, #4
    state->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
    2494:	7062      	strb	r2, [r4, #1]
    state->image_num = BOOT_GET_IMAGE_NUM(swap_info);
    2496:	7123      	strb	r3, [r4, #4]
    if (buffer == NULL || len == 0) {
    2498:	2201      	movs	r2, #1
    249a:	f10d 0107 	add.w	r1, sp, #7
    249e:	4628      	mov	r0, r5
    24a0:	f003 fa45 	bl	592e <bootutil_buffer_is_erased.part.0>
    if (bootutil_buffer_is_erased(fap, &swap_info, sizeof swap_info) ||
    24a4:	b910      	cbnz	r0, 24ac <boot_read_swap_state+0x68>
    24a6:	7863      	ldrb	r3, [r4, #1]
    24a8:	2b04      	cmp	r3, #4
    24aa:	d903      	bls.n	24b4 <boot_read_swap_state+0x70>
        state->swap_type = BOOT_SWAP_TYPE_NONE;
    24ac:	2301      	movs	r3, #1
    24ae:	7063      	strb	r3, [r4, #1]
        state->image_num = 0;
    24b0:	2300      	movs	r3, #0
    24b2:	7123      	strb	r3, [r4, #4]
    return ALIGN_DOWN(boot_magic_off(fap) - BOOT_MAX_ALIGN, BOOT_MAX_ALIGN);
    24b4:	68aa      	ldr	r2, [r5, #8]
    24b6:	3a18      	subs	r2, #24
    24b8:	f022 0207 	bic.w	r2, r2, #7
    return boot_read_flag(fap, copy_done, boot_copy_done_off(fap));
    24bc:	3a08      	subs	r2, #8
    24be:	1ca1      	adds	r1, r4, #2
    24c0:	4628      	mov	r0, r5
    24c2:	f003 fa5f 	bl	5984 <boot_read_flag>
    if (rc) {
    24c6:	2800      	cmp	r0, #0
    24c8:	d1c8      	bne.n	245c <boot_read_swap_state+0x18>
    return boot_read_image_ok(fap, &state->image_ok);
    24ca:	1ce1      	adds	r1, r4, #3
    24cc:	4628      	mov	r0, r5
    24ce:	f003 fab3 	bl	5a38 <boot_read_image_ok>
    24d2:	e7c4      	b.n	245e <boot_read_swap_state+0x1a>
    if (memcmp(magic, BOOT_IMG_MAGIC, BOOT_MAGIC_SZ) == 0) {
    24d4:	4904      	ldr	r1, [pc, #16]	; (24e8 <boot_read_swap_state+0xa4>)
    24d6:	2210      	movs	r2, #16
    24d8:	a802      	add	r0, sp, #8
    24da:	f002 ff94 	bl	5406 <memcmp>
        return BOOT_MAGIC_GOOD;
    24de:	2800      	cmp	r0, #0
    24e0:	bf14      	ite	ne
    24e2:	2302      	movne	r3, #2
    24e4:	2301      	moveq	r3, #1
    24e6:	e7c3      	b.n	2470 <boot_read_swap_state+0x2c>
    24e8:	000061de 	.word	0x000061de

000024ec <boot_swap_type_multi>:
    return boot_write_trailer(fap, off, (const uint8_t *) &swap_info, 1);
}

int
boot_swap_type_multi(int image_index)
{
    24ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    24f0:	b085      	sub	sp, #20

    rc = BOOT_HOOK_CALL(boot_read_swap_state_primary_slot_hook,
                        BOOT_HOOK_REGULAR, image_index, &primary_slot);
    if (rc == BOOT_HOOK_REGULAR)
    {
        rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY(image_index),
    24f2:	4669      	mov	r1, sp
    24f4:	2003      	movs	r0, #3
    24f6:	f003 faa5 	bl	5a44 <boot_read_swap_state_by_id>
                                        &primary_slot);
    }
    if (rc) {
    24fa:	2800      	cmp	r0, #0
    24fc:	d136      	bne.n	256c <boot_swap_type_multi+0x80>
        return BOOT_SWAP_TYPE_PANIC;
    }

    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY(image_index),
    24fe:	a902      	add	r1, sp, #8
    2500:	2001      	movs	r0, #1
    2502:	f003 fa9f 	bl	5a44 <boot_read_swap_state_by_id>
                                    &secondary_slot);
    if (rc == BOOT_EFLASH) {
    2506:	2801      	cmp	r0, #1
    2508:	d12e      	bne.n	2568 <boot_swap_type_multi+0x7c>
        BOOT_LOG_INF("Secondary image of image pair (%d.) "
                     "is unreachable. Treat it as empty", image_index);
        secondary_slot.magic = BOOT_MAGIC_UNSET;
    250a:	2303      	movs	r3, #3
    250c:	f88d 3008 	strb.w	r3, [sp, #8]
        secondary_slot.swap_type = BOOT_SWAP_TYPE_NONE;
        secondary_slot.copy_done = BOOT_FLAG_UNSET;
        secondary_slot.image_ok = BOOT_FLAG_UNSET;
    2510:	f88d 300b 	strb.w	r3, [sp, #11]
    }

    for (i = 0; i < BOOT_SWAP_TABLES_COUNT; i++) {
        table = boot_swap_tables + i;

        if (boot_magic_compatible_check(table->magic_primary_slot,
    2514:	f89d 5000 	ldrb.w	r5, [sp]
                                        primary_slot.magic) &&
            boot_magic_compatible_check(table->magic_secondary_slot,
    2518:	f89d 6008 	ldrb.w	r6, [sp, #8]
                                        secondary_slot.magic) &&
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
                table->image_ok_primary_slot == primary_slot.image_ok) &&
    251c:	f89d 7003 	ldrb.w	r7, [sp, #3]
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
                table->image_ok_secondary_slot == secondary_slot.image_ok) &&
    2520:	f89d 800b 	ldrb.w	r8, [sp, #11]
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
                table->copy_done_primary_slot == primary_slot.copy_done)) {
    2524:	f89d 9002 	ldrb.w	r9, [sp, #2]
    2528:	4a16      	ldr	r2, [pc, #88]	; (2584 <boot_swap_type_multi+0x98>)
    252a:	2400      	movs	r4, #0
        if (boot_magic_compatible_check(table->magic_primary_slot,
    252c:	7810      	ldrb	r0, [r2, #0]
    252e:	4629      	mov	r1, r5
    2530:	f003 fa14 	bl	595c <boot_magic_compatible_check>
    2534:	b1f0      	cbz	r0, 2574 <boot_swap_type_multi+0x88>
            boot_magic_compatible_check(table->magic_secondary_slot,
    2536:	7850      	ldrb	r0, [r2, #1]
    2538:	4631      	mov	r1, r6
    253a:	f003 fa0f 	bl	595c <boot_magic_compatible_check>
                                        primary_slot.magic) &&
    253e:	b1c8      	cbz	r0, 2574 <boot_swap_type_multi+0x88>
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
    2540:	7893      	ldrb	r3, [r2, #2]
                                        secondary_slot.magic) &&
    2542:	2b04      	cmp	r3, #4
    2544:	d001      	beq.n	254a <boot_swap_type_multi+0x5e>
            (table->image_ok_primary_slot == BOOT_FLAG_ANY   ||
    2546:	42bb      	cmp	r3, r7
    2548:	d114      	bne.n	2574 <boot_swap_type_multi+0x88>
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
    254a:	78d3      	ldrb	r3, [r2, #3]
                table->image_ok_primary_slot == primary_slot.image_ok) &&
    254c:	2b04      	cmp	r3, #4
    254e:	d001      	beq.n	2554 <boot_swap_type_multi+0x68>
            (table->image_ok_secondary_slot == BOOT_FLAG_ANY ||
    2550:	4543      	cmp	r3, r8
    2552:	d10f      	bne.n	2574 <boot_swap_type_multi+0x88>
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
    2554:	7913      	ldrb	r3, [r2, #4]
                table->image_ok_secondary_slot == secondary_slot.image_ok) &&
    2556:	2b04      	cmp	r3, #4
    2558:	d10a      	bne.n	2570 <boot_swap_type_multi+0x84>
            BOOT_LOG_INF("Swap type: %s",
    255a:	7950      	ldrb	r0, [r2, #5]
                         table->swap_type == BOOT_SWAP_TYPE_TEST   ? "test"   :
                         table->swap_type == BOOT_SWAP_TYPE_PERM   ? "perm"   :
                         table->swap_type == BOOT_SWAP_TYPE_REVERT ? "revert" :
                         "BUG; can't happen");
            if (table->swap_type != BOOT_SWAP_TYPE_TEST &&
    255c:	1e83      	subs	r3, r0, #2
    255e:	2b02      	cmp	r3, #2
    2560:	d804      	bhi.n	256c <boot_swap_type_multi+0x80>
        }
    }

    BOOT_LOG_INF("Swap type: none");
    return BOOT_SWAP_TYPE_NONE;
}
    2562:	b005      	add	sp, #20
    2564:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    } else if (rc) {
    2568:	2800      	cmp	r0, #0
    256a:	d0d3      	beq.n	2514 <boot_swap_type_multi+0x28>
        return BOOT_SWAP_TYPE_PANIC;
    256c:	20ff      	movs	r0, #255	; 0xff
    256e:	e7f8      	b.n	2562 <boot_swap_type_multi+0x76>
            (table->copy_done_primary_slot == BOOT_FLAG_ANY  ||
    2570:	454b      	cmp	r3, r9
    2572:	d0f2      	beq.n	255a <boot_swap_type_multi+0x6e>
    for (i = 0; i < BOOT_SWAP_TABLES_COUNT; i++) {
    2574:	3401      	adds	r4, #1
    2576:	2c03      	cmp	r4, #3
    2578:	f102 0206 	add.w	r2, r2, #6
    257c:	d1d6      	bne.n	252c <boot_swap_type_multi+0x40>
    return BOOT_SWAP_TYPE_NONE;
    257e:	2001      	movs	r0, #1
    2580:	e7ef      	b.n	2562 <boot_swap_type_multi+0x76>
    2582:	bf00      	nop
    2584:	00006290 	.word	0x00006290

00002588 <nrf52_errata_103>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    2588:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    258c:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    2590:	2a08      	cmp	r2, #8
    2592:	d106      	bne.n	25a2 <nrf52_errata_103+0x1a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    2594:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
                switch(var2)
    2598:	2b05      	cmp	r3, #5
    259a:	d802      	bhi.n	25a2 <nrf52_errata_103+0x1a>
    259c:	4a02      	ldr	r2, [pc, #8]	; (25a8 <nrf52_errata_103+0x20>)
    259e:	5cd0      	ldrb	r0, [r2, r3]
    25a0:	4770      	bx	lr
        return false;
    25a2:	2000      	movs	r0, #0
}
    25a4:	4770      	bx	lr
    25a6:	bf00      	nop
    25a8:	000062a8 	.word	0x000062a8

000025ac <nvmc_wait>:

/* -- NVMC utility functions -- */
/* Waits until NVMC is done with the current pending action */
void nvmc_wait(void)
{
    while (NRF_NVMC->READY == NVMC_READY_READY_Busy){}
    25ac:	4a02      	ldr	r2, [pc, #8]	; (25b8 <nvmc_wait+0xc>)
    25ae:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
    25b2:	2b00      	cmp	r3, #0
    25b4:	d0fb      	beq.n	25ae <nvmc_wait+0x2>
}
    25b6:	4770      	bx	lr
    25b8:	4001e000 	.word	0x4001e000

000025bc <SystemInit>:
{
    SystemCoreClock = __SYSTEM_CLOCK_64M;
}

void SystemInit(void)
{
    25bc:	b510      	push	{r4, lr}
    #endif

    #if NRF52_ERRATA_36_ENABLE_WORKAROUND
        /* Workaround for Errata 36 "CLOCK: Some registers are not reset when expected" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_36()){
    25be:	f003 fa66 	bl	5a8e <nrf52_errata_136>
    25c2:	b140      	cbz	r0, 25d6 <SystemInit+0x1a>
            NRF_CLOCK->EVENTS_DONE = 0;
    25c4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    25c8:	2200      	movs	r2, #0
    25ca:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
            NRF_CLOCK->EVENTS_CTTO = 0;
    25ce:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
            NRF_CLOCK->CTIV = 0;
    25d2:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    #endif

    #if NRF52_ERRATA_66_ENABLE_WORKAROUND
        /* Workaround for Errata 66 "TEMP: Linearity specification not met with default settings" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_66()){
    25d6:	f003 fa5a 	bl	5a8e <nrf52_errata_136>
    25da:	2800      	cmp	r0, #0
    25dc:	d046      	beq.n	266c <SystemInit+0xb0>
            NRF_TEMP->A0 = NRF_FICR->TEMP.A0;
    25de:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
    25e2:	4b65      	ldr	r3, [pc, #404]	; (2778 <SystemInit+0x1bc>)
    25e4:	f8d2 1404 	ldr.w	r1, [r2, #1028]	; 0x404
    25e8:	f8c3 1520 	str.w	r1, [r3, #1312]	; 0x520
            NRF_TEMP->A1 = NRF_FICR->TEMP.A1;
    25ec:	f8d2 1408 	ldr.w	r1, [r2, #1032]	; 0x408
    25f0:	f8c3 1524 	str.w	r1, [r3, #1316]	; 0x524
            NRF_TEMP->A2 = NRF_FICR->TEMP.A2;
    25f4:	f8d2 140c 	ldr.w	r1, [r2, #1036]	; 0x40c
    25f8:	f8c3 1528 	str.w	r1, [r3, #1320]	; 0x528
            NRF_TEMP->A3 = NRF_FICR->TEMP.A3;
    25fc:	f8d2 1410 	ldr.w	r1, [r2, #1040]	; 0x410
    2600:	f8c3 152c 	str.w	r1, [r3, #1324]	; 0x52c
            NRF_TEMP->A4 = NRF_FICR->TEMP.A4;
    2604:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
    2608:	f8c3 1530 	str.w	r1, [r3, #1328]	; 0x530
            NRF_TEMP->A5 = NRF_FICR->TEMP.A5;
    260c:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
    2610:	f8c3 1534 	str.w	r1, [r3, #1332]	; 0x534
            NRF_TEMP->B0 = NRF_FICR->TEMP.B0;
    2614:	f8d2 141c 	ldr.w	r1, [r2, #1052]	; 0x41c
    2618:	f8c3 1540 	str.w	r1, [r3, #1344]	; 0x540
            NRF_TEMP->B1 = NRF_FICR->TEMP.B1;
    261c:	f8d2 1420 	ldr.w	r1, [r2, #1056]	; 0x420
    2620:	f8c3 1544 	str.w	r1, [r3, #1348]	; 0x544
            NRF_TEMP->B2 = NRF_FICR->TEMP.B2;
    2624:	f8d2 1424 	ldr.w	r1, [r2, #1060]	; 0x424
    2628:	f8c3 1548 	str.w	r1, [r3, #1352]	; 0x548
            NRF_TEMP->B3 = NRF_FICR->TEMP.B3;
    262c:	f8d2 1428 	ldr.w	r1, [r2, #1064]	; 0x428
    2630:	f8c3 154c 	str.w	r1, [r3, #1356]	; 0x54c
            NRF_TEMP->B4 = NRF_FICR->TEMP.B4;
    2634:	f8d2 142c 	ldr.w	r1, [r2, #1068]	; 0x42c
    2638:	f8c3 1550 	str.w	r1, [r3, #1360]	; 0x550
            NRF_TEMP->B5 = NRF_FICR->TEMP.B5;
    263c:	f8d2 1430 	ldr.w	r1, [r2, #1072]	; 0x430
    2640:	f8c3 1554 	str.w	r1, [r3, #1364]	; 0x554
            NRF_TEMP->T0 = NRF_FICR->TEMP.T0;
    2644:	f8d2 1434 	ldr.w	r1, [r2, #1076]	; 0x434
    2648:	f8c3 1560 	str.w	r1, [r3, #1376]	; 0x560
            NRF_TEMP->T1 = NRF_FICR->TEMP.T1;
    264c:	f8d2 1438 	ldr.w	r1, [r2, #1080]	; 0x438
    2650:	f8c3 1564 	str.w	r1, [r3, #1380]	; 0x564
            NRF_TEMP->T2 = NRF_FICR->TEMP.T2;
    2654:	f8d2 143c 	ldr.w	r1, [r2, #1084]	; 0x43c
    2658:	f8c3 1568 	str.w	r1, [r3, #1384]	; 0x568
            NRF_TEMP->T3 = NRF_FICR->TEMP.T3;
    265c:	f8d2 1440 	ldr.w	r1, [r2, #1088]	; 0x440
    2660:	f8c3 156c 	str.w	r1, [r3, #1388]	; 0x56c
            NRF_TEMP->T4 = NRF_FICR->TEMP.T4;
    2664:	f8d2 2444 	ldr.w	r2, [r2, #1092]	; 0x444
    2668:	f8c3 2570 	str.w	r2, [r3, #1392]	; 0x570
    #endif

    #if NRF52_ERRATA_98_ENABLE_WORKAROUND
        /* Workaround for Errata 98 "NFCT: Not able to communicate with the peer" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_98()){
    266c:	f7ff ff8c 	bl	2588 <nrf52_errata_103>
    2670:	b118      	cbz	r0, 267a <SystemInit+0xbe>
            *(volatile uint32_t *)0x4000568Cul = 0x00038148ul;
    2672:	4b42      	ldr	r3, [pc, #264]	; (277c <SystemInit+0x1c0>)
    2674:	4a42      	ldr	r2, [pc, #264]	; (2780 <SystemInit+0x1c4>)
    2676:	f8c3 268c 	str.w	r2, [r3, #1676]	; 0x68c
    #endif

    #if NRF52_ERRATA_103_ENABLE_WORKAROUND && defined(CCM_MAXPACKETSIZE_MAXPACKETSIZE_Pos)
        /* Workaround for Errata 103 "CCM: Wrong reset value of CCM MAXPACKETSIZE" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_103()){
    267a:	f7ff ff85 	bl	2588 <nrf52_errata_103>
    267e:	b118      	cbz	r0, 2688 <SystemInit+0xcc>
            NRF_CCM->MAXPACKETSIZE = 0xFBul;
    2680:	4b40      	ldr	r3, [pc, #256]	; (2784 <SystemInit+0x1c8>)
    2682:	22fb      	movs	r2, #251	; 0xfb
    2684:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    #endif

    #if NRF52_ERRATA_115_ENABLE_WORKAROUND
        /* Workaround for Errata 115 "RAM: RAM content cannot be trusted upon waking up from System ON Idle or System OFF mode" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_115()){
    2688:	f7ff ff7e 	bl	2588 <nrf52_errata_103>
    268c:	b170      	cbz	r0, 26ac <SystemInit+0xf0>
            *(volatile uint32_t *)0x40000EE4 = (*(volatile uint32_t *)0x40000EE4 & 0xFFFFFFF0) | (*(uint32_t *)0x10000258 & 0x0000000F);
    268e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    2692:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    2696:	f8d1 2ee4 	ldr.w	r2, [r1, #3812]	; 0xee4
    269a:	f8d3 3258 	ldr.w	r3, [r3, #600]	; 0x258
    269e:	f022 020f 	bic.w	r2, r2, #15
    26a2:	f003 030f 	and.w	r3, r3, #15
    26a6:	4313      	orrs	r3, r2
    26a8:	f8c1 3ee4 	str.w	r3, [r1, #3812]	; 0xee4
    #endif

    #if NRF52_ERRATA_120_ENABLE_WORKAROUND
        /* Workaround for Errata 120 "QSPI: Data read or written is corrupted" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_120()){
    26ac:	f7ff ff6c 	bl	2588 <nrf52_errata_103>
    26b0:	b120      	cbz	r0, 26bc <SystemInit+0x100>
            *(volatile uint32_t *)0x40029640ul = 0x200ul;
    26b2:	4b35      	ldr	r3, [pc, #212]	; (2788 <SystemInit+0x1cc>)
    26b4:	f44f 7200 	mov.w	r2, #512	; 0x200
    26b8:	f8c3 2640 	str.w	r2, [r3, #1600]	; 0x640
    #endif

    #if NRF52_ERRATA_136_ENABLE_WORKAROUND
        /* Workaround for Errata 136 "System: Bits in RESETREAS are set when they should not be" found at the Errata document
           for your device located at https://infocenter.nordicsemi.com/index.jsp  */
        if (nrf52_errata_136()){
    26bc:	f003 f9e7 	bl	5a8e <nrf52_errata_136>
    26c0:	b148      	cbz	r0, 26d6 <SystemInit+0x11a>
            if (NRF_POWER->RESETREAS & POWER_RESETREAS_RESETPIN_Msk){
    26c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    26c6:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
    26ca:	07d2      	lsls	r2, r2, #31
                NRF_POWER->RESETREAS =  ~POWER_RESETREAS_RESETPIN_Msk;
    26cc:	bf44      	itt	mi
    26ce:	f06f 0201 	mvnmi.w	r2, #1
    26d2:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400

    /* Enable the FPU if the compiler used floating point unit instructions. __FPU_USED is a MACRO defined by the
     * compiler. Since the FPU consumes energy, remember to disable FPU use in the compiler if floating point unit
     * operations are not used in your code. */
    #if (__FPU_USED == 1)
        SCB->CPACR |= (3UL << 20) | (3UL << 22);
    26d6:	4a2d      	ldr	r2, [pc, #180]	; (278c <SystemInit+0x1d0>)
    26d8:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
    26dc:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
    26e0:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
  __ASM volatile ("dsb 0xF":::"memory");
    26e4:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
    26e8:	f3bf 8f6f 	isb	sy
         || defined (NRF52820_XXAA) || defined (DEVELOP_IN_NRF52820)\
         || defined (NRF52832_XXAA) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52832_XXAB) || defined (DEVELOP_IN_NRF52832)\
         || defined (NRF52833_XXAA) || defined (DEVELOP_IN_NRF52833)\
         || defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    26ec:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                        return true;
                }
            }
        #endif
        #if defined (NRF52840_XXAA) || defined (DEVELOP_IN_NRF52840)
            if (var1 == 0x08)
    26f0:	f8d3 2130 	ldr.w	r2, [r3, #304]	; 0x130
    26f4:	2a08      	cmp	r2, #8
    26f6:	d10e      	bne.n	2716 <SystemInit+0x15a>
            uint32_t var2 = *(uint32_t *)0x10000134ul;
    26f8:	f8d3 3134 	ldr.w	r3, [r3, #308]	; 0x134
            {
                switch(var2)
    26fc:	2b05      	cmp	r3, #5
    26fe:	d802      	bhi.n	2706 <SystemInit+0x14a>
            {
                /* Prevent processor from unlocking APPROTECT soft branch after this point. */
                NRF_APPROTECT->FORCEPROTECT = APPROTECT_FORCEPROTECT_FORCEPROTECT_Force;
            }
        #else
            if (nrf52_configuration_249())
    2700:	4a23      	ldr	r2, [pc, #140]	; (2790 <SystemInit+0x1d4>)
    2702:	5cd3      	ldrb	r3, [r2, r3]
    2704:	b13b      	cbz	r3, 2716 <SystemInit+0x15a>
            {
                /* Load APPROTECT soft branch from UICR.
                   If UICR->APPROTECT is disabled, POWER->APPROTECT will be disabled. */
                NRF_APPROTECT->DISABLE = NRF_UICR->APPROTECT;
    2706:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    270a:	f8d3 2208 	ldr.w	r2, [r3, #520]	; 0x208
    270e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2712:	f8c3 2558 	str.w	r2, [r3, #1368]	; 0x558

    /* Configure GPIO pads as pPin Reset pin if Pin Reset capabilities desired. If CONFIG_GPIO_AS_PINRESET is not
      defined, pin reset will not be available. One GPIO (see Product Specification to see which one) will then be
      reserved for PinReset and not available as normal GPIO. */
    #if defined (CONFIG_GPIO_AS_PINRESET)
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    2716:	f04f 2310 	mov.w	r3, #268439552	; 0x10001000
    271a:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    271e:	2a00      	cmp	r2, #0
    2720:	db03      	blt.n	272a <SystemInit+0x16e>
            ((NRF_UICR->PSELRESET[1] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos))){
    2722:	f8d3 3204 	ldr.w	r3, [r3, #516]	; 0x204
        if (((NRF_UICR->PSELRESET[0] & UICR_PSELRESET_CONNECT_Msk) != (UICR_PSELRESET_CONNECT_Connected << UICR_PSELRESET_CONNECT_Pos)) ||
    2726:	2b00      	cmp	r3, #0
    2728:	da22      	bge.n	2770 <SystemInit+0x1b4>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    272a:	491a      	ldr	r1, [pc, #104]	; (2794 <SystemInit+0x1d8>)
    272c:	2301      	movs	r3, #1
            nvmc_config(NVMC_CONFIG_WEN_Wen);
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    272e:	f04f 2010 	mov.w	r0, #268439552	; 0x10001000
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    2732:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    2736:	2412      	movs	r4, #18
    nvmc_wait();
    2738:	f7ff ff38 	bl	25ac <nvmc_wait>
            NRF_UICR->PSELRESET[0] = RESET_PIN;
    273c:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
            nvmc_wait();
    2740:	f7ff ff34 	bl	25ac <nvmc_wait>
            NRF_UICR->PSELRESET[1] = RESET_PIN;
    2744:	f8c0 4204 	str.w	r4, [r0, #516]	; 0x204
            nvmc_wait();
    2748:	f7ff ff30 	bl	25ac <nvmc_wait>
    NRF_NVMC->CONFIG = mode << NVMC_CONFIG_WEN_Pos;
    274c:	2300      	movs	r3, #0
    274e:	f8c1 3504 	str.w	r3, [r1, #1284]	; 0x504
    nvmc_wait();
    2752:	f7ff ff2b 	bl	25ac <nvmc_wait>
  __ASM volatile ("dsb 0xF":::"memory");
    2756:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
    275a:	490c      	ldr	r1, [pc, #48]	; (278c <SystemInit+0x1d0>)
    275c:	4b0e      	ldr	r3, [pc, #56]	; (2798 <SystemInit+0x1dc>)
    275e:	68ca      	ldr	r2, [r1, #12]
    2760:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    2764:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
    2766:	60cb      	str	r3, [r1, #12]
    2768:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
    276c:	bf00      	nop
  for(;;)                                                           /* wait until reset */
    276e:	e7fd      	b.n	276c <SystemInit+0x1b0>
    SystemCoreClock = __SYSTEM_CLOCK_64M;
    2770:	4b0a      	ldr	r3, [pc, #40]	; (279c <SystemInit+0x1e0>)
    2772:	4a0b      	ldr	r2, [pc, #44]	; (27a0 <SystemInit+0x1e4>)
    2774:	601a      	str	r2, [r3, #0]
            NVIC_SystemReset();
        }
    #endif

    SystemCoreClockUpdate();
}
    2776:	bd10      	pop	{r4, pc}
    2778:	4000c000 	.word	0x4000c000
    277c:	40005000 	.word	0x40005000
    2780:	00038148 	.word	0x00038148
    2784:	4000f000 	.word	0x4000f000
    2788:	40029000 	.word	0x40029000
    278c:	e000ed00 	.word	0xe000ed00
    2790:	000062a2 	.word	0x000062a2
    2794:	4001e000 	.word	0x4001e000
    2798:	05fa0004 	.word	0x05fa0004
    279c:	2000000c 	.word	0x2000000c
    27a0:	03d09000 	.word	0x03d09000

000027a4 <clock_stop>:
    CoreDebug->DEMCR = core_debug;
}
#endif // NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_132)

static void clock_stop(nrf_clock_domain_t domain)
{
    27a4:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    switch (domain)
    27a6:	4604      	mov	r4, r0
    27a8:	b118      	cbz	r0, 27b2 <clock_stop+0xe>
    27aa:	2801      	cmp	r0, #1
    27ac:	d029      	beq.n	2802 <CONFIG_MAIN_STACK_SIZE+0x2>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    {
            m_clock_cb.hfclk_started = false;
    }
#endif
}
    27ae:	b003      	add	sp, #12
    27b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
    p_reg->INTENCLR = mask;
    27b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    27b6:	2202      	movs	r2, #2
    27b8:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    27bc:	f8c3 0104 	str.w	r0, [r3, #260]	; 0x104
    27c0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    27c4:	2201      	movs	r2, #1
    27c6:	60da      	str	r2, [r3, #12]
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    27c8:	2301      	movs	r3, #1
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
    27ca:	429c      	cmp	r4, r3
    nrf_clock_hfclk_t clk_src = NRF_CLOCK_HFCLK_HIGH_ACCURACY;
    27cc:	f88d 3007 	strb.w	r3, [sp, #7]
    nrf_clock_hfclk_t *p_clk_src = (domain == NRF_CLOCK_DOMAIN_HFCLK) ? &clk_src : NULL;
    27d0:	bf14      	ite	ne
    27d2:	2500      	movne	r5, #0
    27d4:	f10d 0507 	addeq.w	r5, sp, #7
    27d8:	f242 7710 	movw	r7, #10000	; 0x2710
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    27dc:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
    switch (domain)
    27e0:	b1d4      	cbz	r4, 2818 <CONFIG_MAIN_STACK_SIZE+0x18>
    27e2:	2c01      	cmp	r4, #1
    27e4:	d1e3      	bne.n	27ae <clock_stop+0xa>
            if (p_clk_src != NULL)
    27e6:	b125      	cbz	r5, 27f2 <clock_stop+0x4e>
                    (nrf_clock_hfclk_t)((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_SRC_Msk)
    27e8:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
    27ec:	f003 0301 	and.w	r3, r3, #1
                (*(nrf_clock_hfclk_t *)p_clk_src) =
    27f0:	702b      	strb	r3, [r5, #0]
            if ((p_reg->HFCLKSTAT & CLOCK_HFCLKSTAT_STATE_Msk)
    27f2:	f8d6 340c 	ldr.w	r3, [r6, #1036]	; 0x40c
    27f6:	03db      	lsls	r3, r3, #15
    27f8:	d418      	bmi.n	282c <CONFIG_MAIN_STACK_SIZE+0x2c>
            m_clock_cb.hfclk_started = false;
    27fa:	4b13      	ldr	r3, [pc, #76]	; (2848 <CONFIG_MAIN_STACK_SIZE+0x48>)
    27fc:	2200      	movs	r2, #0
    27fe:	715a      	strb	r2, [r3, #5]
    2800:	e7d5      	b.n	27ae <clock_stop+0xa>
    p_reg->INTENCLR = mask;
    2802:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2806:	2200      	movs	r2, #0
    p_reg->INTENCLR = mask;
    2808:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    280c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    2810:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2814:	6058      	str	r0, [r3, #4]
}
    2816:	e7d7      	b.n	27c8 <clock_stop+0x24>
            if (p_clk_src != NULL)
    2818:	b125      	cbz	r5, 2824 <CONFIG_MAIN_STACK_SIZE+0x24>
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    281a:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    281e:	f003 0303 	and.w	r3, r3, #3
                (*(nrf_clock_lfclk_t *)p_clk_src) =
    2822:	602b      	str	r3, [r5, #0]
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    2824:	f8d6 3418 	ldr.w	r3, [r6, #1048]	; 0x418
    2828:	03da      	lsls	r2, r3, #15
    282a:	d5c0      	bpl.n	27ae <clock_stop+0xa>
    NRFX_WAIT_FOR((!nrfx_clock_is_running(domain, p_clk_src) ||
    282c:	b92d      	cbnz	r5, 283a <CONFIG_MAIN_STACK_SIZE+0x3a>
    282e:	2001      	movs	r0, #1
    2830:	f003 f937 	bl	5aa2 <nrfx_busy_wait>
    2834:	3f01      	subs	r7, #1
    2836:	d1d3      	bne.n	27e0 <clock_stop+0x3c>
    2838:	e003      	b.n	2842 <CONFIG_MAIN_STACK_SIZE+0x42>
    283a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    283e:	2b01      	cmp	r3, #1
    2840:	d0f5      	beq.n	282e <CONFIG_MAIN_STACK_SIZE+0x2e>
    if (domain == NRF_CLOCK_DOMAIN_HFCLK)
    2842:	2c01      	cmp	r4, #1
    2844:	d0d9      	beq.n	27fa <clock_stop+0x56>
    2846:	e7b2      	b.n	27ae <clock_stop+0xa>
    2848:	2000159c 	.word	0x2000159c

0000284c <nrfx_clock_init>:
nrfx_err_t nrfx_clock_init(nrfx_clock_event_handler_t event_handler)
{
    NRFX_ASSERT(event_handler);

    nrfx_err_t err_code = NRFX_SUCCESS;
    if (m_clock_cb.module_initialized)
    284c:	4b04      	ldr	r3, [pc, #16]	; (2860 <nrfx_clock_init+0x14>)
    284e:	791a      	ldrb	r2, [r3, #4]
    2850:	b922      	cbnz	r2, 285c <nrfx_clock_init+0x10>
    {
#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LF_CAL_ENABLED)
        m_clock_cb.cal_state = CAL_STATE_IDLE;
#endif
        m_clock_cb.event_handler = event_handler;
        m_clock_cb.module_initialized = true;
    2852:	2201      	movs	r2, #1
        m_clock_cb.event_handler = event_handler;
    2854:	6018      	str	r0, [r3, #0]
        m_clock_cb.module_initialized = true;
    2856:	809a      	strh	r2, [r3, #4]
    nrfx_err_t err_code = NRFX_SUCCESS;
    2858:	4802      	ldr	r0, [pc, #8]	; (2864 <nrfx_clock_init+0x18>)
    285a:	4770      	bx	lr
        err_code = NRFX_ERROR_ALREADY_INITIALIZED;
    285c:	4802      	ldr	r0, [pc, #8]	; (2868 <nrfx_clock_init+0x1c>)
#endif
    }

    NRFX_LOG_INFO("Function: %s, error code: %s.", __func__, NRFX_LOG_ERROR_STRING_GET(err_code));
    return err_code;
}
    285e:	4770      	bx	lr
    2860:	2000159c 	.word	0x2000159c
    2864:	0bad0000 	.word	0x0bad0000
    2868:	0bad000c 	.word	0x0bad000c

0000286c <nrfx_power_clock_irq_handler>:
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    286c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    }
}
#endif

void nrfx_clock_irq_handler(void)
{
    2870:	b510      	push	{r4, lr}
    2872:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED))
    2876:	b16a      	cbz	r2, 2894 <nrfx_power_clock_irq_handler+0x28>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2878:	2200      	movs	r2, #0
    287a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    287e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENCLR = mask;
    2882:	2201      	movs	r2, #1
    2884:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
        nrf_clock_event_clear(NRF_CLOCK, NRF_CLOCK_EVENT_HFCLKSTARTED);
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_HFCLKSTARTED");
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF_STARTED_MASK);

#if NRFX_CHECK(USE_WORKAROUND_FOR_ANOMALY_201)
        if (!m_clock_cb.hfclk_started)
    2888:	4b11      	ldr	r3, [pc, #68]	; (28d0 <nrfx_power_clock_irq_handler+0x64>)
    288a:	7958      	ldrb	r0, [r3, #5]
    288c:	b910      	cbnz	r0, 2894 <nrfx_power_clock_irq_handler+0x28>
        {
            m_clock_cb.hfclk_started = true;
    288e:	715a      	strb	r2, [r3, #5]
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
    2890:	681b      	ldr	r3, [r3, #0]
    2892:	4798      	blx	r3
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
    2894:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    2898:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
        }
#else
        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK_STARTED);
#endif
    }
    if (nrf_clock_event_check(NRF_CLOCK, NRF_CLOCK_EVENT_LFCLKSTARTED))
    289c:	b172      	cbz	r2, 28bc <nrfx_power_clock_irq_handler+0x50>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    289e:	2200      	movs	r2, #0
    28a0:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
    28a4:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    28a8:	f8d3 2418 	ldr.w	r2, [r3, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    28ac:	f8d3 1418 	ldr.w	r1, [r3, #1048]	; 0x418
        NRFX_LOG_DEBUG("Event: NRF_CLOCK_EVENT_LFCLKSTARTED");

#if NRFX_CHECK(NRFX_CLOCK_CONFIG_LFXO_TWO_STAGE_ENABLED)
        nrf_clock_lfclk_t lfclksrc;
        (void)nrf_clock_is_running(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK, &lfclksrc);
        if (lfclksrc == NRF_CLOCK_LFCLK_RC)
    28b0:	0792      	lsls	r2, r2, #30
    28b2:	d104      	bne.n	28be <nrfx_power_clock_irq_handler+0x52>
    p_reg->LFCLKSRC = (uint32_t)(source);
    28b4:	2201      	movs	r2, #1
    28b6:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    28ba:	609a      	str	r2, [r3, #8]
        nrf_clock_int_disable(NRF_CLOCK, NRF_CLOCK_INT_HF192M_STARTED_MASK);

        m_clock_cb.event_handler(NRFX_CLOCK_EVT_HFCLK192M_STARTED);
    }
#endif
}
    28bc:	bd10      	pop	{r4, pc}
    p_reg->INTENCLR = mask;
    28be:	2202      	movs	r2, #2
    28c0:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    28c4:	4b02      	ldr	r3, [pc, #8]	; (28d0 <nrfx_power_clock_irq_handler+0x64>)
}
    28c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
            m_clock_cb.event_handler(NRFX_CLOCK_EVT_LFCLK_STARTED);
    28ca:	681b      	ldr	r3, [r3, #0]
    28cc:	2001      	movs	r0, #1
    28ce:	4718      	bx	r3
    28d0:	2000159c 	.word	0x2000159c

000028d4 <nvmc_word_write>:
    28d4:	4a04      	ldr	r2, [pc, #16]	; (28e8 <nvmc_word_write+0x14>)
    28d6:	f8d2 3400 	ldr.w	r3, [r2, #1024]	; 0x400
{
#if defined(NRF9160_XXAA)
    while (!nrf_nvmc_write_ready_check(NRF_NVMC))
    {}
#else
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    28da:	07db      	lsls	r3, r3, #31
    28dc:	d5fb      	bpl.n	28d6 <nvmc_word_write+0x2>
    {}
#endif

    *(volatile uint32_t *)addr = value;
    28de:	6001      	str	r1, [r0, #0]
  __ASM volatile ("dmb 0xF":::"memory");
    28e0:	f3bf 8f5f 	dmb	sy
    __DMB();
}
    28e4:	4770      	bx	lr
    28e6:	bf00      	nop
    28e8:	4001e000 	.word	0x4001e000

000028ec <nrfx_nvmc_page_erase>:
NRF_STATIC_INLINE uint32_t nrf_ficr_codepagesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODEPAGESIZE_CODEPAGESIZE_Msk)
    return p_reg->INFO.CODEPAGESIZE;
#else
    return p_reg->CODEPAGESIZE;
    28ec:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    28f0:	691a      	ldr	r2, [r3, #16]
    return !(addr % flash_page_size_get());
    28f2:	fbb0 f3f2 	udiv	r3, r0, r2
    28f6:	fb02 0313 	mls	r3, r2, r3, r0

nrfx_err_t nrfx_nvmc_page_erase(uint32_t addr)
{
    NRFX_ASSERT(is_valid_address(addr, false));

    if (!is_page_aligned_check(addr))
    28fa:	b973      	cbnz	r3, 291a <nrfx_nvmc_page_erase+0x2e>
#endif

NRF_STATIC_INLINE void nrf_nvmc_mode_set(NRF_NVMC_Type * p_reg,
                                         nrf_nvmc_mode_t mode)
{
    p_reg->CONFIG = (uint32_t)mode;
    28fc:	4b08      	ldr	r3, [pc, #32]	; (2920 <nrfx_nvmc_page_erase+0x34>)
    28fe:	2202      	movs	r2, #2
    2900:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    else
    {
        p_reg->ERASEPCR1 = page_addr;
    }
#elif defined(NRF52_SERIES)
    p_reg->ERASEPAGE = page_addr;
    2904:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
    return (bool)(p_reg->READY & NVMC_READY_READY_Msk);
    2908:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
        return NRFX_ERROR_INVALID_ADDR;
    }

    nvmc_erase_mode_set();
    nrf_nvmc_page_erase_start(NRF_NVMC, addr);
    while (!nrf_nvmc_ready_check(NRF_NVMC))
    290c:	07d2      	lsls	r2, r2, #31
    290e:	d5fb      	bpl.n	2908 <nrfx_nvmc_page_erase+0x1c>
    p_reg->CONFIG = (uint32_t)mode;
    2910:	2200      	movs	r2, #0
    {}
    nvmc_readonly_mode_set();

    return NRFX_SUCCESS;
    2912:	4804      	ldr	r0, [pc, #16]	; (2924 <nrfx_nvmc_page_erase+0x38>)
    2914:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    2918:	4770      	bx	lr
        return NRFX_ERROR_INVALID_ADDR;
    291a:	4803      	ldr	r0, [pc, #12]	; (2928 <nrfx_nvmc_page_erase+0x3c>)
}
    291c:	4770      	bx	lr
    291e:	bf00      	nop
    2920:	4001e000 	.word	0x4001e000
    2924:	0bad0000 	.word	0x0bad0000
    2928:	0bad000a 	.word	0x0bad000a

0000292c <nrfx_nvmc_word_write>:

    nrfx_nvmc_word_write(aligned_addr, partial_word_create(addr, (const uint8_t *)&value, 2));
}

void nrfx_nvmc_word_write(uint32_t addr, uint32_t value)
{
    292c:	b510      	push	{r4, lr}
    292e:	4c05      	ldr	r4, [pc, #20]	; (2944 <nrfx_nvmc_word_write+0x18>)
    2930:	2301      	movs	r3, #1
    2932:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504
    NRFX_ASSERT(is_valid_address(addr, true));
    NRFX_ASSERT(nrfx_is_word_aligned((void const *)addr));

    nvmc_write_mode_set();

    nvmc_word_write(addr, value);
    2936:	f7ff ffcd 	bl	28d4 <nvmc_word_write>
    293a:	2300      	movs	r3, #0
    293c:	f8c4 3504 	str.w	r3, [r4, #1284]	; 0x504

    nvmc_readonly_mode_set();
}
    2940:	bd10      	pop	{r4, pc}
    2942:	bf00      	nop
    2944:	4001e000 	.word	0x4001e000

00002948 <nrf_gpio_pin_port_decode>:
    uint32_t pin_number = *p_pin;
    2948:	6803      	ldr	r3, [r0, #0]
    *p_pin = pin_number & 0x1F;
    294a:	f003 021f 	and.w	r2, r3, #31
    return pin_number >> 5;
    294e:	095b      	lsrs	r3, r3, #5
        case 1: return NRF_P1;
    2950:	2b01      	cmp	r3, #1
    *p_pin = pin_number & 0x1F;
    2952:	6002      	str	r2, [r0, #0]
}
    2954:	4802      	ldr	r0, [pc, #8]	; (2960 <nrf_gpio_pin_port_decode+0x18>)
    2956:	bf18      	it	ne
    2958:	f04f 40a0 	movne.w	r0, #1342177280	; 0x50000000
    295c:	4770      	bx	lr
    295e:	bf00      	nop
    2960:	50000300 	.word	0x50000300

00002964 <qspi_xfer>:

static nrfx_err_t qspi_xfer(void *            p_buffer,
                            size_t            length,
                            uint32_t          address,
                            nrfx_qspi_state_t desired_state)
{
    2964:	b570      	push	{r4, r5, r6, lr}
    2966:	f000 4460 	and.w	r4, r0, #3758096384	; 0xe0000000
    NRFX_ASSERT(m_cb.state != NRFX_QSPI_STATE_UNINITIALIZED);
    NRFX_ASSERT(p_buffer != NULL);

    if (!nrfx_is_in_ram(p_buffer) || !nrfx_is_word_aligned(p_buffer))
    296a:	f1b4 5f00 	cmp.w	r4, #536870912	; 0x20000000
    296e:	d14b      	bne.n	2a08 <qspi_xfer+0xa4>
    2970:	0784      	lsls	r4, r0, #30
    2972:	d149      	bne.n	2a08 <qspi_xfer+0xa4>
    {
        return NRFX_ERROR_INVALID_ADDR;
    }

    if ((m_cb.state != NRFX_QSPI_STATE_IDLE) &&
    2974:	4c26      	ldr	r4, [pc, #152]	; (2a10 <qspi_xfer+0xac>)
    2976:	f894 5030 	ldrb.w	r5, [r4, #48]	; 0x30
    297a:	2d01      	cmp	r5, #1
    297c:	d001      	beq.n	2982 <qspi_xfer+0x1e>
    297e:	429d      	cmp	r5, r3
    2980:	d144      	bne.n	2a0c <qspi_xfer+0xa8>
    {
        return NRFX_ERROR_BUSY;
    }

    bool is_first_buffer = false;
    if (m_cb.handler)
    2982:	6825      	ldr	r5, [r4, #0]
    2984:	2d00      	cmp	r5, #0
    2986:	d02e      	beq.n	29e6 <qspi_xfer+0x82>
    {
        if (m_cb.p_buffer_primary)
    2988:	68a6      	ldr	r6, [r4, #8]
    298a:	b32e      	cbz	r6, 29d8 <qspi_xfer+0x74>
        {
            m_cb.p_buffer_secondary = p_buffer;
    298c:	60e0      	str	r0, [r4, #12]
            m_cb.size_secondary     = length;
    298e:	6161      	str	r1, [r4, #20]
            m_cb.addr_secondary     = address;
    2990:	61e2      	str	r2, [r4, #28]
    bool is_first_buffer = false;
    2992:	2600      	movs	r6, #0
            is_first_buffer = true;
        }
    }

    nrf_qspi_task_t task;
    if (desired_state == NRFX_QSPI_STATE_WRITE)
    2994:	4c1f      	ldr	r4, [pc, #124]	; (2a14 <qspi_xfer+0xb0>)
    2996:	2b02      	cmp	r3, #2
NRF_STATIC_INLINE void nrf_qspi_write_buffer_set(NRF_QSPI_Type * p_reg,
                                                 void const    * p_buffer,
                                                 uint32_t        length,
                                                 uint32_t        dest_addr)
{
    p_reg->WRITE.DST = dest_addr;
    2998:	bf0b      	itete	eq
    299a:	f8c4 2510 	streq.w	r2, [r4, #1296]	; 0x510
NRF_STATIC_INLINE void nrf_qspi_read_buffer_set(NRF_QSPI_Type * p_reg,
                                                void          * p_buffer,
                                                uint32_t        length,
                                                uint32_t        src_addr)
{
    p_reg->READ.SRC = src_addr;
    299e:	f8c4 2504 	strne.w	r2, [r4, #1284]	; 0x504
    p_reg->WRITE.SRC = (uint32_t) p_buffer;
    29a2:	f8c4 0514 	streq.w	r0, [r4, #1300]	; 0x514
    p_reg->READ.DST = (uint32_t) p_buffer;
    29a6:	f8c4 0508 	strne.w	r0, [r4, #1288]	; 0x508
    p_reg->WRITE.CNT = length;
    29aa:	bf07      	ittee	eq
    29ac:	f8c4 1518 	streq.w	r1, [r4, #1304]	; 0x518
    {
        nrf_qspi_write_buffer_set(NRF_QSPI, p_buffer, length, address);
        task = NRF_QSPI_TASK_WRITESTART;
    29b0:	2308      	moveq	r3, #8
    p_reg->READ.CNT = length;
    29b2:	f8c4 150c 	strne.w	r1, [r4, #1292]	; 0x50c
    }
    else
    {
        nrf_qspi_read_buffer_set(NRF_QSPI, p_buffer, length, address);
        task = NRF_QSPI_TASK_READSTART;
    29b6:	2304      	movne	r3, #4
    }

    if (!m_cb.handler)
    29b8:	b9bd      	cbnz	r5, 29ea <qspi_xfer+0x86>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    29ba:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    29be:	f503 3324 	add.w	r3, r3, #167936	; 0x29000
    29c2:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    29c4:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    29c8:	601a      	str	r2, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    29ca:	4a12      	ldr	r2, [pc, #72]	; (2a14 <qspi_xfer+0xb0>)
    29cc:	f8d2 3100 	ldr.w	r3, [r2, #256]	; 0x100
    {
        nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);
        nrf_qspi_task_trigger(NRF_QSPI, task);
        while (!nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY))
    29d0:	2b00      	cmp	r3, #0
    29d2:	d0fb      	beq.n	29cc <qspi_xfer+0x68>
        nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);
        nrf_qspi_int_enable(NRF_QSPI, NRF_QSPI_INT_READY_MASK);
        nrf_qspi_task_trigger(NRF_QSPI, task);
    }

    return NRFX_SUCCESS;
    29d4:	4810      	ldr	r0, [pc, #64]	; (2a18 <qspi_xfer+0xb4>)
}
    29d6:	bd70      	pop	{r4, r5, r6, pc}
            m_cb.p_buffer_primary = p_buffer;
    29d8:	60a0      	str	r0, [r4, #8]
            m_cb.size_primary     = length;
    29da:	6121      	str	r1, [r4, #16]
            m_cb.addr_primary     = address;
    29dc:	61a2      	str	r2, [r4, #24]
            m_cb.state = desired_state;
    29de:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
            is_first_buffer = true;
    29e2:	2601      	movs	r6, #1
    29e4:	e7d6      	b.n	2994 <qspi_xfer+0x30>
    bool is_first_buffer = false;
    29e6:	462e      	mov	r6, r5
    29e8:	e7d4      	b.n	2994 <qspi_xfer+0x30>
    else if (is_first_buffer)
    29ea:	2e00      	cmp	r6, #0
    29ec:	d0f2      	beq.n	29d4 <qspi_xfer+0x70>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    29ee:	4909      	ldr	r1, [pc, #36]	; (2a14 <qspi_xfer+0xb0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    29f0:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    29f4:	2200      	movs	r2, #0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    29f6:	f503 3324 	add.w	r3, r3, #167936	; 0x29000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    29fa:	f8c1 2100 	str.w	r2, [r1, #256]	; 0x100
    p_reg->INTENSET = mask;
    29fe:	2201      	movs	r2, #1
    2a00:	f8c1 2304 	str.w	r2, [r1, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2a04:	601a      	str	r2, [r3, #0]
    2a06:	e7e5      	b.n	29d4 <qspi_xfer+0x70>
        return NRFX_ERROR_INVALID_ADDR;
    2a08:	4804      	ldr	r0, [pc, #16]	; (2a1c <qspi_xfer+0xb8>)
    2a0a:	e7e4      	b.n	29d6 <qspi_xfer+0x72>
        return NRFX_ERROR_BUSY;
    2a0c:	4804      	ldr	r0, [pc, #16]	; (2a20 <qspi_xfer+0xbc>)
    2a0e:	e7e2      	b.n	29d6 <qspi_xfer+0x72>
    2a10:	200015a4 	.word	0x200015a4
    2a14:	40029000 	.word	0x40029000
    2a18:	0bad0000 	.word	0x0bad0000
    2a1c:	0bad000a 	.word	0x0bad000a
    2a20:	0bad000b 	.word	0x0bad000b

00002a24 <qspi_ready_wait>:
        nrf_gpio_cfg_default(pins.io3_pin);
    }
}

static nrfx_err_t qspi_ready_wait(void)
{
    2a24:	b538      	push	{r3, r4, r5, lr}
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2a26:	4d07      	ldr	r5, [pc, #28]	; (2a44 <qspi_ready_wait+0x20>)
    2a28:	2464      	movs	r4, #100	; 0x64
    2a2a:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
    bool result;
    NRFX_WAIT_FOR(nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY),
    2a2e:	b933      	cbnz	r3, 2a3e <qspi_ready_wait+0x1a>
    2a30:	200a      	movs	r0, #10
    2a32:	f003 f836 	bl	5aa2 <nrfx_busy_wait>
    2a36:	3c01      	subs	r4, #1
    2a38:	d1f7      	bne.n	2a2a <qspi_ready_wait+0x6>
                                       QSPI_DEF_WAIT_ATTEMPTS,
                                       QSPI_DEF_WAIT_TIME_US,
                                       result);
    if (!result)
    {
        return NRFX_ERROR_TIMEOUT;
    2a3a:	4803      	ldr	r0, [pc, #12]	; (2a48 <qspi_ready_wait+0x24>)
    }

    return NRFX_SUCCESS;
}
    2a3c:	bd38      	pop	{r3, r4, r5, pc}
    return NRFX_SUCCESS;
    2a3e:	4803      	ldr	r0, [pc, #12]	; (2a4c <qspi_ready_wait+0x28>)
    2a40:	e7fc      	b.n	2a3c <qspi_ready_wait+0x18>
    2a42:	bf00      	nop
    2a44:	40029000 	.word	0x40029000
    2a48:	0bad0007 	.word	0x0bad0007
    2a4c:	0bad0000 	.word	0x0bad0000

00002a50 <qspi_event_xfer_handle.constprop.0>:
}
#endif

static void qspi_event_xfer_handle(nrfx_qspi_evt_ext_xfer_t * p_xfer)
{
    p_xfer->p_buffer = (uint8_t *)m_cb.p_buffer_primary;
    2a50:	4b08      	ldr	r3, [pc, #32]	; (2a74 <qspi_event_xfer_handle.constprop.0+0x24>)
    2a52:	689a      	ldr	r2, [r3, #8]
    2a54:	625a      	str	r2, [r3, #36]	; 0x24
    p_xfer->size     = m_cb.size_primary;
    2a56:	691a      	ldr	r2, [r3, #16]
    2a58:	629a      	str	r2, [r3, #40]	; 0x28
    p_xfer->addr     = m_cb.addr_primary;
    2a5a:	699a      	ldr	r2, [r3, #24]
    2a5c:	62da      	str	r2, [r3, #44]	; 0x2c
    if (m_cb.p_buffer_secondary)
    2a5e:	68da      	ldr	r2, [r3, #12]
    {
        m_cb.p_buffer_primary = m_cb.p_buffer_secondary;
    2a60:	609a      	str	r2, [r3, #8]
    if (m_cb.p_buffer_secondary)
    2a62:	b132      	cbz	r2, 2a72 <qspi_event_xfer_handle.constprop.0+0x22>
        m_cb.size_primary     = m_cb.size_secondary;
    2a64:	695a      	ldr	r2, [r3, #20]
    2a66:	611a      	str	r2, [r3, #16]
        m_cb.addr_primary     = m_cb.addr_secondary;
    2a68:	69da      	ldr	r2, [r3, #28]
    2a6a:	619a      	str	r2, [r3, #24]

        m_cb.p_buffer_secondary = NULL;
    2a6c:	2200      	movs	r2, #0
    2a6e:	60da      	str	r2, [r3, #12]
    2a70:	4770      	bx	lr
    }
    else
    {
        m_cb.p_buffer_primary = NULL;
    }
}
    2a72:	4770      	bx	lr
    2a74:	200015a4 	.word	0x200015a4

00002a78 <nrf_qspi_cinstrdata_get.constprop.0>:
                                               nrf_qspi_cinstr_len_t length,
                                               void *                p_rx_data)
{
    uint8_t *p_rx_data_8 = (uint8_t *) p_rx_data;

    uint32_t reg1 = p_reg->CINSTRDAT1;
    2a78:	4b0e      	ldr	r3, [pc, #56]	; (2ab4 <nrf_qspi_cinstrdata_get.constprop.0+0x3c>)
    uint32_t reg0 = p_reg->CINSTRDAT0;
    switch (length)
    2a7a:	3802      	subs	r0, #2
    uint32_t reg1 = p_reg->CINSTRDAT1;
    2a7c:	f8d3 263c 	ldr.w	r2, [r3, #1596]	; 0x63c
    uint32_t reg0 = p_reg->CINSTRDAT0;
    2a80:	f8d3 3638 	ldr.w	r3, [r3, #1592]	; 0x638
    switch (length)
    2a84:	2807      	cmp	r0, #7
    2a86:	d813      	bhi.n	2ab0 <nrf_qspi_cinstrdata_get.constprop.0+0x38>
    2a88:	e8df f000 	tbb	[pc, r0]
    2a8c:	0b0d0f11 	.word	0x0b0d0f11
    2a90:	0406080a 	.word	0x0406080a
    {
        case NRF_QSPI_CINSTR_LEN_9B:
            p_rx_data_8[7] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE7_Pos);
    2a94:	0e10      	lsrs	r0, r2, #24
    2a96:	71c8      	strb	r0, [r1, #7]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_8B:
            p_rx_data_8[6] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE6_Pos);
    2a98:	0c10      	lsrs	r0, r2, #16
    2a9a:	7188      	strb	r0, [r1, #6]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_7B:
            p_rx_data_8[5] = (uint8_t)(reg1 >> QSPI_CINSTRDAT1_BYTE5_Pos);
    2a9c:	0a10      	lsrs	r0, r2, #8
    2a9e:	7148      	strb	r0, [r1, #5]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_6B:
            p_rx_data_8[4] = (uint8_t)(reg1);
    2aa0:	710a      	strb	r2, [r1, #4]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_5B:
            p_rx_data_8[3] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE3_Pos);
    2aa2:	0e1a      	lsrs	r2, r3, #24
    2aa4:	70ca      	strb	r2, [r1, #3]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_4B:
            p_rx_data_8[2] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE2_Pos);
    2aa6:	0c1a      	lsrs	r2, r3, #16
    2aa8:	708a      	strb	r2, [r1, #2]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_3B:
            p_rx_data_8[1] = (uint8_t)(reg0 >> QSPI_CINSTRDAT0_BYTE1_Pos);
    2aaa:	0a1a      	lsrs	r2, r3, #8
    2aac:	704a      	strb	r2, [r1, #1]
            /* FALLTHROUGH */
        case NRF_QSPI_CINSTR_LEN_2B:
            p_rx_data_8[0] = (uint8_t)(reg0);
    2aae:	700b      	strb	r3, [r1, #0]
            /* Send only opcode. Case to avoid compiler warnings. */
            break;
        default:
            break;
    }
}
    2ab0:	4770      	bx	lr
    2ab2:	bf00      	nop
    2ab4:	40029000 	.word	0x40029000

00002ab8 <nrf_qspi_cinstrdata_set.constprop.0>:
    switch (length)
    2ab8:	3802      	subs	r0, #2
    2aba:	2807      	cmp	r0, #7
    2abc:	d81f      	bhi.n	2afe <nrf_qspi_cinstrdata_set.constprop.0+0x46>
    2abe:	e8df f000 	tbb	[pc, r0]
    2ac2:	2729      	.short	0x2729
    2ac4:	21231125 	.word	0x21231125
    2ac8:	041f      	.short	0x041f
            reg |= ((uint32_t)p_tx_data_8[7]) << QSPI_CINSTRDAT1_BYTE7_Pos;
    2aca:	79cb      	ldrb	r3, [r1, #7]
    2acc:	061b      	lsls	r3, r3, #24
            reg |= ((uint32_t)p_tx_data_8[6]) << QSPI_CINSTRDAT1_BYTE6_Pos;
    2ace:	798a      	ldrb	r2, [r1, #6]
    2ad0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            reg |= ((uint32_t)p_tx_data_8[5]) << QSPI_CINSTRDAT1_BYTE5_Pos;
    2ad4:	794a      	ldrb	r2, [r1, #5]
    2ad6:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            reg |= ((uint32_t)p_tx_data_8[4]);
    2ada:	790a      	ldrb	r2, [r1, #4]
    2adc:	4313      	orrs	r3, r2
            p_reg->CINSTRDAT1 = reg;
    2ade:	4a0e      	ldr	r2, [pc, #56]	; (2b18 <nrf_qspi_cinstrdata_set.constprop.0+0x60>)
    2ae0:	f8c2 363c 	str.w	r3, [r2, #1596]	; 0x63c
            reg |= ((uint32_t)p_tx_data_8[3]) << QSPI_CINSTRDAT0_BYTE3_Pos;
    2ae4:	78cb      	ldrb	r3, [r1, #3]
    2ae6:	061b      	lsls	r3, r3, #24
            reg |= ((uint32_t)p_tx_data_8[2]) << QSPI_CINSTRDAT0_BYTE2_Pos;
    2ae8:	788a      	ldrb	r2, [r1, #2]
    2aea:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
            reg |= ((uint32_t)p_tx_data_8[1]) << QSPI_CINSTRDAT0_BYTE1_Pos;
    2aee:	784a      	ldrb	r2, [r1, #1]
    2af0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
            reg |= ((uint32_t)p_tx_data_8[0]);
    2af4:	780a      	ldrb	r2, [r1, #0]
    2af6:	4313      	orrs	r3, r2
            p_reg->CINSTRDAT0 = reg;
    2af8:	4a07      	ldr	r2, [pc, #28]	; (2b18 <nrf_qspi_cinstrdata_set.constprop.0+0x60>)
    2afa:	f8c2 3638 	str.w	r3, [r2, #1592]	; 0x638
}
    2afe:	4770      	bx	lr
    switch (length)
    2b00:	2300      	movs	r3, #0
    2b02:	e7e4      	b.n	2ace <nrf_qspi_cinstrdata_set.constprop.0+0x16>
    2b04:	2300      	movs	r3, #0
    2b06:	e7e5      	b.n	2ad4 <nrf_qspi_cinstrdata_set.constprop.0+0x1c>
    2b08:	2300      	movs	r3, #0
    2b0a:	e7e6      	b.n	2ada <nrf_qspi_cinstrdata_set.constprop.0+0x22>
    2b0c:	2300      	movs	r3, #0
    2b0e:	e7eb      	b.n	2ae8 <nrf_qspi_cinstrdata_set.constprop.0+0x30>
    2b10:	2300      	movs	r3, #0
    2b12:	e7ec      	b.n	2aee <nrf_qspi_cinstrdata_set.constprop.0+0x36>
    2b14:	2300      	movs	r3, #0
    2b16:	e7ed      	b.n	2af4 <nrf_qspi_cinstrdata_set.constprop.0+0x3c>
    2b18:	40029000 	.word	0x40029000

00002b1c <nrfx_qspi_init>:
{
    2b1c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    if (m_cb.state != NRFX_QSPI_STATE_UNINITIALIZED)
    2b1e:	4e6f      	ldr	r6, [pc, #444]	; (2cdc <nrfx_qspi_init+0x1c0>)
    2b20:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
{
    2b24:	4604      	mov	r4, r0
    2b26:	4615      	mov	r5, r2
    if (m_cb.state != NRFX_QSPI_STATE_UNINITIALIZED)
    2b28:	2b00      	cmp	r3, #0
    2b2a:	f040 80d2 	bne.w	2cd2 <nrfx_qspi_init+0x1b6>
    if (p_config->skip_gpio_cfg && p_config->skip_psel_cfg)
    2b2e:	7cc2      	ldrb	r2, [r0, #19]
    2b30:	b11a      	cbz	r2, 2b3a <nrfx_qspi_init+0x1e>
    2b32:	7d03      	ldrb	r3, [r0, #20]
    2b34:	2b00      	cmp	r3, #0
    2b36:	f040 8084 	bne.w	2c42 <nrfx_qspi_init+0x126>
    if ((p_config->pins.sck_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    2b3a:	7923      	ldrb	r3, [r4, #4]
    2b3c:	2bff      	cmp	r3, #255	; 0xff
    2b3e:	f000 80cb 	beq.w	2cd8 <nrfx_qspi_init+0x1bc>
    2b42:	7960      	ldrb	r0, [r4, #5]
    2b44:	28ff      	cmp	r0, #255	; 0xff
    2b46:	f000 80c7 	beq.w	2cd8 <nrfx_qspi_init+0x1bc>
        (p_config->pins.csn_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    2b4a:	79a0      	ldrb	r0, [r4, #6]
    2b4c:	28ff      	cmp	r0, #255	; 0xff
    2b4e:	f000 80c3 	beq.w	2cd8 <nrfx_qspi_init+0x1bc>
        (p_config->pins.io0_pin == NRF_QSPI_PIN_NOT_CONNECTED) ||
    2b52:	79e0      	ldrb	r0, [r4, #7]
    2b54:	28ff      	cmp	r0, #255	; 0xff
    2b56:	f000 80bf 	beq.w	2cd8 <nrfx_qspi_init+0x1bc>
    if (!p_config->skip_gpio_cfg)
    2b5a:	2a00      	cmp	r2, #0
    2b5c:	d142      	bne.n	2be4 <nrfx_qspi_init+0xc8>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2b5e:	a801      	add	r0, sp, #4
        QSPI_PIN_INIT(p_config->pins.sck_pin);
    2b60:	9301      	str	r3, [sp, #4]
    2b62:	f7ff fef1 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    2b66:	9b01      	ldr	r3, [sp, #4]
    2b68:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    2b6c:	f240 3702 	movw	r7, #770	; 0x302
    2b70:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2b74:	a801      	add	r0, sp, #4
        QSPI_PIN_INIT(p_config->pins.csn_pin);
    2b76:	7963      	ldrb	r3, [r4, #5]
    2b78:	9301      	str	r3, [sp, #4]
    2b7a:	f7ff fee5 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    2b7e:	9b01      	ldr	r3, [sp, #4]
    2b80:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    2b84:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2b88:	a801      	add	r0, sp, #4
        QSPI_PIN_INIT(p_config->pins.io0_pin);
    2b8a:	79a3      	ldrb	r3, [r4, #6]
    2b8c:	9301      	str	r3, [sp, #4]
    2b8e:	f7ff fedb 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    2b92:	9b01      	ldr	r3, [sp, #4]
    2b94:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    2b98:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2b9c:	a801      	add	r0, sp, #4
        QSPI_PIN_INIT(p_config->pins.io1_pin);
    2b9e:	79e3      	ldrb	r3, [r4, #7]
    2ba0:	9301      	str	r3, [sp, #4]
    2ba2:	f7ff fed1 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    2ba6:	9b01      	ldr	r3, [sp, #4]
    2ba8:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    2bac:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
        if (p_config->pins.io2_pin != NRF_QSPI_PIN_NOT_CONNECTED)
    2bb0:	7a23      	ldrb	r3, [r4, #8]
    2bb2:	2bff      	cmp	r3, #255	; 0xff
    2bb4:	d008      	beq.n	2bc8 <nrfx_qspi_init+0xac>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2bb6:	a801      	add	r0, sp, #4
            QSPI_PIN_INIT(p_config->pins.io2_pin);
    2bb8:	9301      	str	r3, [sp, #4]
    2bba:	f7ff fec5 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    2bbe:	9b01      	ldr	r3, [sp, #4]
    2bc0:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    2bc4:	f840 7023 	str.w	r7, [r0, r3, lsl #2]
        if (p_config->pins.io3_pin != NRF_QSPI_PIN_NOT_CONNECTED)
    2bc8:	7a63      	ldrb	r3, [r4, #9]
    2bca:	2bff      	cmp	r3, #255	; 0xff
    2bcc:	d00a      	beq.n	2be4 <nrfx_qspi_init+0xc8>
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    2bce:	a801      	add	r0, sp, #4
            QSPI_PIN_INIT(p_config->pins.io3_pin);
    2bd0:	9301      	str	r3, [sp, #4]
    2bd2:	f7ff feb9 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    2bd6:	9b01      	ldr	r3, [sp, #4]
    2bd8:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    2bdc:	f240 3202 	movw	r2, #770	; 0x302
    2be0:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
    if (!p_config->skip_psel_cfg)
    2be4:	7d23      	ldrb	r3, [r4, #20]
    2be6:	bb63      	cbnz	r3, 2c42 <nrfx_qspi_init+0x126>
    p_reg->PSEL.SCK = NRF_QSPI_PIN_VAL(p_pins->sck_pin);
    2be8:	7923      	ldrb	r3, [r4, #4]
    2bea:	2bff      	cmp	r3, #255	; 0xff
    2bec:	bf18      	it	ne
    2bee:	461a      	movne	r2, r3
    2bf0:	4b3b      	ldr	r3, [pc, #236]	; (2ce0 <nrfx_qspi_init+0x1c4>)
    2bf2:	bf08      	it	eq
    2bf4:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    2bf8:	f8c3 2524 	str.w	r2, [r3, #1316]	; 0x524
    p_reg->PSEL.CSN = NRF_QSPI_PIN_VAL(p_pins->csn_pin);
    2bfc:	7962      	ldrb	r2, [r4, #5]
    2bfe:	2aff      	cmp	r2, #255	; 0xff
    2c00:	bf08      	it	eq
    2c02:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    2c06:	f8c3 2528 	str.w	r2, [r3, #1320]	; 0x528
    p_reg->PSEL.IO0 = NRF_QSPI_PIN_VAL(p_pins->io0_pin);
    2c0a:	79a2      	ldrb	r2, [r4, #6]
    2c0c:	2aff      	cmp	r2, #255	; 0xff
    2c0e:	bf08      	it	eq
    2c10:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    2c14:	f8c3 2530 	str.w	r2, [r3, #1328]	; 0x530
    p_reg->PSEL.IO1 = NRF_QSPI_PIN_VAL(p_pins->io1_pin);
    2c18:	79e2      	ldrb	r2, [r4, #7]
    2c1a:	2aff      	cmp	r2, #255	; 0xff
    2c1c:	bf08      	it	eq
    2c1e:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    2c22:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
    p_reg->PSEL.IO2 = NRF_QSPI_PIN_VAL(p_pins->io2_pin);
    2c26:	7a22      	ldrb	r2, [r4, #8]
    2c28:	2aff      	cmp	r2, #255	; 0xff
    2c2a:	bf08      	it	eq
    2c2c:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    2c30:	f8c3 2538 	str.w	r2, [r3, #1336]	; 0x538
    p_reg->PSEL.IO3 = NRF_QSPI_PIN_VAL(p_pins->io3_pin);
    2c34:	7a62      	ldrb	r2, [r4, #9]
    2c36:	2aff      	cmp	r2, #255	; 0xff
    2c38:	bf08      	it	eq
    2c3a:	f04f 32ff 	moveq.w	r2, #4294967295	; 0xffffffff
    2c3e:	f8c3 253c 	str.w	r2, [r3, #1340]	; 0x53c
    p_reg->XIPOFFSET = xip_offset;
    2c42:	4a27      	ldr	r2, [pc, #156]	; (2ce0 <nrfx_qspi_init+0x1c4>)
    nrf_qspi_xip_offset_set(NRF_QSPI, p_config->xip_offset);
    2c44:	6823      	ldr	r3, [r4, #0]
    2c46:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
    config |= ((uint32_t)p_config->addrmode)   << QSPI_IFCONFIG0_ADDRMODE_Pos;
    2c4a:	7b23      	ldrb	r3, [r4, #12]
    config |= ((uint32_t)p_config->writeoc)    << QSPI_IFCONFIG0_WRITEOC_Pos;
    2c4c:	7ae7      	ldrb	r7, [r4, #11]
    uint32_t config = p_config->readoc;
    2c4e:	7aa0      	ldrb	r0, [r4, #10]
    config |= ((uint32_t)p_config->addrmode)   << QSPI_IFCONFIG0_ADDRMODE_Pos;
    2c50:	019b      	lsls	r3, r3, #6
    2c52:	ea43 03c7 	orr.w	r3, r3, r7, lsl #3
    2c56:	4303      	orrs	r3, r0
    config |= (p_config->dpmconfig ? 1U : 0U ) << QSPI_IFCONFIG0_DPMENABLE_Pos;
    2c58:	7b60      	ldrb	r0, [r4, #13]
    2c5a:	2800      	cmp	r0, #0
    2c5c:	bf14      	ite	ne
    2c5e:	2080      	movne	r0, #128	; 0x80
    2c60:	2000      	moveq	r0, #0
    2c62:	4303      	orrs	r3, r0
    p_reg->IFCONFIG0 = config;
    2c64:	f8c2 3544 	str.w	r3, [r2, #1348]	; 0x544
    uint32_t config = p_reg->IFCONFIG1 & 0x00FFFF00;
    2c68:	f8d2 3600 	ldr.w	r3, [r2, #1536]	; 0x600
    config |= p_config->sck_delay;
    2c6c:	7ba0      	ldrb	r0, [r4, #14]
    2c6e:	f894 c010 	ldrb.w	ip, [r4, #16]
    2c72:	7c67      	ldrb	r7, [r4, #17]
    uint32_t config = p_reg->IFCONFIG1 & 0x00FFFF00;
    2c74:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    2c78:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    2c7c:	4303      	orrs	r3, r0
    config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
    2c7e:	7be0      	ldrb	r0, [r4, #15]
    config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
    2c80:	ea43 634c 	orr.w	r3, r3, ip, lsl #25
    config |= (p_config->dpmen ? 1U : 0U)      << QSPI_IFCONFIG1_DPMEN_Pos;
    2c84:	2800      	cmp	r0, #0
    2c86:	bf14      	ite	ne
    2c88:	f04f 7080 	movne.w	r0, #16777216	; 0x1000000
    2c8c:	2000      	moveq	r0, #0
    config |= ((uint32_t)(p_config->sck_freq)) << QSPI_IFCONFIG1_SCKFREQ_Pos;
    2c8e:	ea43 7307 	orr.w	r3, r3, r7, lsl #28
    2c92:	4303      	orrs	r3, r0
    p_reg->IFCONFIG1 = config;
    2c94:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    m_cb.skip_gpio_cfg = p_config->skip_gpio_cfg;
    2c98:	7ce3      	ldrb	r3, [r4, #19]
    2c9a:	f886 3031 	strb.w	r3, [r6, #49]	; 0x31
    p_reg->INTENCLR = mask;
    2c9e:	2301      	movs	r3, #1
    m_cb.p_context = p_context;
    2ca0:	e9c6 1500 	strd	r1, r5, [r6]
    2ca4:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
    if (handler)
    2ca8:	b111      	cbz	r1, 2cb0 <nrfx_qspi_init+0x194>
        NRFX_IRQ_ENABLE(QSPI_IRQn);
    2caa:	2029      	movs	r0, #41	; 0x29
    2cac:	f7fe f976 	bl	f9c <arch_irq_enable>
    p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Enabled << QSPI_ENABLE_ENABLE_Pos);
    2cb0:	4b0b      	ldr	r3, [pc, #44]	; (2ce0 <nrfx_qspi_init+0x1c4>)
    m_cb.state = NRFX_QSPI_STATE_IDLE;
    2cb2:	2201      	movs	r2, #1
    m_cb.p_buffer_primary = NULL;
    2cb4:	2100      	movs	r1, #0
    m_cb.p_buffer_secondary = NULL;
    2cb6:	e9c6 1102 	strd	r1, r1, [r6, #8]
    m_cb.state = NRFX_QSPI_STATE_IDLE;
    2cba:	f886 2030 	strb.w	r2, [r6, #48]	; 0x30
    2cbe:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2cc2:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2cc6:	601a      	str	r2, [r3, #0]
}
    2cc8:	b003      	add	sp, #12
    2cca:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
    return qspi_ready_wait();
    2cce:	f7ff bea9 	b.w	2a24 <qspi_ready_wait>
        return NRFX_ERROR_INVALID_STATE;
    2cd2:	4804      	ldr	r0, [pc, #16]	; (2ce4 <nrfx_qspi_init+0x1c8>)
}
    2cd4:	b003      	add	sp, #12
    2cd6:	bdf0      	pop	{r4, r5, r6, r7, pc}
        return NRFX_ERROR_INVALID_PARAM;
    2cd8:	4803      	ldr	r0, [pc, #12]	; (2ce8 <nrfx_qspi_init+0x1cc>)
    2cda:	e7fb      	b.n	2cd4 <nrfx_qspi_init+0x1b8>
    2cdc:	200015a4 	.word	0x200015a4
    2ce0:	40029000 	.word	0x40029000
    2ce4:	0bad0005 	.word	0x0bad0005
    2ce8:	0bad0004 	.word	0x0bad0004

00002cec <nrfx_qspi_cinstr_xfer>:
{
    2cec:	b570      	push	{r4, r5, r6, lr}
    2cee:	4614      	mov	r4, r2
    if (m_cb.state != NRFX_QSPI_STATE_IDLE)
    2cf0:	4a19      	ldr	r2, [pc, #100]	; (2d58 <nrfx_qspi_cinstr_xfer+0x6c>)
    2cf2:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
    2cf6:	2a01      	cmp	r2, #1
{
    2cf8:	4605      	mov	r5, r0
    if (m_cb.state != NRFX_QSPI_STATE_IDLE)
    2cfa:	d12b      	bne.n	2d54 <nrfx_qspi_cinstr_xfer+0x68>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2cfc:	4e17      	ldr	r6, [pc, #92]	; (2d5c <nrfx_qspi_cinstr_xfer+0x70>)
    2cfe:	2200      	movs	r2, #0
    2d00:	f8c6 2100 	str.w	r2, [r6, #256]	; 0x100
    if (p_tx_buffer)
    2d04:	b111      	cbz	r1, 2d0c <nrfx_qspi_cinstr_xfer+0x20>
        nrf_qspi_cinstrdata_set(NRF_QSPI, p_config->length, p_tx_buffer);
    2d06:	7840      	ldrb	r0, [r0, #1]
    2d08:	f7ff fed6 	bl	2ab8 <nrf_qspi_cinstrdata_set.constprop.0>
    p_reg->INTENCLR = mask;
    2d0c:	2301      	movs	r3, #1
    2d0e:	f8c6 3308 	str.w	r3, [r6, #776]	; 0x308
NRF_STATIC_INLINE void nrf_qspi_cinstr_transfer_start(NRF_QSPI_Type *                p_reg,
                                                      nrf_qspi_cinstr_conf_t const * p_config)
{
    p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
                         ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
    2d12:	78ab      	ldrb	r3, [r5, #2]
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
    2d14:	786a      	ldrb	r2, [r5, #1]
                         ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
    2d16:	031b      	lsls	r3, r3, #12
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
    2d18:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
    p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
    2d1c:	782a      	ldrb	r2, [r5, #0]
                         ((uint32_t)p_config->length    << QSPI_CINSTRCONF_LENGTH_Pos) |
    2d1e:	4313      	orrs	r3, r2
                         ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
    2d20:	78ea      	ldrb	r2, [r5, #3]
                         ((uint32_t)p_config->io2_level << QSPI_CINSTRCONF_LIO2_Pos) |
    2d22:	ea43 3342 	orr.w	r3, r3, r2, lsl #13
                         ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
    2d26:	792a      	ldrb	r2, [r5, #4]
                         ((uint32_t)p_config->io3_level << QSPI_CINSTRCONF_LIO3_Pos) |
    2d28:	ea43 3382 	orr.w	r3, r3, r2, lsl #14
                         ((uint32_t)p_config->wren      << QSPI_CINSTRCONF_WREN_Pos));
    2d2c:	796a      	ldrb	r2, [r5, #5]
                         ((uint32_t)p_config->wipwait   << QSPI_CINSTRCONF_WIPWAIT_Pos) |
    2d2e:	ea43 33c2 	orr.w	r3, r3, r2, lsl #15
    p_reg->CINSTRCONF = (((uint32_t)p_config->opcode    << QSPI_CINSTRCONF_OPCODE_Pos) |
    2d32:	f8c6 3634 	str.w	r3, [r6, #1588]	; 0x634
    if (qspi_ready_wait() == NRFX_ERROR_TIMEOUT)
    2d36:	f7ff fe75 	bl	2a24 <qspi_ready_wait>
    2d3a:	4b09      	ldr	r3, [pc, #36]	; (2d60 <nrfx_qspi_cinstr_xfer+0x74>)
    2d3c:	4298      	cmp	r0, r3
    2d3e:	d00a      	beq.n	2d56 <nrfx_qspi_cinstr_xfer+0x6a>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2d40:	2300      	movs	r3, #0
    2d42:	f8c6 3100 	str.w	r3, [r6, #256]	; 0x100
    if (p_rx_buffer)
    2d46:	b11c      	cbz	r4, 2d50 <nrfx_qspi_cinstr_xfer+0x64>
        nrf_qspi_cinstrdata_get(NRF_QSPI, p_config->length, p_rx_buffer);
    2d48:	7868      	ldrb	r0, [r5, #1]
    2d4a:	4621      	mov	r1, r4
    2d4c:	f7ff fe94 	bl	2a78 <nrf_qspi_cinstrdata_get.constprop.0>
    2d50:	4804      	ldr	r0, [pc, #16]	; (2d64 <nrfx_qspi_cinstr_xfer+0x78>)
    2d52:	e000      	b.n	2d56 <nrfx_qspi_cinstr_xfer+0x6a>
        return NRFX_ERROR_BUSY;
    2d54:	4804      	ldr	r0, [pc, #16]	; (2d68 <nrfx_qspi_cinstr_xfer+0x7c>)
}
    2d56:	bd70      	pop	{r4, r5, r6, pc}
    2d58:	200015a4 	.word	0x200015a4
    2d5c:	40029000 	.word	0x40029000
    2d60:	0bad0007 	.word	0x0bad0007
    2d64:	0bad0000 	.word	0x0bad0000
    2d68:	0bad000b 	.word	0x0bad000b

00002d6c <nrfx_qspi_mem_busy_check>:
{
    2d6c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint8_t status_value = 0;
    2d6e:	2300      	movs	r3, #0
    2d70:	f88d 3007 	strb.w	r3, [sp, #7]
    nrf_qspi_cinstr_conf_t const config =
    2d74:	4b0c      	ldr	r3, [pc, #48]	; (2da8 <nrfx_qspi_mem_busy_check+0x3c>)
    ret_code = nrfx_qspi_cinstr_xfer(&config, &status_value, &status_value);
    2d76:	f10d 0207 	add.w	r2, sp, #7
    nrf_qspi_cinstr_conf_t const config =
    2d7a:	6818      	ldr	r0, [r3, #0]
    2d7c:	9002      	str	r0, [sp, #8]
    2d7e:	889b      	ldrh	r3, [r3, #4]
    2d80:	f8ad 300c 	strh.w	r3, [sp, #12]
    ret_code = nrfx_qspi_cinstr_xfer(&config, &status_value, &status_value);
    2d84:	4611      	mov	r1, r2
    2d86:	a802      	add	r0, sp, #8
    2d88:	f7ff ffb0 	bl	2cec <nrfx_qspi_cinstr_xfer>
    if (ret_code != NRFX_SUCCESS)
    2d8c:	4b07      	ldr	r3, [pc, #28]	; (2dac <nrfx_qspi_mem_busy_check+0x40>)
    2d8e:	4298      	cmp	r0, r3
    2d90:	d106      	bne.n	2da0 <nrfx_qspi_mem_busy_check+0x34>
    if ((status_value & QSPI_MEM_STATUSREG_WIP_Pos) != 0x00)
    2d92:	f89d 3007 	ldrb.w	r3, [sp, #7]
        return NRFX_ERROR_BUSY;
    2d96:	f013 0f01 	tst.w	r3, #1
    2d9a:	4b05      	ldr	r3, [pc, #20]	; (2db0 <nrfx_qspi_mem_busy_check+0x44>)
    2d9c:	bf18      	it	ne
    2d9e:	4618      	movne	r0, r3
}
    2da0:	b005      	add	sp, #20
    2da2:	f85d fb04 	ldr.w	pc, [sp], #4
    2da6:	bf00      	nop
    2da8:	00005e80 	.word	0x00005e80
    2dac:	0bad0000 	.word	0x0bad0000
    2db0:	0bad000b 	.word	0x0bad000b

00002db4 <nrfx_qspi_uninit>:
{
    2db4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    NRFX_IRQ_DISABLE(QSPI_IRQn);
    2db8:	2029      	movs	r0, #41	; 0x29
    2dba:	f7fe f8ff 	bl	fbc <arch_irq_disable>
                         (QSPI_CINSTRCONF_LFEN_Msk));
}

NRF_STATIC_INLINE bool nrf_qspi_cinstr_long_transfer_is_ongoing(NRF_QSPI_Type const * p_reg)
{
    return (bool)((p_reg->CINSTRCONF & (QSPI_CINSTRCONF_LFEN_Msk | QSPI_CINSTRCONF_LFSTOP_Msk))
    2dbe:	4b24      	ldr	r3, [pc, #144]	; (2e50 <nrfx_qspi_uninit+0x9c>)
    if (!m_cb.skip_gpio_cfg)
    2dc0:	4d24      	ldr	r5, [pc, #144]	; (2e54 <nrfx_qspi_uninit+0xa0>)
    2dc2:	f8d3 2634 	ldr.w	r2, [r3, #1588]	; 0x634
    2dc6:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
    if (nrf_qspi_cinstr_long_transfer_is_ongoing(NRF_QSPI))
    2dca:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
                                                              bool                  finalize)
{
    uint32_t mask = (((uint32_t)length << QSPI_CINSTRCONF_LENGTH_Pos) | (QSPI_CINSTRCONF_LFEN_Msk));
    mask |= (finalize ? QSPI_CINSTRCONF_LFSTOP_Msk : 0);

    p_reg->CINSTRCONF = mask;
    2dce:	bf04      	itt	eq
    2dd0:	4a21      	ldreq	r2, [pc, #132]	; (2e58 <nrfx_qspi_uninit+0xa4>)
    2dd2:	f8c3 2634 	streq.w	r2, [r3, #1588]	; 0x634
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    2dd6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
    p_reg->INTENCLR = mask;
    2dda:	2201      	movs	r2, #1
    2ddc:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2de0:	611a      	str	r2, [r3, #16]
            if (var1 == 0x08)
    2de2:	f8d1 1130 	ldr.w	r1, [r1, #304]	; 0x130
    2de6:	2908      	cmp	r1, #8
        *(volatile uint32_t *)0x40029054ul = 1ul;
    2de8:	bf08      	it	eq
    2dea:	655a      	streq	r2, [r3, #84]	; 0x54
    p_reg->ENABLE = (QSPI_ENABLE_ENABLE_Disabled << QSPI_ENABLE_ENABLE_Pos);
    2dec:	4b18      	ldr	r3, [pc, #96]	; (2e50 <nrfx_qspi_uninit+0x9c>)
    2dee:	2200      	movs	r2, #0
    2df0:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2df4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    if (!m_cb.skip_gpio_cfg)
    2df8:	f895 2031 	ldrb.w	r2, [r5, #49]	; 0x31
    2dfc:	bb1a      	cbnz	r2, 2e46 <nrfx_qspi_uninit+0x92>
    p_pins->sck_pin = (uint8_t)p_reg->PSEL.SCK;
    2dfe:	f8d3 0524 	ldr.w	r0, [r3, #1316]	; 0x524
    p_pins->csn_pin = (uint8_t)p_reg->PSEL.CSN;
    2e02:	f8d3 8528 	ldr.w	r8, [r3, #1320]	; 0x528
    p_pins->io0_pin = (uint8_t)p_reg->PSEL.IO0;
    2e06:	f8d3 7530 	ldr.w	r7, [r3, #1328]	; 0x530
    p_pins->io1_pin = (uint8_t)p_reg->PSEL.IO1;
    2e0a:	f8d3 6534 	ldr.w	r6, [r3, #1332]	; 0x534
    p_pins->io2_pin = (uint8_t)p_reg->PSEL.IO2;
    2e0e:	f8d3 4538 	ldr.w	r4, [r3, #1336]	; 0x538
    p_pins->io3_pin = (uint8_t)p_reg->PSEL.IO3;
    2e12:	f8d3 153c 	ldr.w	r1, [r3, #1340]	; 0x53c
    nrf_gpio_cfg_default(pins.sck_pin);
    2e16:	b2c0      	uxtb	r0, r0
    2e18:	f002 fe9f 	bl	5b5a <nrf_gpio_cfg_default>
    nrf_gpio_cfg_default(pins.csn_pin);
    2e1c:	fa5f f088 	uxtb.w	r0, r8
    2e20:	f002 fe9b 	bl	5b5a <nrf_gpio_cfg_default>
    nrf_gpio_cfg_default(pins.io0_pin);
    2e24:	b2f8      	uxtb	r0, r7
    2e26:	f002 fe98 	bl	5b5a <nrf_gpio_cfg_default>
    nrf_gpio_cfg_default(pins.io1_pin);
    2e2a:	b2f0      	uxtb	r0, r6
    2e2c:	f002 fe95 	bl	5b5a <nrf_gpio_cfg_default>
    if (pins.io2_pin != NRF_QSPI_PIN_NOT_CONNECTED)
    2e30:	b2e0      	uxtb	r0, r4
    2e32:	28ff      	cmp	r0, #255	; 0xff
    2e34:	b2c9      	uxtb	r1, r1
    2e36:	d001      	beq.n	2e3c <nrfx_qspi_uninit+0x88>
        nrf_gpio_cfg_default(pins.io2_pin);
    2e38:	f002 fe8f 	bl	5b5a <nrf_gpio_cfg_default>
    if (pins.io3_pin != NRF_QSPI_PIN_NOT_CONNECTED)
    2e3c:	29ff      	cmp	r1, #255	; 0xff
    2e3e:	d002      	beq.n	2e46 <nrfx_qspi_uninit+0x92>
        nrf_gpio_cfg_default(pins.io3_pin);
    2e40:	4608      	mov	r0, r1
    2e42:	f002 fe8a 	bl	5b5a <nrf_gpio_cfg_default>
    m_cb.state = NRFX_QSPI_STATE_UNINITIALIZED;
    2e46:	2300      	movs	r3, #0
    2e48:	f885 3030 	strb.w	r3, [r5, #48]	; 0x30
}
    2e4c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    2e50:	40029000 	.word	0x40029000
    2e54:	200015a4 	.word	0x200015a4
    2e58:	00030100 	.word	0x00030100

00002e5c <nrfx_qspi_erase>:
    if (!nrfx_is_word_aligned((void const *)start_address))
    2e5c:	078b      	lsls	r3, r1, #30
{
    2e5e:	b510      	push	{r4, lr}
    if (!nrfx_is_word_aligned((void const *)start_address))
    2e60:	d120      	bne.n	2ea4 <nrfx_qspi_erase+0x48>
    if (m_cb.handler && m_cb.state != NRFX_QSPI_STATE_IDLE)
    2e62:	4a12      	ldr	r2, [pc, #72]	; (2eac <nrfx_qspi_erase+0x50>)
    2e64:	6814      	ldr	r4, [r2, #0]
    2e66:	b11c      	cbz	r4, 2e70 <nrfx_qspi_erase+0x14>
    2e68:	f892 3030 	ldrb.w	r3, [r2, #48]	; 0x30
    2e6c:	2b01      	cmp	r3, #1
    2e6e:	d11b      	bne.n	2ea8 <nrfx_qspi_erase+0x4c>
    m_cb.state = NRFX_QSPI_STATE_ERASE;
    2e70:	2304      	movs	r3, #4
    2e72:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
    p_reg->ERASE.PTR = erase_addr;
    2e76:	4b0e      	ldr	r3, [pc, #56]	; (2eb0 <nrfx_qspi_erase+0x54>)
    2e78:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2e7c:	2100      	movs	r1, #0
    p_reg->ERASE.LEN = len;
    2e7e:	f8c3 0520 	str.w	r0, [r3, #1312]	; 0x520
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2e82:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    2e86:	2101      	movs	r1, #1
    2e88:	60d9      	str	r1, [r3, #12]
    if (!m_cb.handler)
    2e8a:	b944      	cbnz	r4, 2e9e <nrfx_qspi_erase+0x42>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2e8c:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
        while (!nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY))
    2e90:	2900      	cmp	r1, #0
    2e92:	d0fb      	beq.n	2e8c <nrfx_qspi_erase+0x30>
        m_cb.state = NRFX_QSPI_STATE_IDLE;
    2e94:	2301      	movs	r3, #1
    2e96:	f882 3030 	strb.w	r3, [r2, #48]	; 0x30
    return NRFX_SUCCESS;
    2e9a:	4806      	ldr	r0, [pc, #24]	; (2eb4 <nrfx_qspi_erase+0x58>)
}
    2e9c:	bd10      	pop	{r4, pc}
    p_reg->INTENSET = mask;
    2e9e:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
    2ea2:	e7fa      	b.n	2e9a <nrfx_qspi_erase+0x3e>
        return NRFX_ERROR_INVALID_ADDR;
    2ea4:	4804      	ldr	r0, [pc, #16]	; (2eb8 <nrfx_qspi_erase+0x5c>)
    2ea6:	e7f9      	b.n	2e9c <nrfx_qspi_erase+0x40>
        return NRFX_ERROR_BUSY;
    2ea8:	4804      	ldr	r0, [pc, #16]	; (2ebc <nrfx_qspi_erase+0x60>)
    2eaa:	e7f7      	b.n	2e9c <nrfx_qspi_erase+0x40>
    2eac:	200015a4 	.word	0x200015a4
    2eb0:	40029000 	.word	0x40029000
    2eb4:	0bad0000 	.word	0x0bad0000
    2eb8:	0bad000a 	.word	0x0bad000a
    2ebc:	0bad000b 	.word	0x0bad000b

00002ec0 <nrfx_qspi_irq_handler>:
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
    2ec0:	4b17      	ldr	r3, [pc, #92]	; (2f20 <nrfx_qspi_irq_handler+0x60>)
    2ec2:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
            break;
    }
}

void nrfx_qspi_irq_handler(void)
{
    2ec6:	b510      	push	{r4, lr}
    // Catch Event ready interrupts
    if (nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY))
    2ec8:	b1e2      	cbz	r2, 2f04 <nrfx_qspi_irq_handler+0x44>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    2eca:	2200      	movs	r2, #0
    switch (m_cb.state)
    2ecc:	4c15      	ldr	r4, [pc, #84]	; (2f24 <nrfx_qspi_irq_handler+0x64>)
    2ece:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    2ed2:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
    2ed6:	2a03      	cmp	r2, #3
    2ed8:	d015      	beq.n	2f06 <nrfx_qspi_irq_handler+0x46>
    2eda:	2a04      	cmp	r2, #4
    2edc:	d015      	beq.n	2f0a <nrfx_qspi_irq_handler+0x4a>
    2ede:	2a02      	cmp	r2, #2
    2ee0:	d104      	bne.n	2eec <nrfx_qspi_irq_handler+0x2c>
            p_event->type = NRFX_QSPI_EVENT_WRITE_DONE;
    2ee2:	2301      	movs	r3, #1
            p_event->type = NRFX_QSPI_EVENT_READ_DONE;
    2ee4:	f884 3020 	strb.w	r3, [r4, #32]
            qspi_event_xfer_handle(&p_event->data.xfer);
    2ee8:	f7ff fdb2 	bl	2a50 <qspi_event_xfer_handle.constprop.0>
    {
        nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);

        qspi_extended_event_process(&m_cb.evt_ext);
        if (!m_cb.p_buffer_primary)
    2eec:	68a3      	ldr	r3, [r4, #8]
    2eee:	b913      	cbnz	r3, 2ef6 <nrfx_qspi_irq_handler+0x36>
        {
            m_cb.state = NRFX_QSPI_STATE_IDLE;
    2ef0:	2301      	movs	r3, #1
    2ef2:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
        }

        m_cb.handler(NRFX_QSPI_EVENT_DONE, m_cb.p_context);
    2ef6:	e9d4 3100 	ldrd	r3, r1, [r4]
    2efa:	2000      	movs	r0, #0
    2efc:	4798      	blx	r3
        m_cb.evt_ext.type = NRFX_QSPI_EVENT_NONE;
    2efe:	2300      	movs	r3, #0
    2f00:	f884 3020 	strb.w	r3, [r4, #32]
    }
}
    2f04:	bd10      	pop	{r4, pc}
            p_event->type = NRFX_QSPI_EVENT_READ_DONE;
    2f06:	2302      	movs	r3, #2
    2f08:	e7ec      	b.n	2ee4 <nrfx_qspi_irq_handler+0x24>
            p_event->type = NRFX_QSPI_EVENT_ERASE_DONE;
    2f0a:	2203      	movs	r2, #3
    2f0c:	f884 2020 	strb.w	r2, [r4, #32]
    return p_reg->ERASE.PTR;
    2f10:	f8d3 251c 	ldr.w	r2, [r3, #1308]	; 0x51c
    p_erase->addr = nrf_qspi_erase_ptr_get(NRF_QSPI);
    2f14:	6262      	str	r2, [r4, #36]	; 0x24
    return (nrf_qspi_erase_len_t)p_reg->ERASE.LEN;
    2f16:	f8d3 3520 	ldr.w	r3, [r3, #1312]	; 0x520
    2f1a:	f884 3028 	strb.w	r3, [r4, #40]	; 0x28
}
    2f1e:	e7e5      	b.n	2eec <nrfx_qspi_irq_handler+0x2c>
    2f20:	40029000 	.word	0x40029000
    2f24:	200015a4 	.word	0x200015a4

00002f28 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2f28:	4b0e      	ldr	r3, [pc, #56]	; (2f64 <z_sys_init_run_level+0x3c>)
{
    2f2a:	b570      	push	{r4, r5, r6, lr}
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2f2c:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
    2f30:	3001      	adds	r0, #1
    2f32:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
    2f36:	42a6      	cmp	r6, r4
    2f38:	d800      	bhi.n	2f3c <z_sys_init_run_level+0x14>
				dev->state->init_res = rc;
			}
			dev->state->initialized = true;
		}
	}
}
    2f3a:	bd70      	pop	{r4, r5, r6, pc}
		int rc = entry->init(dev);
    2f3c:	e9d4 3500 	ldrd	r3, r5, [r4]
    2f40:	4628      	mov	r0, r5
    2f42:	4798      	blx	r3
		if (dev != NULL) {
    2f44:	b165      	cbz	r5, 2f60 <z_sys_init_run_level+0x38>
				dev->state->init_res = rc;
    2f46:	68eb      	ldr	r3, [r5, #12]
			if (rc != 0) {
    2f48:	b130      	cbz	r0, 2f58 <z_sys_init_run_level+0x30>
				if (rc < 0) {
    2f4a:	2800      	cmp	r0, #0
    2f4c:	bfb8      	it	lt
    2f4e:	4240      	neglt	r0, r0
				dev->state->init_res = rc;
    2f50:	28ff      	cmp	r0, #255	; 0xff
    2f52:	bfa8      	it	ge
    2f54:	20ff      	movge	r0, #255	; 0xff
    2f56:	7018      	strb	r0, [r3, #0]
			dev->state->initialized = true;
    2f58:	785a      	ldrb	r2, [r3, #1]
    2f5a:	f042 0201 	orr.w	r2, r2, #1
    2f5e:	705a      	strb	r2, [r3, #1]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
    2f60:	3408      	adds	r4, #8
    2f62:	e7e8      	b.n	2f36 <z_sys_init_run_level+0xe>
    2f64:	00006040 	.word	0x00006040

00002f68 <z_impl_device_get_binding>:

const struct device *z_impl_device_get_binding(const char *name)
{
    2f68:	b570      	push	{r4, r5, r6, lr}
	const struct device *dev;

	/* A null string identifies no device.  So does an empty
	 * string.
	 */
	if ((name == NULL) || (name[0] == '\0')) {
    2f6a:	4605      	mov	r5, r0
    2f6c:	b910      	cbnz	r0, 2f74 <z_impl_device_get_binding+0xc>
		return NULL;
    2f6e:	2400      	movs	r4, #0
			return dev;
		}
	}

	return NULL;
}
    2f70:	4620      	mov	r0, r4
    2f72:	bd70      	pop	{r4, r5, r6, pc}
	if ((name == NULL) || (name[0] == '\0')) {
    2f74:	7803      	ldrb	r3, [r0, #0]
    2f76:	2b00      	cmp	r3, #0
    2f78:	d0f9      	beq.n	2f6e <z_impl_device_get_binding+0x6>
	for (dev = __device_start; dev != __device_end; dev++) {
    2f7a:	4c0e      	ldr	r4, [pc, #56]	; (2fb4 <z_impl_device_get_binding+0x4c>)
    2f7c:	4e0e      	ldr	r6, [pc, #56]	; (2fb8 <z_impl_device_get_binding+0x50>)
    2f7e:	42b4      	cmp	r4, r6
    2f80:	d108      	bne.n	2f94 <z_impl_device_get_binding+0x2c>
	for (dev = __device_start; dev != __device_end; dev++) {
    2f82:	4c0c      	ldr	r4, [pc, #48]	; (2fb4 <z_impl_device_get_binding+0x4c>)
    2f84:	42b4      	cmp	r4, r6
    2f86:	d0f2      	beq.n	2f6e <z_impl_device_get_binding+0x6>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
    2f88:	4620      	mov	r0, r4
    2f8a:	f002 fdff 	bl	5b8c <z_device_is_ready>
    2f8e:	b950      	cbnz	r0, 2fa6 <z_impl_device_get_binding+0x3e>
	for (dev = __device_start; dev != __device_end; dev++) {
    2f90:	3418      	adds	r4, #24
    2f92:	e7f7      	b.n	2f84 <z_impl_device_get_binding+0x1c>
		if (z_device_is_ready(dev) && (dev->name == name)) {
    2f94:	4620      	mov	r0, r4
    2f96:	f002 fdf9 	bl	5b8c <z_device_is_ready>
    2f9a:	b110      	cbz	r0, 2fa2 <z_impl_device_get_binding+0x3a>
    2f9c:	6823      	ldr	r3, [r4, #0]
    2f9e:	42ab      	cmp	r3, r5
    2fa0:	d0e6      	beq.n	2f70 <z_impl_device_get_binding+0x8>
	for (dev = __device_start; dev != __device_end; dev++) {
    2fa2:	3418      	adds	r4, #24
    2fa4:	e7eb      	b.n	2f7e <z_impl_device_get_binding+0x16>
		if (z_device_is_ready(dev) && (strcmp(name, dev->name) == 0)) {
    2fa6:	6821      	ldr	r1, [r4, #0]
    2fa8:	4628      	mov	r0, r5
    2faa:	f002 fa20 	bl	53ee <strcmp>
    2fae:	2800      	cmp	r0, #0
    2fb0:	d1ee      	bne.n	2f90 <z_impl_device_get_binding+0x28>
    2fb2:	e7dd      	b.n	2f70 <z_impl_device_get_binding+0x8>
    2fb4:	00005c8c 	.word	0x00005c8c
    2fb8:	00005cd4 	.word	0x00005cd4

00002fbc <bg_thread_main>:
 * This routine completes kernel initialization by invoking the remaining
 * init functions, then invokes application's main() routine.
 */
__boot_func
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
    2fbc:	b508      	push	{r3, lr}
	 * may perform memory management tasks (except for z_phys_map() which
	 * is allowed at any time)
	 */
	z_mem_manage_init();
#endif /* CONFIG_MMU */
	z_sys_post_kernel = true;
    2fbe:	4b09      	ldr	r3, [pc, #36]	; (2fe4 <bg_thread_main+0x28>)
    2fc0:	2201      	movs	r2, #1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    2fc2:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
    2fc4:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
    2fc6:	f7ff ffaf 	bl	2f28 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
    2fca:	f002 fe13 	bl	5bf4 <boot_banner>
	void z_cpp_init_static(void);
	z_cpp_init_static();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
    2fce:	2003      	movs	r0, #3
    2fd0:	f7ff ffaa 	bl	2f28 <z_sys_init_run_level>
	z_mem_manage_boot_finish();
#endif /* CONFIG_MMU */

	extern void main(void);

	main();
    2fd4:	f7fd f894 	bl	100 <main>

	/* Mark nonessential since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
    2fd8:	4a03      	ldr	r2, [pc, #12]	; (2fe8 <bg_thread_main+0x2c>)
    2fda:	7b13      	ldrb	r3, [r2, #12]
    2fdc:	f023 0301 	bic.w	r3, r3, #1
    2fe0:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
    2fe2:	bd08      	pop	{r3, pc}
    2fe4:	2000176d 	.word	0x2000176d
    2fe8:	200015d8 	.word	0x200015d8

00002fec <z_bss_zero>:
{
    2fec:	b508      	push	{r3, lr}
	z_early_memset(__bss_start, 0, __bss_end - __bss_start);
    2fee:	4803      	ldr	r0, [pc, #12]	; (2ffc <z_bss_zero+0x10>)
    2ff0:	4a03      	ldr	r2, [pc, #12]	; (3000 <z_bss_zero+0x14>)
    2ff2:	2100      	movs	r1, #0
    2ff4:	1a12      	subs	r2, r2, r0
    2ff6:	f002 fdef 	bl	5bd8 <z_early_memset>
}
    2ffa:	bd08      	pop	{r3, pc}
    2ffc:	20000088 	.word	0x20000088
    3000:	20001770 	.word	0x20001770

00003004 <z_cstart>:
 *
 * @return Does not return
 */
__boot_func
FUNC_NORETURN void z_cstart(void)
{
    3004:	b508      	push	{r3, lr}
 * pointer) register, and switched to automatically when taking an exception.
 *
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	uint32_t msp =
    3006:	4b19      	ldr	r3, [pc, #100]	; (306c <z_cstart+0x68>)
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
    3008:	f383 8808 	msr	MSP, r3
	 * for Cortex-M3 and Cortex-M4 (ARMv7-M) MCUs. For the rest
	 * of ARM Cortex-M processors this setting is enforced by
	 * default and it is not configurable.
	 */
#if defined(CONFIG_CPU_CORTEX_M3) || defined(CONFIG_CPU_CORTEX_M4)
	SCB->CCR |= SCB_CCR_STKALIGN_Msk;
    300c:	4c18      	ldr	r4, [pc, #96]	; (3070 <z_cstart+0x6c>)
    300e:	6963      	ldr	r3, [r4, #20]
    3010:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    3014:	6163      	str	r3, [r4, #20]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
    3016:	2500      	movs	r5, #0
    3018:	23e0      	movs	r3, #224	; 0xe0
    301a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
    301e:	77e5      	strb	r5, [r4, #31]
    3020:	7625      	strb	r5, [r4, #24]
    3022:	7665      	strb	r5, [r4, #25]
    3024:	76a5      	strb	r5, [r4, #26]
    3026:	f884 5020 	strb.w	r5, [r4, #32]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
    302a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    302c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
    3030:	6263      	str	r3, [r4, #36]	; 0x24
    3032:	f884 5023 	strb.w	r5, [r4, #35]	; 0x23

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
    3036:	f7fe f971 	bl	131c <z_arm_fault_init>
	z_arm_cpu_idle_init();
    303a:	f7fd ff9f 	bl	f7c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
    303e:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    3042:	62a3      	str	r3, [r4, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
    3044:	62e3      	str	r3, [r4, #44]	; 0x2c
	z_arm_clear_faults();
#if defined(CONFIG_ARM_MPU)
	z_arm_mpu_init();
    3046:	f7fe fa63 	bl	1510 <z_arm_mpu_init>
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
    304a:	f7fe f9f3 	bl	1434 <z_arm_configure_static_mpu_regions>
	struct k_thread dummy_thread;

	z_dummy_thread_init(&dummy_thread);
#endif
	/* do any necessary initialization of static devices */
	z_device_state_init();
    304e:	f002 fd9c 	bl	5b8a <z_device_state_init>

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
    3052:	4628      	mov	r0, r5
    3054:	f7ff ff68 	bl	2f28 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
    3058:	2001      	movs	r0, #1
    305a:	f7ff ff65 	bl	2f28 <z_sys_init_run_level>
#else
#ifdef ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING
	/* Custom ARCH-specific routine to switch to main()
	 * in the case of no multi-threading.
	 */
	ARCH_SWITCH_TO_MAIN_NO_MULTITHREADING(bg_thread_main,
    305e:	4805      	ldr	r0, [pc, #20]	; (3074 <z_cstart+0x70>)
    3060:	462b      	mov	r3, r5
    3062:	462a      	mov	r2, r5
    3064:	4629      	mov	r1, r5
    3066:	f7fe f83b 	bl	10e0 <z_arm_switch_to_main_no_multithreading>
    306a:	bf00      	nop
    306c:	200047c0 	.word	0x200047c0
    3070:	e000ed00 	.word	0xe000ed00
    3074:	00002fbd 	.word	0x00002fbd

00003078 <z_data_copy>:
 * @brief Copy the data section from ROM to RAM
 *
 * This routine copies the data section from ROM to RAM.
 */
void z_data_copy(void)
{
    3078:	b508      	push	{r3, lr}
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
		       __data_region_end - __data_region_start);
    307a:	4806      	ldr	r0, [pc, #24]	; (3094 <z_data_copy+0x1c>)
	z_early_memcpy(&__data_region_start, &__data_region_load_start,
    307c:	4a06      	ldr	r2, [pc, #24]	; (3098 <z_data_copy+0x20>)
    307e:	4907      	ldr	r1, [pc, #28]	; (309c <z_data_copy+0x24>)
    3080:	1a12      	subs	r2, r2, r0
    3082:	f002 fdab 	bl	5bdc <z_early_memcpy>
#else
	z_early_memcpy(&_app_smem_start, &_app_smem_rom_start,
		       _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
    3086:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_early_memcpy(&__ramfunc_start, &__ramfunc_load_start,
    308a:	4a05      	ldr	r2, [pc, #20]	; (30a0 <z_data_copy+0x28>)
    308c:	4905      	ldr	r1, [pc, #20]	; (30a4 <z_data_copy+0x2c>)
    308e:	4806      	ldr	r0, [pc, #24]	; (30a8 <z_data_copy+0x30>)
    3090:	f002 bda4 	b.w	5bdc <z_early_memcpy>
    3094:	20000000 	.word	0x20000000
    3098:	20000084 	.word	0x20000084
    309c:	000062b0 	.word	0x000062b0
    30a0:	00000000 	.word	0x00000000
    30a4:	000062b0 	.word	0x000062b0
    30a8:	20000000 	.word	0x20000000

000030ac <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? sys_clock_elapsed() : 0U;
    30ac:	4b03      	ldr	r3, [pc, #12]	; (30bc <elapsed+0x10>)
    30ae:	681b      	ldr	r3, [r3, #0]
    30b0:	b90b      	cbnz	r3, 30b6 <elapsed+0xa>
    30b2:	f002 bb31 	b.w	5718 <sys_clock_elapsed>
}
    30b6:	2000      	movs	r0, #0
    30b8:	4770      	bx	lr
    30ba:	bf00      	nop
    30bc:	2000164c 	.word	0x2000164c

000030c0 <next_timeout>:
 * @return true if empty, false otherwise
 */

static inline bool sys_dlist_is_empty(sys_dlist_t *list)
{
	return list->head == list;
    30c0:	4b08      	ldr	r3, [pc, #32]	; (30e4 <next_timeout+0x24>)

static int32_t next_timeout(void)
{
    30c2:	b510      	push	{r4, lr}
    30c4:	681c      	ldr	r4, [r3, #0]
 * @return a pointer to the head element, NULL if list is empty
 */

static inline sys_dnode_t *sys_dlist_peek_head(sys_dlist_t *list)
{
	return sys_dlist_is_empty(list) ? NULL : list->head;
    30c6:	429c      	cmp	r4, r3
    30c8:	bf08      	it	eq
    30ca:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
    30cc:	f7ff ffee 	bl	30ac <elapsed>
	int32_t ret;

	if ((to == NULL) ||
    30d0:	b124      	cbz	r4, 30dc <next_timeout+0x1c>
	    ((int64_t)(to->dticks - ticks_elapsed) > (int64_t)INT_MAX)) {
		ret = MAX_WAIT;
	} else {
		ret = MAX(0, to->dticks - ticks_elapsed);
    30d2:	68e3      	ldr	r3, [r4, #12]
    30d4:	1a18      	subs	r0, r3, r0
    30d6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
    30da:	bd10      	pop	{r4, pc}
		ret = MAX_WAIT;
    30dc:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
	return ret;
    30e0:	e7fb      	b.n	30da <next_timeout+0x1a>
    30e2:	bf00      	nop
    30e4:	20000010 	.word	0x20000010

000030e8 <remove_timeout>:
 */

static inline sys_dnode_t *sys_dlist_peek_next_no_check(sys_dlist_t *list,
							sys_dnode_t *node)
{
	return (node == list->tail) ? NULL : node->next;
    30e8:	6803      	ldr	r3, [r0, #0]
 */

static inline sys_dnode_t *sys_dlist_peek_next(sys_dlist_t *list,
					       sys_dnode_t *node)
{
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
    30ea:	b140      	cbz	r0, 30fe <remove_timeout+0x16>
	return (node == list->tail) ? NULL : node->next;
    30ec:	4a07      	ldr	r2, [pc, #28]	; (310c <remove_timeout+0x24>)
    30ee:	6852      	ldr	r2, [r2, #4]
    30f0:	4290      	cmp	r0, r2
    30f2:	d004      	beq.n	30fe <remove_timeout+0x16>
	if (next(t) != NULL) {
    30f4:	b11b      	cbz	r3, 30fe <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
    30f6:	68da      	ldr	r2, [r3, #12]
    30f8:	68c1      	ldr	r1, [r0, #12]
    30fa:	440a      	add	r2, r1
    30fc:	60da      	str	r2, [r3, #12]
 * @param node the node to remove
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	sys_dnode_t *const prev = node->prev;
    30fe:	6842      	ldr	r2, [r0, #4]
	sys_dnode_t *const next = node->next;

	prev->next = next;
    3100:	6013      	str	r3, [r2, #0]
	next->prev = prev;
    3102:	605a      	str	r2, [r3, #4]
	node->next = NULL;
    3104:	2300      	movs	r3, #0
	node->prev = NULL;
    3106:	e9c0 3300 	strd	r3, r3, [r0]
}
    310a:	4770      	bx	lr
    310c:	20000010 	.word	0x20000010

00003110 <sys_clock_announce>:
		}
	}
}

void sys_clock_announce(int32_t ticks)
{
    3110:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__asm__ volatile(
    3114:	f04f 0320 	mov.w	r3, #32
    3118:	f3ef 8411 	mrs	r4, BASEPRI
    311c:	f383 8812 	msr	BASEPRI_MAX, r3
    3120:	f3bf 8f6f 	isb	sy
		announce_remaining += ticks;
		k_spin_unlock(&timeout_lock, key);
		return;
	}

	announce_remaining = ticks;
    3124:	4e1e      	ldr	r6, [pc, #120]	; (31a0 <sys_clock_announce+0x90>)
	return list->head == list;
    3126:	f8df 8080 	ldr.w	r8, [pc, #128]	; 31a8 <sys_clock_announce+0x98>

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
    312a:	4d1e      	ldr	r5, [pc, #120]	; (31a4 <sys_clock_announce+0x94>)
	announce_remaining = ticks;
    312c:	6030      	str	r0, [r6, #0]
    312e:	f8d8 0000 	ldr.w	r0, [r8]
	while (first() != NULL && first()->dticks <= announce_remaining) {
    3132:	6832      	ldr	r2, [r6, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
    3134:	4540      	cmp	r0, r8
		curr_tick += dt;
    3136:	e9d5 1700 	ldrd	r1, r7, [r5]
    313a:	d005      	beq.n	3148 <sys_clock_announce+0x38>
	while (first() != NULL && first()->dticks <= announce_remaining) {
    313c:	b120      	cbz	r0, 3148 <sys_clock_announce+0x38>
    313e:	68c3      	ldr	r3, [r0, #12]
    3140:	4293      	cmp	r3, r2
    3142:	dd13      	ble.n	316c <sys_clock_announce+0x5c>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
    3144:	1a9b      	subs	r3, r3, r2
    3146:	60c3      	str	r3, [r0, #12]
	}

	curr_tick += announce_remaining;
    3148:	1851      	adds	r1, r2, r1
    314a:	eb47 72e2 	adc.w	r2, r7, r2, asr #31
    314e:	e9c5 1200 	strd	r1, r2, [r5]
	announce_remaining = 0;
    3152:	2500      	movs	r5, #0
    3154:	6035      	str	r5, [r6, #0]

	sys_clock_set_timeout(next_timeout(), false);
    3156:	f7ff ffb3 	bl	30c0 <next_timeout>
    315a:	4629      	mov	r1, r5
    315c:	f002 fadb 	bl	5716 <sys_clock_set_timeout>
	__asm__ volatile(
    3160:	f384 8811 	msr	BASEPRI, r4
    3164:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
    3168:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		curr_tick += dt;
    316c:	1859      	adds	r1, r3, r1
    316e:	eb47 77e3 	adc.w	r7, r7, r3, asr #31
		announce_remaining -= dt;
    3172:	1ad3      	subs	r3, r2, r3
    3174:	6033      	str	r3, [r6, #0]
		t->dticks = 0;
    3176:	2300      	movs	r3, #0
    3178:	60c3      	str	r3, [r0, #12]
		curr_tick += dt;
    317a:	e9c5 1700 	strd	r1, r7, [r5]
		remove_timeout(t);
    317e:	f7ff ffb3 	bl	30e8 <remove_timeout>
    3182:	f384 8811 	msr	BASEPRI, r4
    3186:	f3bf 8f6f 	isb	sy
		t->fn(t);
    318a:	6883      	ldr	r3, [r0, #8]
    318c:	4798      	blx	r3
	__asm__ volatile(
    318e:	f04f 0320 	mov.w	r3, #32
    3192:	f3ef 8411 	mrs	r4, BASEPRI
    3196:	f383 8812 	msr	BASEPRI_MAX, r3
    319a:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
    319e:	e7c6      	b.n	312e <sys_clock_announce+0x1e>
    31a0:	2000164c 	.word	0x2000164c
    31a4:	200000a8 	.word	0x200000a8
    31a8:	20000010 	.word	0x20000010

000031ac <nrf_cc3xx_platform_init_no_rng>:
    31ac:	b510      	push	{r4, lr}
    31ae:	4c0a      	ldr	r4, [pc, #40]	; (31d8 <nrf_cc3xx_platform_init_no_rng+0x2c>)
    31b0:	6823      	ldr	r3, [r4, #0]
    31b2:	b11b      	cbz	r3, 31bc <nrf_cc3xx_platform_init_no_rng+0x10>
    31b4:	2301      	movs	r3, #1
    31b6:	6023      	str	r3, [r4, #0]
    31b8:	2000      	movs	r0, #0
    31ba:	bd10      	pop	{r4, pc}
    31bc:	f000 f852 	bl	3264 <CC_LibInitNoRng>
    31c0:	2800      	cmp	r0, #0
    31c2:	d0f7      	beq.n	31b4 <nrf_cc3xx_platform_init_no_rng+0x8>
    31c4:	3801      	subs	r0, #1
    31c6:	2806      	cmp	r0, #6
    31c8:	d803      	bhi.n	31d2 <nrf_cc3xx_platform_init_no_rng+0x26>
    31ca:	4b04      	ldr	r3, [pc, #16]	; (31dc <nrf_cc3xx_platform_init_no_rng+0x30>)
    31cc:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    31d0:	bd10      	pop	{r4, pc}
    31d2:	4803      	ldr	r0, [pc, #12]	; (31e0 <nrf_cc3xx_platform_init_no_rng+0x34>)
    31d4:	bd10      	pop	{r4, pc}
    31d6:	bf00      	nop
    31d8:	20001650 	.word	0x20001650
    31dc:	00006054 	.word	0x00006054
    31e0:	ffff8ffe 	.word	0xffff8ffe

000031e4 <nrf_cc3xx_platform_abort>:
    31e4:	f3bf 8f4f 	dsb	sy
    31e8:	4905      	ldr	r1, [pc, #20]	; (3200 <nrf_cc3xx_platform_abort+0x1c>)
    31ea:	4b06      	ldr	r3, [pc, #24]	; (3204 <nrf_cc3xx_platform_abort+0x20>)
    31ec:	68ca      	ldr	r2, [r1, #12]
    31ee:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
    31f2:	4313      	orrs	r3, r2
    31f4:	60cb      	str	r3, [r1, #12]
    31f6:	f3bf 8f4f 	dsb	sy
    31fa:	bf00      	nop
    31fc:	e7fd      	b.n	31fa <nrf_cc3xx_platform_abort+0x16>
    31fe:	bf00      	nop
    3200:	e000ed00 	.word	0xe000ed00
    3204:	05fa0004 	.word	0x05fa0004

00003208 <CC_PalAbort>:
    3208:	b410      	push	{r4}
    320a:	4b0a      	ldr	r3, [pc, #40]	; (3234 <CC_PalAbort+0x2c>)
    320c:	490a      	ldr	r1, [pc, #40]	; (3238 <CC_PalAbort+0x30>)
    320e:	4c0b      	ldr	r4, [pc, #44]	; (323c <CC_PalAbort+0x34>)
    3210:	f04f 32fe 	mov.w	r2, #4278124286	; 0xfefefefe
    3214:	f8c3 2400 	str.w	r2, [r3, #1024]	; 0x400
    3218:	6849      	ldr	r1, [r1, #4]
    321a:	f8c3 2404 	str.w	r2, [r3, #1028]	; 0x404
    321e:	f8c3 2408 	str.w	r2, [r3, #1032]	; 0x408
    3222:	f8c3 240c 	str.w	r2, [r3, #1036]	; 0x40c
    3226:	2300      	movs	r3, #0
    3228:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
    322c:	f85d 4b04 	ldr.w	r4, [sp], #4
    3230:	4708      	bx	r1
    3232:	bf00      	nop
    3234:	5002b000 	.word	0x5002b000
    3238:	20000018 	.word	0x20000018
    323c:	5002a000 	.word	0x5002a000

00003240 <nrf_cc3xx_platform_set_abort>:
    3240:	e9d0 1200 	ldrd	r1, r2, [r0]
    3244:	4b01      	ldr	r3, [pc, #4]	; (324c <nrf_cc3xx_platform_set_abort+0xc>)
    3246:	e9c3 1200 	strd	r1, r2, [r3]
    324a:	4770      	bx	lr
    324c:	20000018 	.word	0x20000018

00003250 <mbedtls_platform_zeroize>:
    3250:	b138      	cbz	r0, 3262 <mbedtls_platform_zeroize+0x12>
    3252:	b131      	cbz	r1, 3262 <mbedtls_platform_zeroize+0x12>
    3254:	4401      	add	r1, r0
    3256:	2200      	movs	r2, #0
    3258:	4603      	mov	r3, r0
    325a:	3001      	adds	r0, #1
    325c:	4288      	cmp	r0, r1
    325e:	701a      	strb	r2, [r3, #0]
    3260:	d1fa      	bne.n	3258 <mbedtls_platform_zeroize+0x8>
    3262:	4770      	bx	lr

00003264 <CC_LibInitNoRng>:
    3264:	b538      	push	{r3, r4, r5, lr}
    3266:	f000 f82f 	bl	32c8 <CC_HalInit>
    326a:	b120      	cbz	r0, 3276 <CC_LibInitNoRng+0x12>
    326c:	2403      	movs	r4, #3
    326e:	f000 f863 	bl	3338 <CC_PalTerminate>
    3272:	4620      	mov	r0, r4
    3274:	bd38      	pop	{r3, r4, r5, pc}
    3276:	f000 f831 	bl	32dc <CC_PalInit>
    327a:	b998      	cbnz	r0, 32a4 <CC_LibInitNoRng+0x40>
    327c:	f000 f8ac 	bl	33d8 <CC_PalPowerSaveModeSelect>
    3280:	b998      	cbnz	r0, 32aa <CC_LibInitNoRng+0x46>
    3282:	4d0f      	ldr	r5, [pc, #60]	; (32c0 <CC_LibInitNoRng+0x5c>)
    3284:	f8d5 3928 	ldr.w	r3, [r5, #2344]	; 0x928
    3288:	0e1b      	lsrs	r3, r3, #24
    328a:	2bf0      	cmp	r3, #240	; 0xf0
    328c:	d108      	bne.n	32a0 <CC_LibInitNoRng+0x3c>
    328e:	f8d5 2a24 	ldr.w	r2, [r5, #2596]	; 0xa24
    3292:	4b0c      	ldr	r3, [pc, #48]	; (32c4 <CC_LibInitNoRng+0x60>)
    3294:	429a      	cmp	r2, r3
    3296:	d00a      	beq.n	32ae <CC_LibInitNoRng+0x4a>
    3298:	2407      	movs	r4, #7
    329a:	f000 f817 	bl	32cc <CC_HalTerminate>
    329e:	e7e6      	b.n	326e <CC_LibInitNoRng+0xa>
    32a0:	2406      	movs	r4, #6
    32a2:	e7fa      	b.n	329a <CC_LibInitNoRng+0x36>
    32a4:	2404      	movs	r4, #4
    32a6:	4620      	mov	r0, r4
    32a8:	bd38      	pop	{r3, r4, r5, pc}
    32aa:	2400      	movs	r4, #0
    32ac:	e7f5      	b.n	329a <CC_LibInitNoRng+0x36>
    32ae:	2001      	movs	r0, #1
    32b0:	f000 f892 	bl	33d8 <CC_PalPowerSaveModeSelect>
    32b4:	4604      	mov	r4, r0
    32b6:	2800      	cmp	r0, #0
    32b8:	d1f7      	bne.n	32aa <CC_LibInitNoRng+0x46>
    32ba:	f8c5 0a0c 	str.w	r0, [r5, #2572]	; 0xa0c
    32be:	e7d8      	b.n	3272 <CC_LibInitNoRng+0xe>
    32c0:	5002b000 	.word	0x5002b000
    32c4:	20e00000 	.word	0x20e00000

000032c8 <CC_HalInit>:
    32c8:	2000      	movs	r0, #0
    32ca:	4770      	bx	lr

000032cc <CC_HalTerminate>:
    32cc:	2000      	movs	r0, #0
    32ce:	4770      	bx	lr

000032d0 <CC_HalMaskInterrupt>:
    32d0:	4b01      	ldr	r3, [pc, #4]	; (32d8 <CC_HalMaskInterrupt+0x8>)
    32d2:	f8c3 0a04 	str.w	r0, [r3, #2564]	; 0xa04
    32d6:	4770      	bx	lr
    32d8:	5002b000 	.word	0x5002b000

000032dc <CC_PalInit>:
    32dc:	b510      	push	{r4, lr}
    32de:	4811      	ldr	r0, [pc, #68]	; (3324 <CC_PalInit+0x48>)
    32e0:	f000 f848 	bl	3374 <CC_PalMutexCreate>
    32e4:	b100      	cbz	r0, 32e8 <CC_PalInit+0xc>
    32e6:	bd10      	pop	{r4, pc}
    32e8:	480f      	ldr	r0, [pc, #60]	; (3328 <CC_PalInit+0x4c>)
    32ea:	f000 f843 	bl	3374 <CC_PalMutexCreate>
    32ee:	2800      	cmp	r0, #0
    32f0:	d1f9      	bne.n	32e6 <CC_PalInit+0xa>
    32f2:	4c0e      	ldr	r4, [pc, #56]	; (332c <CC_PalInit+0x50>)
    32f4:	4620      	mov	r0, r4
    32f6:	f000 f83d 	bl	3374 <CC_PalMutexCreate>
    32fa:	2800      	cmp	r0, #0
    32fc:	d1f3      	bne.n	32e6 <CC_PalInit+0xa>
    32fe:	4b0c      	ldr	r3, [pc, #48]	; (3330 <CC_PalInit+0x54>)
    3300:	480c      	ldr	r0, [pc, #48]	; (3334 <CC_PalInit+0x58>)
    3302:	601c      	str	r4, [r3, #0]
    3304:	f000 f836 	bl	3374 <CC_PalMutexCreate>
    3308:	4601      	mov	r1, r0
    330a:	2800      	cmp	r0, #0
    330c:	d1eb      	bne.n	32e6 <CC_PalInit+0xa>
    330e:	f000 f82d 	bl	336c <CC_PalDmaInit>
    3312:	4604      	mov	r4, r0
    3314:	b108      	cbz	r0, 331a <CC_PalInit+0x3e>
    3316:	4620      	mov	r0, r4
    3318:	bd10      	pop	{r4, pc}
    331a:	f000 f83f 	bl	339c <CC_PalPowerSaveModeInit>
    331e:	4620      	mov	r0, r4
    3320:	e7fa      	b.n	3318 <CC_PalInit+0x3c>
    3322:	bf00      	nop
    3324:	2000002c 	.word	0x2000002c
    3328:	20000020 	.word	0x20000020
    332c:	20000028 	.word	0x20000028
    3330:	20000030 	.word	0x20000030
    3334:	20000024 	.word	0x20000024

00003338 <CC_PalTerminate>:
    3338:	b508      	push	{r3, lr}
    333a:	4808      	ldr	r0, [pc, #32]	; (335c <CC_PalTerminate+0x24>)
    333c:	f000 f824 	bl	3388 <CC_PalMutexDestroy>
    3340:	4807      	ldr	r0, [pc, #28]	; (3360 <CC_PalTerminate+0x28>)
    3342:	f000 f821 	bl	3388 <CC_PalMutexDestroy>
    3346:	4807      	ldr	r0, [pc, #28]	; (3364 <CC_PalTerminate+0x2c>)
    3348:	f000 f81e 	bl	3388 <CC_PalMutexDestroy>
    334c:	4806      	ldr	r0, [pc, #24]	; (3368 <CC_PalTerminate+0x30>)
    334e:	f000 f81b 	bl	3388 <CC_PalMutexDestroy>
    3352:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    3356:	f000 b80b 	b.w	3370 <CC_PalDmaTerminate>
    335a:	bf00      	nop
    335c:	2000002c 	.word	0x2000002c
    3360:	20000020 	.word	0x20000020
    3364:	20000028 	.word	0x20000028
    3368:	20000024 	.word	0x20000024

0000336c <CC_PalDmaInit>:
    336c:	2000      	movs	r0, #0
    336e:	4770      	bx	lr

00003370 <CC_PalDmaTerminate>:
    3370:	4770      	bx	lr
    3372:	bf00      	nop

00003374 <CC_PalMutexCreate>:
    3374:	b508      	push	{r3, lr}
    3376:	4b03      	ldr	r3, [pc, #12]	; (3384 <CC_PalMutexCreate+0x10>)
    3378:	6802      	ldr	r2, [r0, #0]
    337a:	681b      	ldr	r3, [r3, #0]
    337c:	6810      	ldr	r0, [r2, #0]
    337e:	4798      	blx	r3
    3380:	2000      	movs	r0, #0
    3382:	bd08      	pop	{r3, pc}
    3384:	2000003c 	.word	0x2000003c

00003388 <CC_PalMutexDestroy>:
    3388:	b508      	push	{r3, lr}
    338a:	4b03      	ldr	r3, [pc, #12]	; (3398 <CC_PalMutexDestroy+0x10>)
    338c:	6802      	ldr	r2, [r0, #0]
    338e:	685b      	ldr	r3, [r3, #4]
    3390:	6810      	ldr	r0, [r2, #0]
    3392:	4798      	blx	r3
    3394:	2000      	movs	r0, #0
    3396:	bd08      	pop	{r3, pc}
    3398:	2000003c 	.word	0x2000003c

0000339c <CC_PalPowerSaveModeInit>:
    339c:	b570      	push	{r4, r5, r6, lr}
    339e:	4c09      	ldr	r4, [pc, #36]	; (33c4 <CC_PalPowerSaveModeInit+0x28>)
    33a0:	4d09      	ldr	r5, [pc, #36]	; (33c8 <CC_PalPowerSaveModeInit+0x2c>)
    33a2:	6920      	ldr	r0, [r4, #16]
    33a4:	68ab      	ldr	r3, [r5, #8]
    33a6:	4798      	blx	r3
    33a8:	b118      	cbz	r0, 33b2 <CC_PalPowerSaveModeInit+0x16>
    33aa:	4b08      	ldr	r3, [pc, #32]	; (33cc <CC_PalPowerSaveModeInit+0x30>)
    33ac:	4808      	ldr	r0, [pc, #32]	; (33d0 <CC_PalPowerSaveModeInit+0x34>)
    33ae:	685b      	ldr	r3, [r3, #4]
    33b0:	4798      	blx	r3
    33b2:	4a08      	ldr	r2, [pc, #32]	; (33d4 <CC_PalPowerSaveModeInit+0x38>)
    33b4:	68eb      	ldr	r3, [r5, #12]
    33b6:	6920      	ldr	r0, [r4, #16]
    33b8:	2100      	movs	r1, #0
    33ba:	6011      	str	r1, [r2, #0]
    33bc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    33c0:	4718      	bx	r3
    33c2:	bf00      	nop
    33c4:	2000004c 	.word	0x2000004c
    33c8:	2000003c 	.word	0x2000003c
    33cc:	20000018 	.word	0x20000018
    33d0:	00006070 	.word	0x00006070
    33d4:	20001654 	.word	0x20001654

000033d8 <CC_PalPowerSaveModeSelect>:
    33d8:	b570      	push	{r4, r5, r6, lr}
    33da:	4d1b      	ldr	r5, [pc, #108]	; (3448 <CC_PalPowerSaveModeSelect+0x70>)
    33dc:	4e1b      	ldr	r6, [pc, #108]	; (344c <CC_PalPowerSaveModeSelect+0x74>)
    33de:	4604      	mov	r4, r0
    33e0:	68b2      	ldr	r2, [r6, #8]
    33e2:	6928      	ldr	r0, [r5, #16]
    33e4:	4790      	blx	r2
    33e6:	b9f8      	cbnz	r0, 3428 <CC_PalPowerSaveModeSelect+0x50>
    33e8:	b15c      	cbz	r4, 3402 <CC_PalPowerSaveModeSelect+0x2a>
    33ea:	4c19      	ldr	r4, [pc, #100]	; (3450 <CC_PalPowerSaveModeSelect+0x78>)
    33ec:	6823      	ldr	r3, [r4, #0]
    33ee:	b1b3      	cbz	r3, 341e <CC_PalPowerSaveModeSelect+0x46>
    33f0:	2b01      	cmp	r3, #1
    33f2:	d01b      	beq.n	342c <CC_PalPowerSaveModeSelect+0x54>
    33f4:	3b01      	subs	r3, #1
    33f6:	6023      	str	r3, [r4, #0]
    33f8:	6928      	ldr	r0, [r5, #16]
    33fa:	68f3      	ldr	r3, [r6, #12]
    33fc:	4798      	blx	r3
    33fe:	2000      	movs	r0, #0
    3400:	bd70      	pop	{r4, r5, r6, pc}
    3402:	4c13      	ldr	r4, [pc, #76]	; (3450 <CC_PalPowerSaveModeSelect+0x78>)
    3404:	6821      	ldr	r1, [r4, #0]
    3406:	b941      	cbnz	r1, 341a <CC_PalPowerSaveModeSelect+0x42>
    3408:	4b12      	ldr	r3, [pc, #72]	; (3454 <CC_PalPowerSaveModeSelect+0x7c>)
    340a:	2201      	movs	r2, #1
    340c:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
    3410:	4a11      	ldr	r2, [pc, #68]	; (3458 <CC_PalPowerSaveModeSelect+0x80>)
    3412:	f8d2 3910 	ldr.w	r3, [r2, #2320]	; 0x910
    3416:	2b00      	cmp	r3, #0
    3418:	d1fb      	bne.n	3412 <CC_PalPowerSaveModeSelect+0x3a>
    341a:	3101      	adds	r1, #1
    341c:	6021      	str	r1, [r4, #0]
    341e:	68f3      	ldr	r3, [r6, #12]
    3420:	6928      	ldr	r0, [r5, #16]
    3422:	4798      	blx	r3
    3424:	2000      	movs	r0, #0
    3426:	bd70      	pop	{r4, r5, r6, pc}
    3428:	480c      	ldr	r0, [pc, #48]	; (345c <CC_PalPowerSaveModeSelect+0x84>)
    342a:	bd70      	pop	{r4, r5, r6, pc}
    342c:	4a0a      	ldr	r2, [pc, #40]	; (3458 <CC_PalPowerSaveModeSelect+0x80>)
    342e:	f8d2 3910 	ldr.w	r3, [r2, #2320]	; 0x910
    3432:	2b00      	cmp	r3, #0
    3434:	d1fb      	bne.n	342e <CC_PalPowerSaveModeSelect+0x56>
    3436:	4a07      	ldr	r2, [pc, #28]	; (3454 <CC_PalPowerSaveModeSelect+0x7c>)
    3438:	f06f 407e 	mvn.w	r0, #4261412864	; 0xfe000000
    343c:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
    3440:	f7ff ff46 	bl	32d0 <CC_HalMaskInterrupt>
    3444:	6823      	ldr	r3, [r4, #0]
    3446:	e7d5      	b.n	33f4 <CC_PalPowerSaveModeSelect+0x1c>
    3448:	2000004c 	.word	0x2000004c
    344c:	2000003c 	.word	0x2000003c
    3450:	20001654 	.word	0x20001654
    3454:	5002a000 	.word	0x5002a000
    3458:	5002b000 	.word	0x5002b000
    345c:	ffff8fe9 	.word	0xffff8fe9

00003460 <mutex_free>:
    3460:	b510      	push	{r4, lr}
    3462:	4604      	mov	r4, r0
    3464:	b130      	cbz	r0, 3474 <mutex_free+0x14>
    3466:	6863      	ldr	r3, [r4, #4]
    3468:	06db      	lsls	r3, r3, #27
    346a:	d502      	bpl.n	3472 <mutex_free+0x12>
    346c:	2300      	movs	r3, #0
    346e:	6023      	str	r3, [r4, #0]
    3470:	6063      	str	r3, [r4, #4]
    3472:	bd10      	pop	{r4, pc}
    3474:	4b02      	ldr	r3, [pc, #8]	; (3480 <mutex_free+0x20>)
    3476:	4803      	ldr	r0, [pc, #12]	; (3484 <mutex_free+0x24>)
    3478:	685b      	ldr	r3, [r3, #4]
    347a:	4798      	blx	r3
    347c:	e7f3      	b.n	3466 <mutex_free+0x6>
    347e:	bf00      	nop
    3480:	20000018 	.word	0x20000018
    3484:	00006090 	.word	0x00006090

00003488 <mutex_lock>:
    3488:	b1b0      	cbz	r0, 34b8 <mutex_lock+0x30>
    348a:	6843      	ldr	r3, [r0, #4]
    348c:	b193      	cbz	r3, 34b4 <mutex_lock+0x2c>
    348e:	06db      	lsls	r3, r3, #27
    3490:	d50e      	bpl.n	34b0 <mutex_lock+0x28>
    3492:	2301      	movs	r3, #1
    3494:	e850 2f00 	ldrex	r2, [r0]
    3498:	4619      	mov	r1, r3
    349a:	e840 1c00 	strex	ip, r1, [r0]
    349e:	f09c 0f00 	teq	ip, #0
    34a2:	d1f7      	bne.n	3494 <mutex_lock+0xc>
    34a4:	2a01      	cmp	r2, #1
    34a6:	d0f5      	beq.n	3494 <mutex_lock+0xc>
    34a8:	f3bf 8f5f 	dmb	sy
    34ac:	2000      	movs	r0, #0
    34ae:	4770      	bx	lr
    34b0:	4803      	ldr	r0, [pc, #12]	; (34c0 <mutex_lock+0x38>)
    34b2:	4770      	bx	lr
    34b4:	4803      	ldr	r0, [pc, #12]	; (34c4 <mutex_lock+0x3c>)
    34b6:	4770      	bx	lr
    34b8:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    34bc:	4770      	bx	lr
    34be:	bf00      	nop
    34c0:	ffff8fe9 	.word	0xffff8fe9
    34c4:	ffff8fea 	.word	0xffff8fea

000034c8 <mutex_unlock>:
    34c8:	b168      	cbz	r0, 34e6 <mutex_unlock+0x1e>
    34ca:	6843      	ldr	r3, [r0, #4]
    34cc:	b13b      	cbz	r3, 34de <mutex_unlock+0x16>
    34ce:	06db      	lsls	r3, r3, #27
    34d0:	d507      	bpl.n	34e2 <mutex_unlock+0x1a>
    34d2:	f3bf 8f5f 	dmb	sy
    34d6:	2300      	movs	r3, #0
    34d8:	6003      	str	r3, [r0, #0]
    34da:	4618      	mov	r0, r3
    34dc:	4770      	bx	lr
    34de:	4803      	ldr	r0, [pc, #12]	; (34ec <mutex_unlock+0x24>)
    34e0:	4770      	bx	lr
    34e2:	4803      	ldr	r0, [pc, #12]	; (34f0 <mutex_unlock+0x28>)
    34e4:	4770      	bx	lr
    34e6:	f46f 40e0 	mvn.w	r0, #28672	; 0x7000
    34ea:	4770      	bx	lr
    34ec:	ffff8fea 	.word	0xffff8fea
    34f0:	ffff8fe9 	.word	0xffff8fe9

000034f4 <mutex_init>:
    34f4:	b510      	push	{r4, lr}
    34f6:	4604      	mov	r4, r0
    34f8:	b120      	cbz	r0, 3504 <mutex_init+0x10>
    34fa:	2200      	movs	r2, #0
    34fc:	2311      	movs	r3, #17
    34fe:	6022      	str	r2, [r4, #0]
    3500:	6063      	str	r3, [r4, #4]
    3502:	bd10      	pop	{r4, pc}
    3504:	4801      	ldr	r0, [pc, #4]	; (350c <mutex_init+0x18>)
    3506:	f7ff fe7f 	bl	3208 <CC_PalAbort>
    350a:	e7f6      	b.n	34fa <mutex_init+0x6>
    350c:	000060b8 	.word	0x000060b8

00003510 <verify_context_ecdsa_verify_secp256r1>:
    3510:	b130      	cbz	r0, 3520 <verify_context_ecdsa_verify_secp256r1+0x10>
    3512:	6802      	ldr	r2, [r0, #0]
    3514:	4b03      	ldr	r3, [pc, #12]	; (3524 <verify_context_ecdsa_verify_secp256r1+0x14>)
    3516:	4804      	ldr	r0, [pc, #16]	; (3528 <verify_context_ecdsa_verify_secp256r1+0x18>)
    3518:	429a      	cmp	r2, r3
    351a:	bf08      	it	eq
    351c:	2000      	moveq	r0, #0
    351e:	4770      	bx	lr
    3520:	4802      	ldr	r0, [pc, #8]	; (352c <verify_context_ecdsa_verify_secp256r1+0x1c>)
    3522:	4770      	bx	lr
    3524:	bbaa55dd 	.word	0xbbaa55dd
    3528:	00f00882 	.word	0x00f00882
    352c:	00f00871 	.word	0x00f00871

00003530 <nrf_cc310_bl_ecdsa_verify_init_secp256r1>:
    3530:	b538      	push	{r3, r4, r5, lr}
    3532:	460d      	mov	r5, r1
    3534:	4604      	mov	r4, r0
    3536:	b1b0      	cbz	r0, 3566 <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x36>
    3538:	22a0      	movs	r2, #160	; 0xa0
    353a:	2100      	movs	r1, #0
    353c:	3004      	adds	r0, #4
    353e:	f002 fb74 	bl	5c2a <SaSi_PalMemSet>
    3542:	b195      	cbz	r5, 356a <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x3a>
    3544:	2208      	movs	r2, #8
    3546:	4629      	mov	r1, r5
    3548:	f104 0064 	add.w	r0, r4, #100	; 0x64
    354c:	f002 fb73 	bl	5c36 <CRYS_COMMON_ReverseMemcpy32>
    3550:	2208      	movs	r2, #8
    3552:	f105 0120 	add.w	r1, r5, #32
    3556:	f104 0084 	add.w	r0, r4, #132	; 0x84
    355a:	f002 fb6c 	bl	5c36 <CRYS_COMMON_ReverseMemcpy32>
    355e:	4b04      	ldr	r3, [pc, #16]	; (3570 <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x40>)
    3560:	6023      	str	r3, [r4, #0]
    3562:	2000      	movs	r0, #0
    3564:	bd38      	pop	{r3, r4, r5, pc}
    3566:	4803      	ldr	r0, [pc, #12]	; (3574 <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x44>)
    3568:	e7fc      	b.n	3564 <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x34>
    356a:	4803      	ldr	r0, [pc, #12]	; (3578 <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x48>)
    356c:	e7fa      	b.n	3564 <nrf_cc310_bl_ecdsa_verify_init_secp256r1+0x34>
    356e:	bf00      	nop
    3570:	bbaa55dd 	.word	0xbbaa55dd
    3574:	00f00871 	.word	0x00f00871
    3578:	00f00883 	.word	0x00f00883

0000357c <nrf_cc310_bl_ecdsa_verify_hash_secp256r1>:
    357c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    3580:	4605      	mov	r5, r0
    3582:	460e      	mov	r6, r1
    3584:	4699      	mov	r9, r3
    3586:	4611      	mov	r1, r2
    3588:	f7ff ffc2 	bl	3510 <verify_context_ecdsa_verify_secp256r1>
    358c:	4604      	mov	r4, r0
    358e:	2800      	cmp	r0, #0
    3590:	f040 8084 	bne.w	369c <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x120>
    3594:	2e00      	cmp	r6, #0
    3596:	f000 8085 	beq.w	36a4 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x128>
    359a:	2900      	cmp	r1, #0
    359c:	f000 8084 	beq.w	36a8 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x12c>
    35a0:	f1b9 0f20 	cmp.w	r9, #32
    35a4:	f040 8082 	bne.w	36ac <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x130>
    35a8:	f105 0444 	add.w	r4, r5, #68	; 0x44
    35ac:	2208      	movs	r2, #8
    35ae:	f105 0804 	add.w	r8, r5, #4
    35b2:	4620      	mov	r0, r4
    35b4:	f002 fb3f 	bl	5c36 <CRYS_COMMON_ReverseMemcpy32>
    35b8:	f105 0724 	add.w	r7, r5, #36	; 0x24
    35bc:	2208      	movs	r2, #8
    35be:	4631      	mov	r1, r6
    35c0:	4640      	mov	r0, r8
    35c2:	f002 fb38 	bl	5c36 <CRYS_COMMON_ReverseMemcpy32>
    35c6:	f106 0120 	add.w	r1, r6, #32
    35ca:	2208      	movs	r2, #8
    35cc:	4638      	mov	r0, r7
    35ce:	f002 fb32 	bl	5c36 <CRYS_COMMON_ReverseMemcpy32>
    35d2:	a902      	add	r1, sp, #8
    35d4:	f44f 7080 	mov.w	r0, #256	; 0x100
    35d8:	f841 9d04 	str.w	r9, [r1, #-4]!
    35dc:	f002 fb1f 	bl	5c1e <PkaInitAndMutexLock>
    35e0:	2800      	cmp	r0, #0
    35e2:	d165      	bne.n	36b0 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x134>
    35e4:	4a33      	ldr	r2, [pc, #204]	; (36b4 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x138>)
    35e6:	f44f 7380 	mov.w	r3, #256	; 0x100
    35ea:	6013      	str	r3, [r2, #0]
    35ec:	2101      	movs	r1, #1
    35ee:	6093      	str	r3, [r2, #8]
    35f0:	2308      	movs	r3, #8
    35f2:	4a31      	ldr	r2, [pc, #196]	; (36b8 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x13c>)
    35f4:	f000 fb2e 	bl	3c54 <PkaCopyDataIntoPkaReg>
    35f8:	2101      	movs	r1, #1
    35fa:	4608      	mov	r0, r1
    35fc:	2305      	movs	r3, #5
    35fe:	4a2f      	ldr	r2, [pc, #188]	; (36bc <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x140>)
    3600:	f000 fb28 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3604:	2308      	movs	r3, #8
    3606:	4642      	mov	r2, r8
    3608:	2101      	movs	r1, #1
    360a:	201c      	movs	r0, #28
    360c:	f000 fb22 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3610:	2308      	movs	r3, #8
    3612:	463a      	mov	r2, r7
    3614:	2101      	movs	r1, #1
    3616:	2003      	movs	r0, #3
    3618:	f000 fb1c 	bl	3c54 <PkaCopyDataIntoPkaReg>
    361c:	4622      	mov	r2, r4
    361e:	2308      	movs	r3, #8
    3620:	2101      	movs	r1, #1
    3622:	2002      	movs	r0, #2
    3624:	f000 fb16 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3628:	2308      	movs	r3, #8
    362a:	4a25      	ldr	r2, [pc, #148]	; (36c0 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x144>)
    362c:	2101      	movs	r1, #1
    362e:	201a      	movs	r0, #26
    3630:	f000 fb10 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3634:	2305      	movs	r3, #5
    3636:	4a23      	ldr	r2, [pc, #140]	; (36c4 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x148>)
    3638:	2101      	movs	r1, #1
    363a:	201b      	movs	r0, #27
    363c:	f000 fb0a 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3640:	2308      	movs	r3, #8
    3642:	4a21      	ldr	r2, [pc, #132]	; (36c8 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x14c>)
    3644:	2101      	movs	r1, #1
    3646:	2014      	movs	r0, #20
    3648:	f000 fb04 	bl	3c54 <PkaCopyDataIntoPkaReg>
    364c:	2308      	movs	r3, #8
    364e:	4a1f      	ldr	r2, [pc, #124]	; (36cc <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x150>)
    3650:	2101      	movs	r1, #1
    3652:	2015      	movs	r0, #21
    3654:	f000 fafe 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3658:	2308      	movs	r3, #8
    365a:	f105 0264 	add.w	r2, r5, #100	; 0x64
    365e:	2101      	movs	r1, #1
    3660:	2016      	movs	r0, #22
    3662:	f000 faf7 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3666:	2308      	movs	r3, #8
    3668:	f105 0284 	add.w	r2, r5, #132	; 0x84
    366c:	2101      	movs	r1, #1
    366e:	2017      	movs	r0, #23
    3670:	f000 faf0 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3674:	2308      	movs	r3, #8
    3676:	4a16      	ldr	r2, [pc, #88]	; (36d0 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x154>)
    3678:	2101      	movs	r1, #1
    367a:	200b      	movs	r0, #11
    367c:	f000 faea 	bl	3c54 <PkaCopyDataIntoPkaReg>
    3680:	f000 fb44 	bl	3d0c <PkaEcdsaVerify>
    3684:	4604      	mov	r4, r0
    3686:	9801      	ldr	r0, [sp, #4]
    3688:	f000 fad2 	bl	3c30 <PkaFinishAndMutexUnlock>
    368c:	4b11      	ldr	r3, [pc, #68]	; (36d4 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x158>)
    368e:	2c00      	cmp	r4, #0
    3690:	bf18      	it	ne
    3692:	461c      	movne	r4, r3
    3694:	21a4      	movs	r1, #164	; 0xa4
    3696:	4628      	mov	r0, r5
    3698:	f002 fac9 	bl	5c2e <SaSi_PalMemSetZero>
    369c:	4620      	mov	r0, r4
    369e:	b003      	add	sp, #12
    36a0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    36a4:	4c0c      	ldr	r4, [pc, #48]	; (36d8 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x15c>)
    36a6:	e7f9      	b.n	369c <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x120>
    36a8:	4c0c      	ldr	r4, [pc, #48]	; (36dc <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x160>)
    36aa:	e7f7      	b.n	369c <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x120>
    36ac:	4c0c      	ldr	r4, [pc, #48]	; (36e0 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x164>)
    36ae:	e7f5      	b.n	369c <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x120>
    36b0:	4c08      	ldr	r4, [pc, #32]	; (36d4 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x158>)
    36b2:	e7ef      	b.n	3694 <nrf_cc310_bl_ecdsa_verify_hash_secp256r1+0x118>
    36b4:	5002b090 	.word	0x5002b090
    36b8:	0000611c 	.word	0x0000611c
    36bc:	00006194 	.word	0x00006194
    36c0:	000060dc 	.word	0x000060dc
    36c4:	00006180 	.word	0x00006180
    36c8:	00006140 	.word	0x00006140
    36cc:	00006160 	.word	0x00006160
    36d0:	000060fc 	.word	0x000060fc
    36d4:	00f00884 	.word	0x00f00884
    36d8:	00f00876 	.word	0x00f00876
    36dc:	00f00880 	.word	0x00f00880
    36e0:	00f00881 	.word	0x00f00881

000036e4 <set_digest_in_hw_sha256>:
    36e4:	4b0c      	ldr	r3, [pc, #48]	; (3718 <set_digest_in_hw_sha256+0x34>)
    36e6:	69c2      	ldr	r2, [r0, #28]
    36e8:	601a      	str	r2, [r3, #0]
    36ea:	6982      	ldr	r2, [r0, #24]
    36ec:	f843 2c04 	str.w	r2, [r3, #-4]
    36f0:	6942      	ldr	r2, [r0, #20]
    36f2:	f843 2c08 	str.w	r2, [r3, #-8]
    36f6:	6902      	ldr	r2, [r0, #16]
    36f8:	f843 2c0c 	str.w	r2, [r3, #-12]
    36fc:	68c2      	ldr	r2, [r0, #12]
    36fe:	f843 2c10 	str.w	r2, [r3, #-16]
    3702:	6882      	ldr	r2, [r0, #8]
    3704:	f843 2c14 	str.w	r2, [r3, #-20]
    3708:	6842      	ldr	r2, [r0, #4]
    370a:	f843 2c18 	str.w	r2, [r3, #-24]
    370e:	6802      	ldr	r2, [r0, #0]
    3710:	f843 2c1c 	str.w	r2, [r3, #-28]
    3714:	4770      	bx	lr
    3716:	bf00      	nop
    3718:	5002b65c 	.word	0x5002b65c

0000371c <read_digest_in_hw_sha256>:
    371c:	4b0c      	ldr	r3, [pc, #48]	; (3750 <read_digest_in_hw_sha256+0x34>)
    371e:	681b      	ldr	r3, [r3, #0]
    3720:	61c3      	str	r3, [r0, #28]
    3722:	4b0c      	ldr	r3, [pc, #48]	; (3754 <read_digest_in_hw_sha256+0x38>)
    3724:	681b      	ldr	r3, [r3, #0]
    3726:	6183      	str	r3, [r0, #24]
    3728:	4b0b      	ldr	r3, [pc, #44]	; (3758 <read_digest_in_hw_sha256+0x3c>)
    372a:	681b      	ldr	r3, [r3, #0]
    372c:	6143      	str	r3, [r0, #20]
    372e:	4b0b      	ldr	r3, [pc, #44]	; (375c <read_digest_in_hw_sha256+0x40>)
    3730:	681b      	ldr	r3, [r3, #0]
    3732:	6103      	str	r3, [r0, #16]
    3734:	4b0a      	ldr	r3, [pc, #40]	; (3760 <read_digest_in_hw_sha256+0x44>)
    3736:	681b      	ldr	r3, [r3, #0]
    3738:	60c3      	str	r3, [r0, #12]
    373a:	4b0a      	ldr	r3, [pc, #40]	; (3764 <read_digest_in_hw_sha256+0x48>)
    373c:	681b      	ldr	r3, [r3, #0]
    373e:	6083      	str	r3, [r0, #8]
    3740:	4b09      	ldr	r3, [pc, #36]	; (3768 <read_digest_in_hw_sha256+0x4c>)
    3742:	681b      	ldr	r3, [r3, #0]
    3744:	6043      	str	r3, [r0, #4]
    3746:	4b09      	ldr	r3, [pc, #36]	; (376c <read_digest_in_hw_sha256+0x50>)
    3748:	681b      	ldr	r3, [r3, #0]
    374a:	6003      	str	r3, [r0, #0]
    374c:	4770      	bx	lr
    374e:	bf00      	nop
    3750:	5002b65c 	.word	0x5002b65c
    3754:	5002b658 	.word	0x5002b658
    3758:	5002b654 	.word	0x5002b654
    375c:	5002b650 	.word	0x5002b650
    3760:	5002b64c 	.word	0x5002b64c
    3764:	5002b648 	.word	0x5002b648
    3768:	5002b644 	.word	0x5002b644
    376c:	5002b640 	.word	0x5002b640

00003770 <verify_context_hash_sha256>:
    3770:	b130      	cbz	r0, 3780 <verify_context_hash_sha256+0x10>
    3772:	6802      	ldr	r2, [r0, #0]
    3774:	4b03      	ldr	r3, [pc, #12]	; (3784 <verify_context_hash_sha256+0x14>)
    3776:	4804      	ldr	r0, [pc, #16]	; (3788 <verify_context_hash_sha256+0x18>)
    3778:	429a      	cmp	r2, r3
    377a:	bf08      	it	eq
    377c:	2000      	moveq	r0, #0
    377e:	4770      	bx	lr
    3780:	4802      	ldr	r0, [pc, #8]	; (378c <verify_context_hash_sha256+0x1c>)
    3782:	4770      	bx	lr
    3784:	bbaa55dd 	.word	0xbbaa55dd
    3788:	00f00202 	.word	0x00f00202
    378c:	00f00200 	.word	0x00f00200

00003790 <nrf_cc310_bl_hash_sha256_init>:
    3790:	b538      	push	{r3, r4, r5, lr}
    3792:	4604      	mov	r4, r0
    3794:	b168      	cbz	r0, 37b2 <nrf_cc310_bl_hash_sha256_init+0x22>
    3796:	1d05      	adds	r5, r0, #4
    3798:	2170      	movs	r1, #112	; 0x70
    379a:	4628      	mov	r0, r5
    379c:	f002 fa47 	bl	5c2e <SaSi_PalMemSetZero>
    37a0:	4628      	mov	r0, r5
    37a2:	2220      	movs	r2, #32
    37a4:	4904      	ldr	r1, [pc, #16]	; (37b8 <nrf_cc310_bl_hash_sha256_init+0x28>)
    37a6:	f002 fa3e 	bl	5c26 <SaSi_PalMemCopy>
    37aa:	4b04      	ldr	r3, [pc, #16]	; (37bc <nrf_cc310_bl_hash_sha256_init+0x2c>)
    37ac:	6023      	str	r3, [r4, #0]
    37ae:	2000      	movs	r0, #0
    37b0:	bd38      	pop	{r3, r4, r5, pc}
    37b2:	4803      	ldr	r0, [pc, #12]	; (37c0 <nrf_cc310_bl_hash_sha256_init+0x30>)
    37b4:	e7fc      	b.n	37b0 <nrf_cc310_bl_hash_sha256_init+0x20>
    37b6:	bf00      	nop
    37b8:	000061a8 	.word	0x000061a8
    37bc:	bbaa55dd 	.word	0xbbaa55dd
    37c0:	00f00200 	.word	0x00f00200

000037c4 <nrf_cc310_bl_hash_sha256_update>:
    37c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    37c8:	4b28      	ldr	r3, [pc, #160]	; (386c <nrf_cc310_bl_hash_sha256_update+0xa8>)
    37ca:	4604      	mov	r4, r0
    37cc:	460e      	mov	r6, r1
    37ce:	4615      	mov	r5, r2
    37d0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    37d2:	b085      	sub	sp, #20
    37d4:	466f      	mov	r7, sp
    37d6:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    37da:	b92d      	cbnz	r5, 37e8 <nrf_cc310_bl_hash_sha256_update+0x24>
    37dc:	f04f 0900 	mov.w	r9, #0
    37e0:	4648      	mov	r0, r9
    37e2:	b005      	add	sp, #20
    37e4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    37e8:	4620      	mov	r0, r4
    37ea:	f7ff ffc1 	bl	3770 <verify_context_hash_sha256>
    37ee:	4681      	mov	r9, r0
    37f0:	2800      	cmp	r0, #0
    37f2:	d1f5      	bne.n	37e0 <nrf_cc310_bl_hash_sha256_update+0x1c>
    37f4:	1d23      	adds	r3, r4, #4
    37f6:	9301      	str	r3, [sp, #4]
    37f8:	6a63      	ldr	r3, [r4, #36]	; 0x24
    37fa:	bba3      	cbnz	r3, 3866 <nrf_cc310_bl_hash_sha256_update+0xa2>
    37fc:	6f23      	ldr	r3, [r4, #112]	; 0x70
    37fe:	b18b      	cbz	r3, 3824 <nrf_cc310_bl_hash_sha256_update+0x60>
    3800:	f1c3 0840 	rsb	r8, r3, #64	; 0x40
    3804:	45a8      	cmp	r8, r5
    3806:	bf28      	it	cs
    3808:	46a8      	movcs	r8, r5
    380a:	f104 0030 	add.w	r0, r4, #48	; 0x30
    380e:	4631      	mov	r1, r6
    3810:	4418      	add	r0, r3
    3812:	4642      	mov	r2, r8
    3814:	f002 fa07 	bl	5c26 <SaSi_PalMemCopy>
    3818:	6f23      	ldr	r3, [r4, #112]	; 0x70
    381a:	4443      	add	r3, r8
    381c:	4446      	add	r6, r8
    381e:	6723      	str	r3, [r4, #112]	; 0x70
    3820:	eba5 0508 	sub.w	r5, r5, r8
    3824:	6f22      	ldr	r2, [r4, #112]	; 0x70
    3826:	2a40      	cmp	r2, #64	; 0x40
    3828:	d106      	bne.n	3838 <nrf_cc310_bl_hash_sha256_update+0x74>
    382a:	f104 0130 	add.w	r1, r4, #48	; 0x30
    382e:	4638      	mov	r0, r7
    3830:	f000 fbae 	bl	3f90 <nrf_cc310_bl_hash_update_internal>
    3834:	2300      	movs	r3, #0
    3836:	6723      	str	r3, [r4, #112]	; 0x70
    3838:	f005 083f 	and.w	r8, r5, #63	; 0x3f
    383c:	f035 053f 	bics.w	r5, r5, #63	; 0x3f
    3840:	d005      	beq.n	384e <nrf_cc310_bl_hash_sha256_update+0x8a>
    3842:	4631      	mov	r1, r6
    3844:	462a      	mov	r2, r5
    3846:	4638      	mov	r0, r7
    3848:	f000 fba2 	bl	3f90 <nrf_cc310_bl_hash_update_internal>
    384c:	442e      	add	r6, r5
    384e:	f1b8 0f00 	cmp.w	r8, #0
    3852:	d0c3      	beq.n	37dc <nrf_cc310_bl_hash_sha256_update+0x18>
    3854:	4642      	mov	r2, r8
    3856:	4631      	mov	r1, r6
    3858:	f104 0030 	add.w	r0, r4, #48	; 0x30
    385c:	f002 f9e3 	bl	5c26 <SaSi_PalMemCopy>
    3860:	f8c4 8070 	str.w	r8, [r4, #112]	; 0x70
    3864:	e7bc      	b.n	37e0 <nrf_cc310_bl_hash_sha256_update+0x1c>
    3866:	f8df 9008 	ldr.w	r9, [pc, #8]	; 3870 <nrf_cc310_bl_hash_sha256_update+0xac>
    386a:	e7b9      	b.n	37e0 <nrf_cc310_bl_hash_sha256_update+0x1c>
    386c:	00005e70 	.word	0x00005e70
    3870:	00f0020c 	.word	0x00f0020c

00003874 <nrf_cc310_bl_hash_sha256_finalize>:
    3874:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
    3878:	4b14      	ldr	r3, [pc, #80]	; (38cc <nrf_cc310_bl_hash_sha256_finalize+0x58>)
    387a:	4604      	mov	r4, r0
    387c:	460e      	mov	r6, r1
    387e:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
    3880:	466f      	mov	r7, sp
    3882:	e887 000f 	stmia.w	r7, {r0, r1, r2, r3}
    3886:	4620      	mov	r0, r4
    3888:	f7ff ff72 	bl	3770 <verify_context_hash_sha256>
    388c:	4680      	mov	r8, r0
    388e:	b9b0      	cbnz	r0, 38be <nrf_cc310_bl_hash_sha256_finalize+0x4a>
    3890:	b1ce      	cbz	r6, 38c6 <nrf_cc310_bl_hash_sha256_finalize+0x52>
    3892:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3894:	1d25      	adds	r5, r4, #4
    3896:	9501      	str	r5, [sp, #4]
    3898:	b93b      	cbnz	r3, 38aa <nrf_cc310_bl_hash_sha256_finalize+0x36>
    389a:	2301      	movs	r3, #1
    389c:	6263      	str	r3, [r4, #36]	; 0x24
    389e:	6f22      	ldr	r2, [r4, #112]	; 0x70
    38a0:	f104 0130 	add.w	r1, r4, #48	; 0x30
    38a4:	4638      	mov	r0, r7
    38a6:	f000 fb73 	bl	3f90 <nrf_cc310_bl_hash_update_internal>
    38aa:	462b      	mov	r3, r5
    38ac:	3e04      	subs	r6, #4
    38ae:	3424      	adds	r4, #36	; 0x24
    38b0:	f853 2b04 	ldr.w	r2, [r3], #4
    38b4:	ba12      	rev	r2, r2
    38b6:	42a3      	cmp	r3, r4
    38b8:	f846 2f04 	str.w	r2, [r6, #4]!
    38bc:	d1f8      	bne.n	38b0 <nrf_cc310_bl_hash_sha256_finalize+0x3c>
    38be:	4640      	mov	r0, r8
    38c0:	b004      	add	sp, #16
    38c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    38c6:	f8df 8008 	ldr.w	r8, [pc, #8]	; 38d0 <nrf_cc310_bl_hash_sha256_finalize+0x5c>
    38ca:	e7f8      	b.n	38be <nrf_cc310_bl_hash_sha256_finalize+0x4a>
    38cc:	00005e70 	.word	0x00005e70
    38d0:	00f00205 	.word	0x00f00205

000038d4 <nrf_cc310_bl_init>:
    38d4:	4b08      	ldr	r3, [pc, #32]	; (38f8 <nrf_cc310_bl_init+0x24>)
    38d6:	681b      	ldr	r3, [r3, #0]
    38d8:	0e1b      	lsrs	r3, r3, #24
    38da:	2bf0      	cmp	r3, #240	; 0xf0
    38dc:	d108      	bne.n	38f0 <nrf_cc310_bl_init+0x1c>
    38de:	4b07      	ldr	r3, [pc, #28]	; (38fc <nrf_cc310_bl_init+0x28>)
    38e0:	681a      	ldr	r2, [r3, #0]
    38e2:	4b07      	ldr	r3, [pc, #28]	; (3900 <nrf_cc310_bl_init+0x2c>)
    38e4:	429a      	cmp	r2, r3
    38e6:	d105      	bne.n	38f4 <nrf_cc310_bl_init+0x20>
    38e8:	4b06      	ldr	r3, [pc, #24]	; (3904 <nrf_cc310_bl_init+0x30>)
    38ea:	2000      	movs	r0, #0
    38ec:	6018      	str	r0, [r3, #0]
    38ee:	4770      	bx	lr
    38f0:	2005      	movs	r0, #5
    38f2:	4770      	bx	lr
    38f4:	2006      	movs	r0, #6
    38f6:	4770      	bx	lr
    38f8:	5002b928 	.word	0x5002b928
    38fc:	5002ba24 	.word	0x5002ba24
    3900:	20e00000 	.word	0x20e00000
    3904:	5002ba0c 	.word	0x5002ba0c

00003908 <PkaSetRegsMapTab>:
    3908:	2200      	movs	r2, #0
    390a:	b530      	push	{r4, r5, lr}
    390c:	0049      	lsls	r1, r1, #1
    390e:	4613      	mov	r3, r2
    3910:	3802      	subs	r0, #2
    3912:	f640 75fc 	movw	r5, #4092	; 0xffc
    3916:	f102 54a0 	add.w	r4, r2, #335544320	; 0x14000000
    391a:	f504 442c 	add.w	r4, r4, #44032	; 0xac00
    391e:	00a4      	lsls	r4, r4, #2
    3920:	4290      	cmp	r0, r2
    3922:	f102 0201 	add.w	r2, r2, #1
    3926:	bfca      	itet	gt
    3928:	6023      	strgt	r3, [r4, #0]
    392a:	6025      	strle	r5, [r4, #0]
    392c:	185b      	addgt	r3, r3, r1
    392e:	2a1e      	cmp	r2, #30
    3930:	d1f1      	bne.n	3916 <PkaSetRegsMapTab+0xe>
    3932:	4a04      	ldr	r2, [pc, #16]	; (3944 <PkaSetRegsMapTab+0x3c>)
    3934:	6013      	str	r3, [r2, #0]
    3936:	440b      	add	r3, r1
    3938:	6053      	str	r3, [r2, #4]
    393a:	4b03      	ldr	r3, [pc, #12]	; (3948 <PkaSetRegsMapTab+0x40>)
    393c:	4a03      	ldr	r2, [pc, #12]	; (394c <PkaSetRegsMapTab+0x44>)
    393e:	601a      	str	r2, [r3, #0]
    3940:	bd30      	pop	{r4, r5, pc}
    3942:	bf00      	nop
    3944:	5002b078 	.word	0x5002b078
    3948:	5002b084 	.word	0x5002b084
    394c:	000ff820 	.word	0x000ff820

00003950 <PkaGetRegEffectiveSizeInBits>:
    3950:	b530      	push	{r4, r5, lr}
    3952:	4b1e      	ldr	r3, [pc, #120]	; (39cc <PkaGetRegEffectiveSizeInBits+0x7c>)
    3954:	b085      	sub	sp, #20
    3956:	461a      	mov	r2, r3
    3958:	6819      	ldr	r1, [r3, #0]
    395a:	9100      	str	r1, [sp, #0]
    395c:	9900      	ldr	r1, [sp, #0]
    395e:	07cc      	lsls	r4, r1, #31
    3960:	d5fa      	bpl.n	3958 <PkaGetRegEffectiveSizeInBits+0x8>
    3962:	f100 50a0 	add.w	r0, r0, #335544320	; 0x14000000
    3966:	f500 402c 	add.w	r0, r0, #44032	; 0xac00
    396a:	0080      	lsls	r0, r0, #2
    396c:	6801      	ldr	r1, [r0, #0]
    396e:	6813      	ldr	r3, [r2, #0]
    3970:	9301      	str	r3, [sp, #4]
    3972:	9b01      	ldr	r3, [sp, #4]
    3974:	07d8      	lsls	r0, r3, #31
    3976:	d5fa      	bpl.n	396e <PkaGetRegEffectiveSizeInBits+0x1e>
    3978:	4b15      	ldr	r3, [pc, #84]	; (39d0 <PkaGetRegEffectiveSizeInBits+0x80>)
    397a:	4c16      	ldr	r4, [pc, #88]	; (39d4 <PkaGetRegEffectiveSizeInBits+0x84>)
    397c:	6818      	ldr	r0, [r3, #0]
    397e:	4d16      	ldr	r5, [pc, #88]	; (39d8 <PkaGetRegEffectiveSizeInBits+0x88>)
    3980:	301f      	adds	r0, #31
    3982:	2320      	movs	r3, #32
    3984:	fb90 f0f3 	sdiv	r0, r0, r3
    3988:	3801      	subs	r0, #1
    398a:	2800      	cmp	r0, #0
    398c:	da10      	bge.n	39b0 <PkaGetRegEffectiveSizeInBits+0x60>
    398e:	2300      	movs	r3, #0
    3990:	3001      	adds	r0, #1
    3992:	0140      	lsls	r0, r0, #5
    3994:	b153      	cbz	r3, 39ac <PkaGetRegEffectiveSizeInBits+0x5c>
    3996:	f1a0 0120 	sub.w	r1, r0, #32
    399a:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    399e:	4213      	tst	r3, r2
    39a0:	d104      	bne.n	39ac <PkaGetRegEffectiveSizeInBits+0x5c>
    39a2:	3801      	subs	r0, #1
    39a4:	4288      	cmp	r0, r1
    39a6:	ea4f 0252 	mov.w	r2, r2, lsr #1
    39aa:	d1f8      	bne.n	399e <PkaGetRegEffectiveSizeInBits+0x4e>
    39ac:	b005      	add	sp, #20
    39ae:	bd30      	pop	{r4, r5, pc}
    39b0:	6813      	ldr	r3, [r2, #0]
    39b2:	9303      	str	r3, [sp, #12]
    39b4:	9b03      	ldr	r3, [sp, #12]
    39b6:	07db      	lsls	r3, r3, #31
    39b8:	d5fa      	bpl.n	39b0 <PkaGetRegEffectiveSizeInBits+0x60>
    39ba:	1843      	adds	r3, r0, r1
    39bc:	6023      	str	r3, [r4, #0]
    39be:	682b      	ldr	r3, [r5, #0]
    39c0:	9302      	str	r3, [sp, #8]
    39c2:	9b02      	ldr	r3, [sp, #8]
    39c4:	2b00      	cmp	r3, #0
    39c6:	d1e3      	bne.n	3990 <PkaGetRegEffectiveSizeInBits+0x40>
    39c8:	3801      	subs	r0, #1
    39ca:	e7de      	b.n	398a <PkaGetRegEffectiveSizeInBits+0x3a>
    39cc:	5002b0b4 	.word	0x5002b0b4
    39d0:	5002b0ac 	.word	0x5002b0ac
    39d4:	5002b0e4 	.word	0x5002b0e4
    39d8:	5002b0dc 	.word	0x5002b0dc

000039dc <PkaGetNextMsBit>:
    39dc:	b5f0      	push	{r4, r5, r6, r7, lr}
    39de:	681d      	ldr	r5, [r3, #0]
    39e0:	b085      	sub	sp, #20
    39e2:	f001 041f 	and.w	r4, r1, #31
    39e6:	b90d      	cbnz	r5, 39ec <PkaGetNextMsBit+0x10>
    39e8:	2c1f      	cmp	r4, #31
    39ea:	d125      	bne.n	3a38 <PkaGetNextMsBit+0x5c>
    39ec:	4d15      	ldr	r5, [pc, #84]	; (3a44 <PkaGetNextMsBit+0x68>)
    39ee:	462e      	mov	r6, r5
    39f0:	682f      	ldr	r7, [r5, #0]
    39f2:	9701      	str	r7, [sp, #4]
    39f4:	9f01      	ldr	r7, [sp, #4]
    39f6:	07ff      	lsls	r7, r7, #31
    39f8:	d5fa      	bpl.n	39f0 <PkaGetNextMsBit+0x14>
    39fa:	f100 50a0 	add.w	r0, r0, #335544320	; 0x14000000
    39fe:	f500 402c 	add.w	r0, r0, #44032	; 0xac00
    3a02:	0080      	lsls	r0, r0, #2
    3a04:	6800      	ldr	r0, [r0, #0]
    3a06:	6835      	ldr	r5, [r6, #0]
    3a08:	9503      	str	r5, [sp, #12]
    3a0a:	9d03      	ldr	r5, [sp, #12]
    3a0c:	07ed      	lsls	r5, r5, #31
    3a0e:	d5fa      	bpl.n	3a06 <PkaGetNextMsBit+0x2a>
    3a10:	4d0d      	ldr	r5, [pc, #52]	; (3a48 <PkaGetNextMsBit+0x6c>)
    3a12:	eb00 1061 	add.w	r0, r0, r1, asr #5
    3a16:	6028      	str	r0, [r5, #0]
    3a18:	480c      	ldr	r0, [pc, #48]	; (3a4c <PkaGetNextMsBit+0x70>)
    3a1a:	6800      	ldr	r0, [r0, #0]
    3a1c:	9002      	str	r0, [sp, #8]
    3a1e:	2c1f      	cmp	r4, #31
    3a20:	bf18      	it	ne
    3a22:	43c9      	mvnne	r1, r1
    3a24:	9802      	ldr	r0, [sp, #8]
    3a26:	bf0f      	iteee	eq
    3a28:	6010      	streq	r0, [r2, #0]
    3a2a:	f001 011f 	andne.w	r1, r1, #31
    3a2e:	fa00 f101 	lslne.w	r1, r0, r1
    3a32:	6011      	strne	r1, [r2, #0]
    3a34:	2100      	movs	r1, #0
    3a36:	6019      	str	r1, [r3, #0]
    3a38:	6810      	ldr	r0, [r2, #0]
    3a3a:	0043      	lsls	r3, r0, #1
    3a3c:	0fc0      	lsrs	r0, r0, #31
    3a3e:	6013      	str	r3, [r2, #0]
    3a40:	b005      	add	sp, #20
    3a42:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3a44:	5002b0b4 	.word	0x5002b0b4
    3a48:	5002b0e4 	.word	0x5002b0e4
    3a4c:	5002b0dc 	.word	0x5002b0dc

00003a50 <PkaSetRegsSizesTab>:
    3a50:	4b0c      	ldr	r3, [pc, #48]	; (3a84 <PkaSetRegsSizesTab+0x34>)
    3a52:	6018      	str	r0, [r3, #0]
    3a54:	303f      	adds	r0, #63	; 0x3f
    3a56:	f020 003f 	bic.w	r0, r0, #63	; 0x3f
    3a5a:	0189      	lsls	r1, r1, #6
    3a5c:	3040      	adds	r0, #64	; 0x40
    3a5e:	6058      	str	r0, [r3, #4]
    3a60:	6099      	str	r1, [r3, #8]
    3a62:	60d9      	str	r1, [r3, #12]
    3a64:	6119      	str	r1, [r3, #16]
    3a66:	6159      	str	r1, [r3, #20]
    3a68:	6199      	str	r1, [r3, #24]
    3a6a:	331c      	adds	r3, #28
    3a6c:	4806      	ldr	r0, [pc, #24]	; (3a88 <PkaSetRegsSizesTab+0x38>)
    3a6e:	6019      	str	r1, [r3, #0]
    3a70:	b082      	sub	sp, #8
    3a72:	6802      	ldr	r2, [r0, #0]
    3a74:	9201      	str	r2, [sp, #4]
    3a76:	9a01      	ldr	r2, [sp, #4]
    3a78:	07d2      	lsls	r2, r2, #31
    3a7a:	d5fa      	bpl.n	3a72 <PkaSetRegsSizesTab+0x22>
    3a7c:	6019      	str	r1, [r3, #0]
    3a7e:	b002      	add	sp, #8
    3a80:	4770      	bx	lr
    3a82:	bf00      	nop
    3a84:	5002b090 	.word	0x5002b090
    3a88:	5002b0b4 	.word	0x5002b0b4

00003a8c <PkaInitPka>:
    3a8c:	b538      	push	{r3, r4, r5, lr}
    3a8e:	f1a0 0320 	sub.w	r3, r0, #32
    3a92:	f5b3 6f42 	cmp.w	r3, #3104	; 0xc20
    3a96:	4605      	mov	r5, r0
    3a98:	d82c      	bhi.n	3af4 <PkaInitPka+0x68>
    3a9a:	288f      	cmp	r0, #143	; 0x8f
    3a9c:	d826      	bhi.n	3aec <PkaInitPka+0x60>
    3a9e:	f100 0347 	add.w	r3, r0, #71	; 0x47
    3aa2:	f100 0466 	add.w	r4, r0, #102	; 0x66
    3aa6:	06db      	lsls	r3, r3, #27
    3aa8:	ea4f 1454 	mov.w	r4, r4, lsr #5
    3aac:	d000      	beq.n	3ab0 <PkaInitPka+0x24>
    3aae:	3401      	adds	r4, #1
    3ab0:	0164      	lsls	r4, r4, #5
    3ab2:	343f      	adds	r4, #63	; 0x3f
    3ab4:	09a4      	lsrs	r4, r4, #6
    3ab6:	3401      	adds	r4, #1
    3ab8:	b111      	cbz	r1, 3ac0 <PkaInitPka+0x34>
    3aba:	42a1      	cmp	r1, r4
    3abc:	d31a      	bcc.n	3af4 <PkaInitPka+0x68>
    3abe:	460c      	mov	r4, r1
    3ac0:	00e3      	lsls	r3, r4, #3
    3ac2:	f44f 5080 	mov.w	r0, #4096	; 0x1000
    3ac6:	fbb0 f0f3 	udiv	r0, r0, r3
    3aca:	2820      	cmp	r0, #32
    3acc:	bf28      	it	cs
    3ace:	2020      	movcs	r0, #32
    3ad0:	b102      	cbz	r2, 3ad4 <PkaInitPka+0x48>
    3ad2:	6010      	str	r0, [r2, #0]
    3ad4:	4b08      	ldr	r3, [pc, #32]	; (3af8 <PkaInitPka+0x6c>)
    3ad6:	2201      	movs	r2, #1
    3ad8:	601a      	str	r2, [r3, #0]
    3ada:	4621      	mov	r1, r4
    3adc:	f7ff ff14 	bl	3908 <PkaSetRegsMapTab>
    3ae0:	4628      	mov	r0, r5
    3ae2:	4621      	mov	r1, r4
    3ae4:	f7ff ffb4 	bl	3a50 <PkaSetRegsSizesTab>
    3ae8:	2000      	movs	r0, #0
    3aea:	bd38      	pop	{r3, r4, r5, pc}
    3aec:	f100 041f 	add.w	r4, r0, #31
    3af0:	0964      	lsrs	r4, r4, #5
    3af2:	e7dd      	b.n	3ab0 <PkaInitPka+0x24>
    3af4:	4801      	ldr	r0, [pc, #4]	; (3afc <PkaInitPka+0x70>)
    3af6:	e7f8      	b.n	3aea <PkaInitPka+0x5e>
    3af8:	5002b81c 	.word	0x5002b81c
    3afc:	00f02122 	.word	0x00f02122

00003b00 <PkaClearBlockOfRegs>:
    3b00:	b5f0      	push	{r4, r5, r6, r7, lr}
    3b02:	4b45      	ldr	r3, [pc, #276]	; (3c18 <PkaClearBlockOfRegs+0x118>)
    3b04:	b089      	sub	sp, #36	; 0x24
    3b06:	461d      	mov	r5, r3
    3b08:	681c      	ldr	r4, [r3, #0]
    3b0a:	9401      	str	r4, [sp, #4]
    3b0c:	9c01      	ldr	r4, [sp, #4]
    3b0e:	07e4      	lsls	r4, r4, #31
    3b10:	d5fa      	bpl.n	3b08 <PkaClearBlockOfRegs+0x8>
    3b12:	4b42      	ldr	r3, [pc, #264]	; (3c1c <PkaClearBlockOfRegs+0x11c>)
    3b14:	f8df e10c 	ldr.w	lr, [pc, #268]	; 3c24 <PkaClearBlockOfRegs+0x124>
    3b18:	f8df c10c 	ldr.w	ip, [pc, #268]	; 3c28 <PkaClearBlockOfRegs+0x128>
    3b1c:	4413      	add	r3, r2
    3b1e:	009b      	lsls	r3, r3, #2
    3b20:	2400      	movs	r4, #0
    3b22:	681a      	ldr	r2, [r3, #0]
    3b24:	180b      	adds	r3, r1, r0
    3b26:	2b1e      	cmp	r3, #30
    3b28:	bf88      	it	hi
    3b2a:	f1c0 011e 	rsbhi	r1, r0, #30
    3b2e:	321f      	adds	r2, #31
    3b30:	180b      	adds	r3, r1, r0
    3b32:	0952      	lsrs	r2, r2, #5
    3b34:	4353      	muls	r3, r2
    3b36:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    3b3a:	bf82      	ittt	hi
    3b3c:	f44f 6180 	movhi.w	r1, #1024	; 0x400
    3b40:	fbb1 f1f2 	udivhi	r1, r1, r2
    3b44:	1a09      	subhi	r1, r1, r0
    3b46:	f100 50a0 	add.w	r0, r0, #335544320	; 0x14000000
    3b4a:	f500 402c 	add.w	r0, r0, #44032	; 0xac00
    3b4e:	4627      	mov	r7, r4
    3b50:	42a1      	cmp	r1, r4
    3b52:	dc33      	bgt.n	3bbc <PkaClearBlockOfRegs+0xbc>
    3b54:	682b      	ldr	r3, [r5, #0]
    3b56:	9304      	str	r3, [sp, #16]
    3b58:	9b04      	ldr	r3, [sp, #16]
    3b5a:	07db      	lsls	r3, r3, #31
    3b5c:	d5fa      	bpl.n	3b54 <PkaClearBlockOfRegs+0x54>
    3b5e:	4b30      	ldr	r3, [pc, #192]	; (3c20 <PkaClearBlockOfRegs+0x120>)
    3b60:	681b      	ldr	r3, [r3, #0]
    3b62:	6829      	ldr	r1, [r5, #0]
    3b64:	9105      	str	r1, [sp, #20]
    3b66:	9905      	ldr	r1, [sp, #20]
    3b68:	07cf      	lsls	r7, r1, #31
    3b6a:	d5fa      	bpl.n	3b62 <PkaClearBlockOfRegs+0x62>
    3b6c:	4c2d      	ldr	r4, [pc, #180]	; (3c24 <PkaClearBlockOfRegs+0x124>)
    3b6e:	492e      	ldr	r1, [pc, #184]	; (3c28 <PkaClearBlockOfRegs+0x128>)
    3b70:	6023      	str	r3, [r4, #0]
    3b72:	2300      	movs	r3, #0
    3b74:	461e      	mov	r6, r3
    3b76:	4293      	cmp	r3, r2
    3b78:	f103 0001 	add.w	r0, r3, #1
    3b7c:	d140      	bne.n	3c00 <PkaClearBlockOfRegs+0x100>
    3b7e:	f020 0201 	bic.w	r2, r0, #1
    3b82:	4829      	ldr	r0, [pc, #164]	; (3c28 <PkaClearBlockOfRegs+0x128>)
    3b84:	4619      	mov	r1, r3
    3b86:	2600      	movs	r6, #0
    3b88:	428a      	cmp	r2, r1
    3b8a:	d83c      	bhi.n	3c06 <PkaClearBlockOfRegs+0x106>
    3b8c:	6829      	ldr	r1, [r5, #0]
    3b8e:	9106      	str	r1, [sp, #24]
    3b90:	9906      	ldr	r1, [sp, #24]
    3b92:	07ce      	lsls	r6, r1, #31
    3b94:	d5fa      	bpl.n	3b8c <PkaClearBlockOfRegs+0x8c>
    3b96:	4925      	ldr	r1, [pc, #148]	; (3c2c <PkaClearBlockOfRegs+0x12c>)
    3b98:	6809      	ldr	r1, [r1, #0]
    3b9a:	6828      	ldr	r0, [r5, #0]
    3b9c:	9007      	str	r0, [sp, #28]
    3b9e:	9807      	ldr	r0, [sp, #28]
    3ba0:	07c0      	lsls	r0, r0, #31
    3ba2:	d5fa      	bpl.n	3b9a <PkaClearBlockOfRegs+0x9a>
    3ba4:	6021      	str	r1, [r4, #0]
    3ba6:	4820      	ldr	r0, [pc, #128]	; (3c28 <PkaClearBlockOfRegs+0x128>)
    3ba8:	2100      	movs	r1, #0
    3baa:	460c      	mov	r4, r1
    3bac:	428b      	cmp	r3, r1
    3bae:	d12d      	bne.n	3c0c <PkaClearBlockOfRegs+0x10c>
    3bb0:	491d      	ldr	r1, [pc, #116]	; (3c28 <PkaClearBlockOfRegs+0x128>)
    3bb2:	2000      	movs	r0, #0
    3bb4:	429a      	cmp	r2, r3
    3bb6:	d82c      	bhi.n	3c12 <PkaClearBlockOfRegs+0x112>
    3bb8:	b009      	add	sp, #36	; 0x24
    3bba:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3bbc:	682b      	ldr	r3, [r5, #0]
    3bbe:	9302      	str	r3, [sp, #8]
    3bc0:	9b02      	ldr	r3, [sp, #8]
    3bc2:	07db      	lsls	r3, r3, #31
    3bc4:	d5fa      	bpl.n	3bbc <PkaClearBlockOfRegs+0xbc>
    3bc6:	1903      	adds	r3, r0, r4
    3bc8:	009b      	lsls	r3, r3, #2
    3bca:	681b      	ldr	r3, [r3, #0]
    3bcc:	682e      	ldr	r6, [r5, #0]
    3bce:	9603      	str	r6, [sp, #12]
    3bd0:	9e03      	ldr	r6, [sp, #12]
    3bd2:	07f6      	lsls	r6, r6, #31
    3bd4:	d5fa      	bpl.n	3bcc <PkaClearBlockOfRegs+0xcc>
    3bd6:	f8ce 3000 	str.w	r3, [lr]
    3bda:	2300      	movs	r3, #0
    3bdc:	4293      	cmp	r3, r2
    3bde:	f103 0301 	add.w	r3, r3, #1
    3be2:	d106      	bne.n	3bf2 <PkaClearBlockOfRegs+0xf2>
    3be4:	4616      	mov	r6, r2
    3be6:	f023 0301 	bic.w	r3, r3, #1
    3bea:	42b3      	cmp	r3, r6
    3bec:	d804      	bhi.n	3bf8 <PkaClearBlockOfRegs+0xf8>
    3bee:	3401      	adds	r4, #1
    3bf0:	e7ae      	b.n	3b50 <PkaClearBlockOfRegs+0x50>
    3bf2:	f8cc 7000 	str.w	r7, [ip]
    3bf6:	e7f1      	b.n	3bdc <PkaClearBlockOfRegs+0xdc>
    3bf8:	f8cc 7000 	str.w	r7, [ip]
    3bfc:	3601      	adds	r6, #1
    3bfe:	e7f4      	b.n	3bea <PkaClearBlockOfRegs+0xea>
    3c00:	600e      	str	r6, [r1, #0]
    3c02:	4603      	mov	r3, r0
    3c04:	e7b7      	b.n	3b76 <PkaClearBlockOfRegs+0x76>
    3c06:	6006      	str	r6, [r0, #0]
    3c08:	3101      	adds	r1, #1
    3c0a:	e7bd      	b.n	3b88 <PkaClearBlockOfRegs+0x88>
    3c0c:	6004      	str	r4, [r0, #0]
    3c0e:	3101      	adds	r1, #1
    3c10:	e7cc      	b.n	3bac <PkaClearBlockOfRegs+0xac>
    3c12:	6008      	str	r0, [r1, #0]
    3c14:	3301      	adds	r3, #1
    3c16:	e7cd      	b.n	3bb4 <PkaClearBlockOfRegs+0xb4>
    3c18:	5002b0b4 	.word	0x5002b0b4
    3c1c:	1400ac24 	.word	0x1400ac24
    3c20:	5002b07c 	.word	0x5002b07c
    3c24:	5002b0d4 	.word	0x5002b0d4
    3c28:	5002b0d8 	.word	0x5002b0d8
    3c2c:	5002b078 	.word	0x5002b078

00003c30 <PkaFinishAndMutexUnlock>:
    3c30:	b508      	push	{r3, lr}
    3c32:	b140      	cbz	r0, 3c46 <PkaFinishAndMutexUnlock+0x16>
    3c34:	2820      	cmp	r0, #32
    3c36:	4601      	mov	r1, r0
    3c38:	f04f 0207 	mov.w	r2, #7
    3c3c:	bf28      	it	cs
    3c3e:	2120      	movcs	r1, #32
    3c40:	2000      	movs	r0, #0
    3c42:	f7ff ff5d 	bl	3b00 <PkaClearBlockOfRegs>
    3c46:	4b02      	ldr	r3, [pc, #8]	; (3c50 <PkaFinishAndMutexUnlock+0x20>)
    3c48:	2200      	movs	r2, #0
    3c4a:	601a      	str	r2, [r3, #0]
    3c4c:	bd08      	pop	{r3, pc}
    3c4e:	bf00      	nop
    3c50:	5002b81c 	.word	0x5002b81c

00003c54 <PkaCopyDataIntoPkaReg>:
    3c54:	b5f0      	push	{r4, r5, r6, r7, lr}
    3c56:	4d29      	ldr	r5, [pc, #164]	; (3cfc <PkaCopyDataIntoPkaReg+0xa8>)
    3c58:	b085      	sub	sp, #20
    3c5a:	462c      	mov	r4, r5
    3c5c:	682e      	ldr	r6, [r5, #0]
    3c5e:	9600      	str	r6, [sp, #0]
    3c60:	9e00      	ldr	r6, [sp, #0]
    3c62:	07f6      	lsls	r6, r6, #31
    3c64:	d5fa      	bpl.n	3c5c <PkaCopyDataIntoPkaReg+0x8>
    3c66:	f100 50a0 	add.w	r0, r0, #335544320	; 0x14000000
    3c6a:	f500 402c 	add.w	r0, r0, #44032	; 0xac00
    3c6e:	0080      	lsls	r0, r0, #2
    3c70:	6805      	ldr	r5, [r0, #0]
    3c72:	6820      	ldr	r0, [r4, #0]
    3c74:	9001      	str	r0, [sp, #4]
    3c76:	9801      	ldr	r0, [sp, #4]
    3c78:	07c7      	lsls	r7, r0, #31
    3c7a:	d5fa      	bpl.n	3c72 <PkaCopyDataIntoPkaReg+0x1e>
    3c7c:	4820      	ldr	r0, [pc, #128]	; (3d00 <PkaCopyDataIntoPkaReg+0xac>)
    3c7e:	4f21      	ldr	r7, [pc, #132]	; (3d04 <PkaCopyDataIntoPkaReg+0xb0>)
    3c80:	6005      	str	r5, [r0, #0]
    3c82:	eb02 0683 	add.w	r6, r2, r3, lsl #2
    3c86:	42b2      	cmp	r2, r6
    3c88:	d129      	bne.n	3cde <PkaCopyDataIntoPkaReg+0x8a>
    3c8a:	1c5a      	adds	r2, r3, #1
    3c8c:	4e1d      	ldr	r6, [pc, #116]	; (3d04 <PkaCopyDataIntoPkaReg+0xb0>)
    3c8e:	f022 0201 	bic.w	r2, r2, #1
    3c92:	2700      	movs	r7, #0
    3c94:	429a      	cmp	r2, r3
    3c96:	d827      	bhi.n	3ce8 <PkaCopyDataIntoPkaReg+0x94>
    3c98:	6823      	ldr	r3, [r4, #0]
    3c9a:	9302      	str	r3, [sp, #8]
    3c9c:	9b02      	ldr	r3, [sp, #8]
    3c9e:	07de      	lsls	r6, r3, #31
    3ca0:	d5fa      	bpl.n	3c98 <PkaCopyDataIntoPkaReg+0x44>
    3ca2:	4b19      	ldr	r3, [pc, #100]	; (3d08 <PkaCopyDataIntoPkaReg+0xb4>)
    3ca4:	440b      	add	r3, r1
    3ca6:	009b      	lsls	r3, r3, #2
    3ca8:	681b      	ldr	r3, [r3, #0]
    3caa:	331f      	adds	r3, #31
    3cac:	095b      	lsrs	r3, r3, #5
    3cae:	429a      	cmp	r2, r3
    3cb0:	d213      	bcs.n	3cda <PkaCopyDataIntoPkaReg+0x86>
    3cb2:	6821      	ldr	r1, [r4, #0]
    3cb4:	9103      	str	r1, [sp, #12]
    3cb6:	9903      	ldr	r1, [sp, #12]
    3cb8:	07c9      	lsls	r1, r1, #31
    3cba:	d5fa      	bpl.n	3cb2 <PkaCopyDataIntoPkaReg+0x5e>
    3cbc:	4415      	add	r5, r2
    3cbe:	2100      	movs	r1, #0
    3cc0:	1a9b      	subs	r3, r3, r2
    3cc2:	4a10      	ldr	r2, [pc, #64]	; (3d04 <PkaCopyDataIntoPkaReg+0xb0>)
    3cc4:	6005      	str	r5, [r0, #0]
    3cc6:	4608      	mov	r0, r1
    3cc8:	428b      	cmp	r3, r1
    3cca:	d810      	bhi.n	3cee <PkaCopyDataIntoPkaReg+0x9a>
    3ccc:	1c5a      	adds	r2, r3, #1
    3cce:	490d      	ldr	r1, [pc, #52]	; (3d04 <PkaCopyDataIntoPkaReg+0xb0>)
    3cd0:	f022 0201 	bic.w	r2, r2, #1
    3cd4:	2000      	movs	r0, #0
    3cd6:	429a      	cmp	r2, r3
    3cd8:	d80c      	bhi.n	3cf4 <PkaCopyDataIntoPkaReg+0xa0>
    3cda:	b005      	add	sp, #20
    3cdc:	bdf0      	pop	{r4, r5, r6, r7, pc}
    3cde:	f852 cb04 	ldr.w	ip, [r2], #4
    3ce2:	f8c7 c000 	str.w	ip, [r7]
    3ce6:	e7ce      	b.n	3c86 <PkaCopyDataIntoPkaReg+0x32>
    3ce8:	6037      	str	r7, [r6, #0]
    3cea:	3301      	adds	r3, #1
    3cec:	e7d2      	b.n	3c94 <PkaCopyDataIntoPkaReg+0x40>
    3cee:	6010      	str	r0, [r2, #0]
    3cf0:	3101      	adds	r1, #1
    3cf2:	e7e9      	b.n	3cc8 <PkaCopyDataIntoPkaReg+0x74>
    3cf4:	6008      	str	r0, [r1, #0]
    3cf6:	3301      	adds	r3, #1
    3cf8:	e7ed      	b.n	3cd6 <PkaCopyDataIntoPkaReg+0x82>
    3cfa:	bf00      	nop
    3cfc:	5002b0b4 	.word	0x5002b0b4
    3d00:	5002b0d4 	.word	0x5002b0d4
    3d04:	5002b0d8 	.word	0x5002b0d8
    3d08:	1400ac24 	.word	0x1400ac24

00003d0c <PkaEcdsaVerify>:
    3d0c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    3d10:	4b81      	ldr	r3, [pc, #516]	; (3f18 <PkaEcdsaVerify+0x20c>)
    3d12:	681d      	ldr	r5, [r3, #0]
    3d14:	6898      	ldr	r0, [r3, #8]
    3d16:	3320      	adds	r3, #32
    3d18:	b0a0      	sub	sp, #128	; 0x80
    3d1a:	461e      	mov	r6, r3
    3d1c:	681a      	ldr	r2, [r3, #0]
    3d1e:	9201      	str	r2, [sp, #4]
    3d20:	9a01      	ldr	r2, [sp, #4]
    3d22:	07d7      	lsls	r7, r2, #31
    3d24:	d5fa      	bpl.n	3d1c <PkaEcdsaVerify+0x10>
    3d26:	4b7d      	ldr	r3, [pc, #500]	; (3f1c <PkaEcdsaVerify+0x210>)
    3d28:	4a7d      	ldr	r2, [pc, #500]	; (3f20 <PkaEcdsaVerify+0x214>)
    3d2a:	601a      	str	r2, [r3, #0]
    3d2c:	6832      	ldr	r2, [r6, #0]
    3d2e:	9202      	str	r2, [sp, #8]
    3d30:	9a02      	ldr	r2, [sp, #8]
    3d32:	07d4      	lsls	r4, r2, #31
    3d34:	d5fa      	bpl.n	3d2c <PkaEcdsaVerify+0x20>
    3d36:	4a7b      	ldr	r2, [pc, #492]	; (3f24 <PkaEcdsaVerify+0x218>)
    3d38:	601a      	str	r2, [r3, #0]
    3d3a:	4a7b      	ldr	r2, [pc, #492]	; (3f28 <PkaEcdsaVerify+0x21c>)
    3d3c:	4614      	mov	r4, r2
    3d3e:	6811      	ldr	r1, [r2, #0]
    3d40:	9103      	str	r1, [sp, #12]
    3d42:	9903      	ldr	r1, [sp, #12]
    3d44:	07c9      	lsls	r1, r1, #31
    3d46:	d5fa      	bpl.n	3d3e <PkaEcdsaVerify+0x32>
    3d48:	4a78      	ldr	r2, [pc, #480]	; (3f2c <PkaEcdsaVerify+0x220>)
    3d4a:	6811      	ldr	r1, [r2, #0]
    3d4c:	f3c1 2140 	ubfx	r1, r1, #9, #1
    3d50:	6837      	ldr	r7, [r6, #0]
    3d52:	9704      	str	r7, [sp, #16]
    3d54:	9f04      	ldr	r7, [sp, #16]
    3d56:	07ff      	lsls	r7, r7, #31
    3d58:	d5fa      	bpl.n	3d50 <PkaEcdsaVerify+0x44>
    3d5a:	4f75      	ldr	r7, [pc, #468]	; (3f30 <PkaEcdsaVerify+0x224>)
    3d5c:	601f      	str	r7, [r3, #0]
    3d5e:	6827      	ldr	r7, [r4, #0]
    3d60:	9705      	str	r7, [sp, #20]
    3d62:	9f05      	ldr	r7, [sp, #20]
    3d64:	07ff      	lsls	r7, r7, #31
    3d66:	d5fa      	bpl.n	3d5e <PkaEcdsaVerify+0x52>
    3d68:	6817      	ldr	r7, [r2, #0]
    3d6a:	2900      	cmp	r1, #0
    3d6c:	f000 80cf 	beq.w	3f0e <PkaEcdsaVerify+0x202>
    3d70:	05b9      	lsls	r1, r7, #22
    3d72:	f140 80cc 	bpl.w	3f0e <PkaEcdsaVerify+0x202>
    3d76:	6831      	ldr	r1, [r6, #0]
    3d78:	9106      	str	r1, [sp, #24]
    3d7a:	9906      	ldr	r1, [sp, #24]
    3d7c:	07cf      	lsls	r7, r1, #31
    3d7e:	d5fa      	bpl.n	3d76 <PkaEcdsaVerify+0x6a>
    3d80:	496c      	ldr	r1, [pc, #432]	; (3f34 <PkaEcdsaVerify+0x228>)
    3d82:	6019      	str	r1, [r3, #0]
    3d84:	6821      	ldr	r1, [r4, #0]
    3d86:	9107      	str	r1, [sp, #28]
    3d88:	9907      	ldr	r1, [sp, #28]
    3d8a:	07c9      	lsls	r1, r1, #31
    3d8c:	d5fa      	bpl.n	3d84 <PkaEcdsaVerify+0x78>
    3d8e:	6811      	ldr	r1, [r2, #0]
    3d90:	f3c1 2140 	ubfx	r1, r1, #9, #1
    3d94:	6837      	ldr	r7, [r6, #0]
    3d96:	9708      	str	r7, [sp, #32]
    3d98:	9f08      	ldr	r7, [sp, #32]
    3d9a:	07ff      	lsls	r7, r7, #31
    3d9c:	d5fa      	bpl.n	3d94 <PkaEcdsaVerify+0x88>
    3d9e:	4f66      	ldr	r7, [pc, #408]	; (3f38 <PkaEcdsaVerify+0x22c>)
    3da0:	601f      	str	r7, [r3, #0]
    3da2:	6827      	ldr	r7, [r4, #0]
    3da4:	9709      	str	r7, [sp, #36]	; 0x24
    3da6:	9f09      	ldr	r7, [sp, #36]	; 0x24
    3da8:	07ff      	lsls	r7, r7, #31
    3daa:	d5fa      	bpl.n	3da2 <PkaEcdsaVerify+0x96>
    3dac:	6812      	ldr	r2, [r2, #0]
    3dae:	2900      	cmp	r1, #0
    3db0:	f000 80af 	beq.w	3f12 <PkaEcdsaVerify+0x206>
    3db4:	0591      	lsls	r1, r2, #22
    3db6:	f140 80ac 	bpl.w	3f12 <PkaEcdsaVerify+0x206>
    3dba:	6832      	ldr	r2, [r6, #0]
    3dbc:	920a      	str	r2, [sp, #40]	; 0x28
    3dbe:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3dc0:	07d2      	lsls	r2, r2, #31
    3dc2:	d5fa      	bpl.n	3dba <PkaEcdsaVerify+0xae>
    3dc4:	4a56      	ldr	r2, [pc, #344]	; (3f20 <PkaEcdsaVerify+0x214>)
    3dc6:	601a      	str	r2, [r3, #0]
    3dc8:	6832      	ldr	r2, [r6, #0]
    3dca:	920b      	str	r2, [sp, #44]	; 0x2c
    3dcc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3dce:	07d7      	lsls	r7, r2, #31
    3dd0:	d5fa      	bpl.n	3dc8 <PkaEcdsaVerify+0xbc>
    3dd2:	4a5a      	ldr	r2, [pc, #360]	; (3f3c <PkaEcdsaVerify+0x230>)
    3dd4:	601a      	str	r2, [r3, #0]
    3dd6:	6831      	ldr	r1, [r6, #0]
    3dd8:	910c      	str	r1, [sp, #48]	; 0x30
    3dda:	990c      	ldr	r1, [sp, #48]	; 0x30
    3ddc:	07cc      	lsls	r4, r1, #31
    3dde:	d5fa      	bpl.n	3dd6 <PkaEcdsaVerify+0xca>
    3de0:	4957      	ldr	r1, [pc, #348]	; (3f40 <PkaEcdsaVerify+0x234>)
    3de2:	6019      	str	r1, [r3, #0]
    3de4:	6831      	ldr	r1, [r6, #0]
    3de6:	910d      	str	r1, [sp, #52]	; 0x34
    3de8:	990d      	ldr	r1, [sp, #52]	; 0x34
    3dea:	07c9      	lsls	r1, r1, #31
    3dec:	d5fa      	bpl.n	3de4 <PkaEcdsaVerify+0xd8>
    3dee:	4955      	ldr	r1, [pc, #340]	; (3f44 <PkaEcdsaVerify+0x238>)
    3df0:	6019      	str	r1, [r3, #0]
    3df2:	6831      	ldr	r1, [r6, #0]
    3df4:	910e      	str	r1, [sp, #56]	; 0x38
    3df6:	990e      	ldr	r1, [sp, #56]	; 0x38
    3df8:	07cf      	lsls	r7, r1, #31
    3dfa:	d5fa      	bpl.n	3df2 <PkaEcdsaVerify+0xe6>
    3dfc:	4952      	ldr	r1, [pc, #328]	; (3f48 <PkaEcdsaVerify+0x23c>)
    3dfe:	6019      	str	r1, [r3, #0]
    3e00:	6831      	ldr	r1, [r6, #0]
    3e02:	910f      	str	r1, [sp, #60]	; 0x3c
    3e04:	990f      	ldr	r1, [sp, #60]	; 0x3c
    3e06:	07cc      	lsls	r4, r1, #31
    3e08:	d5fa      	bpl.n	3e00 <PkaEcdsaVerify+0xf4>
    3e0a:	4950      	ldr	r1, [pc, #320]	; (3f4c <PkaEcdsaVerify+0x240>)
    3e0c:	6019      	str	r1, [r3, #0]
    3e0e:	4b50      	ldr	r3, [pc, #320]	; (3f50 <PkaEcdsaVerify+0x244>)
    3e10:	461e      	mov	r6, r3
    3e12:	6819      	ldr	r1, [r3, #0]
    3e14:	9110      	str	r1, [sp, #64]	; 0x40
    3e16:	9910      	ldr	r1, [sp, #64]	; 0x40
    3e18:	07c9      	lsls	r1, r1, #31
    3e1a:	d5fa      	bpl.n	3e12 <PkaEcdsaVerify+0x106>
    3e1c:	4c3f      	ldr	r4, [pc, #252]	; (3f1c <PkaEcdsaVerify+0x210>)
    3e1e:	4b4d      	ldr	r3, [pc, #308]	; (3f54 <PkaEcdsaVerify+0x248>)
    3e20:	6023      	str	r3, [r4, #0]
    3e22:	6833      	ldr	r3, [r6, #0]
    3e24:	9311      	str	r3, [sp, #68]	; 0x44
    3e26:	9b11      	ldr	r3, [sp, #68]	; 0x44
    3e28:	07db      	lsls	r3, r3, #31
    3e2a:	d5fa      	bpl.n	3e22 <PkaEcdsaVerify+0x116>
    3e2c:	4b4a      	ldr	r3, [pc, #296]	; (3f58 <PkaEcdsaVerify+0x24c>)
    3e2e:	6023      	str	r3, [r4, #0]
    3e30:	6833      	ldr	r3, [r6, #0]
    3e32:	9312      	str	r3, [sp, #72]	; 0x48
    3e34:	9b12      	ldr	r3, [sp, #72]	; 0x48
    3e36:	07df      	lsls	r7, r3, #31
    3e38:	d5fa      	bpl.n	3e30 <PkaEcdsaVerify+0x124>
    3e3a:	4b48      	ldr	r3, [pc, #288]	; (3f5c <PkaEcdsaVerify+0x250>)
    3e3c:	6023      	str	r3, [r4, #0]
    3e3e:	4b3a      	ldr	r3, [pc, #232]	; (3f28 <PkaEcdsaVerify+0x21c>)
    3e40:	4698      	mov	r8, r3
    3e42:	6819      	ldr	r1, [r3, #0]
    3e44:	9113      	str	r1, [sp, #76]	; 0x4c
    3e46:	9913      	ldr	r1, [sp, #76]	; 0x4c
    3e48:	07c9      	lsls	r1, r1, #31
    3e4a:	d5fa      	bpl.n	3e42 <PkaEcdsaVerify+0x136>
    3e4c:	4f32      	ldr	r7, [pc, #200]	; (3f18 <PkaEcdsaVerify+0x20c>)
    3e4e:	6038      	str	r0, [r7, #0]
    3e50:	6833      	ldr	r3, [r6, #0]
    3e52:	9314      	str	r3, [sp, #80]	; 0x50
    3e54:	9b14      	ldr	r3, [sp, #80]	; 0x50
    3e56:	07db      	lsls	r3, r3, #31
    3e58:	d5fa      	bpl.n	3e50 <PkaEcdsaVerify+0x144>
    3e5a:	6022      	str	r2, [r4, #0]
    3e5c:	6833      	ldr	r3, [r6, #0]
    3e5e:	9315      	str	r3, [sp, #84]	; 0x54
    3e60:	9b15      	ldr	r3, [sp, #84]	; 0x54
    3e62:	07d8      	lsls	r0, r3, #31
    3e64:	d5fa      	bpl.n	3e5c <PkaEcdsaVerify+0x150>
    3e66:	4b3e      	ldr	r3, [pc, #248]	; (3f60 <PkaEcdsaVerify+0x254>)
    3e68:	6023      	str	r3, [r4, #0]
    3e6a:	6833      	ldr	r3, [r6, #0]
    3e6c:	9316      	str	r3, [sp, #88]	; 0x58
    3e6e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    3e70:	07d9      	lsls	r1, r3, #31
    3e72:	d5fa      	bpl.n	3e6a <PkaEcdsaVerify+0x15e>
    3e74:	4b3b      	ldr	r3, [pc, #236]	; (3f64 <PkaEcdsaVerify+0x258>)
    3e76:	6023      	str	r3, [r4, #0]
    3e78:	6833      	ldr	r3, [r6, #0]
    3e7a:	9317      	str	r3, [sp, #92]	; 0x5c
    3e7c:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    3e7e:	07da      	lsls	r2, r3, #31
    3e80:	d5fa      	bpl.n	3e78 <PkaEcdsaVerify+0x16c>
    3e82:	4b39      	ldr	r3, [pc, #228]	; (3f68 <PkaEcdsaVerify+0x25c>)
    3e84:	6023      	str	r3, [r4, #0]
    3e86:	6833      	ldr	r3, [r6, #0]
    3e88:	9318      	str	r3, [sp, #96]	; 0x60
    3e8a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    3e8c:	07db      	lsls	r3, r3, #31
    3e8e:	d5fa      	bpl.n	3e86 <PkaEcdsaVerify+0x17a>
    3e90:	4b36      	ldr	r3, [pc, #216]	; (3f6c <PkaEcdsaVerify+0x260>)
    3e92:	6023      	str	r3, [r4, #0]
    3e94:	6833      	ldr	r3, [r6, #0]
    3e96:	9319      	str	r3, [sp, #100]	; 0x64
    3e98:	9b19      	ldr	r3, [sp, #100]	; 0x64
    3e9a:	07d8      	lsls	r0, r3, #31
    3e9c:	d5fa      	bpl.n	3e94 <PkaEcdsaVerify+0x188>
    3e9e:	4b34      	ldr	r3, [pc, #208]	; (3f70 <PkaEcdsaVerify+0x264>)
    3ea0:	6023      	str	r3, [r4, #0]
    3ea2:	6833      	ldr	r3, [r6, #0]
    3ea4:	931a      	str	r3, [sp, #104]	; 0x68
    3ea6:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    3ea8:	07d9      	lsls	r1, r3, #31
    3eaa:	d5fa      	bpl.n	3ea2 <PkaEcdsaVerify+0x196>
    3eac:	4b31      	ldr	r3, [pc, #196]	; (3f74 <PkaEcdsaVerify+0x268>)
    3eae:	6023      	str	r3, [r4, #0]
    3eb0:	6833      	ldr	r3, [r6, #0]
    3eb2:	931b      	str	r3, [sp, #108]	; 0x6c
    3eb4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    3eb6:	07da      	lsls	r2, r3, #31
    3eb8:	d5fa      	bpl.n	3eb0 <PkaEcdsaVerify+0x1a4>
    3eba:	4b2f      	ldr	r3, [pc, #188]	; (3f78 <PkaEcdsaVerify+0x26c>)
    3ebc:	6023      	str	r3, [r4, #0]
    3ebe:	f000 fc1d 	bl	46fc <PkaSum2ScalarMullt>
    3ec2:	bb08      	cbnz	r0, 3f08 <PkaEcdsaVerify+0x1fc>
    3ec4:	f8d8 3000 	ldr.w	r3, [r8]
    3ec8:	931c      	str	r3, [sp, #112]	; 0x70
    3eca:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    3ecc:	07db      	lsls	r3, r3, #31
    3ece:	d5f9      	bpl.n	3ec4 <PkaEcdsaVerify+0x1b8>
    3ed0:	603d      	str	r5, [r7, #0]
    3ed2:	6833      	ldr	r3, [r6, #0]
    3ed4:	931d      	str	r3, [sp, #116]	; 0x74
    3ed6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    3ed8:	07d9      	lsls	r1, r3, #31
    3eda:	d5fa      	bpl.n	3ed2 <PkaEcdsaVerify+0x1c6>
    3edc:	4b27      	ldr	r3, [pc, #156]	; (3f7c <PkaEcdsaVerify+0x270>)
    3ede:	6023      	str	r3, [r4, #0]
    3ee0:	6833      	ldr	r3, [r6, #0]
    3ee2:	931e      	str	r3, [sp, #120]	; 0x78
    3ee4:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    3ee6:	07da      	lsls	r2, r3, #31
    3ee8:	d5fa      	bpl.n	3ee0 <PkaEcdsaVerify+0x1d4>
    3eea:	4b25      	ldr	r3, [pc, #148]	; (3f80 <PkaEcdsaVerify+0x274>)
    3eec:	6023      	str	r3, [r4, #0]
    3eee:	f8d8 3000 	ldr.w	r3, [r8]
    3ef2:	931f      	str	r3, [sp, #124]	; 0x7c
    3ef4:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    3ef6:	07db      	lsls	r3, r3, #31
    3ef8:	d5f9      	bpl.n	3eee <PkaEcdsaVerify+0x1e2>
    3efa:	4b0c      	ldr	r3, [pc, #48]	; (3f2c <PkaEcdsaVerify+0x220>)
    3efc:	681b      	ldr	r3, [r3, #0]
    3efe:	f413 5f80 	tst.w	r3, #4096	; 0x1000
    3f02:	4b20      	ldr	r3, [pc, #128]	; (3f84 <PkaEcdsaVerify+0x278>)
    3f04:	bf08      	it	eq
    3f06:	4618      	moveq	r0, r3
    3f08:	b020      	add	sp, #128	; 0x80
    3f0a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    3f0e:	481e      	ldr	r0, [pc, #120]	; (3f88 <PkaEcdsaVerify+0x27c>)
    3f10:	e7fa      	b.n	3f08 <PkaEcdsaVerify+0x1fc>
    3f12:	481e      	ldr	r0, [pc, #120]	; (3f8c <PkaEcdsaVerify+0x280>)
    3f14:	e7f8      	b.n	3f08 <PkaEcdsaVerify+0x1fc>
    3f16:	bf00      	nop
    3f18:	5002b090 	.word	0x5002b090
    3f1c:	5002b080 	.word	0x5002b080
    3f20:	51021000 	.word	0x51021000
    3f24:	29721fc0 	.word	0x29721fc0
    3f28:	5002b0b4 	.word	0x5002b0b4
    3f2c:	5002b088 	.word	0x5002b088
    3f30:	2901cfc0 	.word	0x2901cfc0
    3f34:	290e1fc0 	.word	0x290e1fc0
    3f38:	29003fc0 	.word	0x29003fc0
    3f3c:	49020140 	.word	0x49020140
    3f40:	a8843100 	.word	0xa8843100
    3f44:	49160000 	.word	0x49160000
    3f48:	a1080140 	.word	0xa1080140
    3f4c:	88084480 	.word	0x88084480
    3f50:	5002b0b0 	.word	0x5002b0b0
    3f54:	887044c0 	.word	0x887044c0
    3f58:	417a0780 	.word	0x417a0780
    3f5c:	417e07c0 	.word	0x417e07c0
    3f60:	496a0000 	.word	0x496a0000
    3f64:	49160680 	.word	0x49160680
    3f68:	496e0040 	.word	0x496e0040
    3f6c:	21000200 	.word	0x21000200
    3f70:	21208200 	.word	0x21208200
    3f74:	21208240 	.word	0x21208240
    3f78:	21248280 	.word	0x21248280
    3f7c:	a161a140 	.word	0xa161a140
    3f80:	5161c800 	.word	0x5161c800
    3f84:	00f10803 	.word	0x00f10803
    3f88:	00f10801 	.word	0x00f10801
    3f8c:	00f10802 	.word	0x00f10802

00003f90 <nrf_cc310_bl_hash_update_internal>:
    3f90:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
    3f94:	4b31      	ldr	r3, [pc, #196]	; (405c <nrf_cc310_bl_hash_update_internal+0xcc>)
    3f96:	6844      	ldr	r4, [r0, #4]
    3f98:	4680      	mov	r8, r0
    3f9a:	4692      	mov	sl, r2
    3f9c:	4699      	mov	r9, r3
    3f9e:	681a      	ldr	r2, [r3, #0]
    3fa0:	2a00      	cmp	r2, #0
    3fa2:	d1fc      	bne.n	3f9e <nrf_cc310_bl_hash_update_internal+0xe>
    3fa4:	4b2e      	ldr	r3, [pc, #184]	; (4060 <nrf_cc310_bl_hash_update_internal+0xd0>)
    3fa6:	469b      	mov	fp, r3
    3fa8:	681a      	ldr	r2, [r3, #0]
    3faa:	2a00      	cmp	r2, #0
    3fac:	d1fc      	bne.n	3fa8 <nrf_cc310_bl_hash_update_internal+0x18>
    3fae:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    3fb2:	9101      	str	r1, [sp, #4]
    3fb4:	f000 fc94 	bl	48e0 <SaSi_HalClearInterruptBit>
    3fb8:	2080      	movs	r0, #128	; 0x80
    3fba:	f000 fc97 	bl	48ec <SaSi_HalMaskInterrupt>
    3fbe:	4d29      	ldr	r5, [pc, #164]	; (4064 <nrf_cc310_bl_hash_update_internal+0xd4>)
    3fc0:	4a29      	ldr	r2, [pc, #164]	; (4068 <nrf_cc310_bl_hash_update_internal+0xd8>)
    3fc2:	4f2a      	ldr	r7, [pc, #168]	; (406c <nrf_cc310_bl_hash_update_internal+0xdc>)
    3fc4:	4e2a      	ldr	r6, [pc, #168]	; (4070 <nrf_cc310_bl_hash_update_internal+0xe0>)
    3fc6:	2301      	movs	r3, #1
    3fc8:	2007      	movs	r0, #7
    3fca:	602b      	str	r3, [r5, #0]
    3fcc:	f5a2 729e 	sub.w	r2, r2, #316	; 0x13c
    3fd0:	f8c2 013c 	str.w	r0, [r2, #316]	; 0x13c
    3fd4:	6013      	str	r3, [r2, #0]
    3fd6:	6a63      	ldr	r3, [r4, #36]	; 0x24
    3fd8:	603b      	str	r3, [r7, #0]
    3fda:	6aa3      	ldr	r3, [r4, #40]	; 0x28
    3fdc:	6033      	str	r3, [r6, #0]
    3fde:	f8d8 3000 	ldr.w	r3, [r8]
    3fe2:	f842 3c04 	str.w	r3, [r2, #-4]
    3fe6:	f8d8 3008 	ldr.w	r3, [r8, #8]
    3fea:	4620      	mov	r0, r4
    3fec:	4798      	blx	r3
    3fee:	9901      	ldr	r1, [sp, #4]
    3ff0:	f8d9 3000 	ldr.w	r3, [r9]
    3ff4:	2b00      	cmp	r3, #0
    3ff6:	d1fb      	bne.n	3ff0 <nrf_cc310_bl_hash_update_internal+0x60>
    3ff8:	f1ba 0f00 	cmp.w	sl, #0
    3ffc:	d120      	bne.n	4040 <nrf_cc310_bl_hash_update_internal+0xb0>
    3ffe:	4b1d      	ldr	r3, [pc, #116]	; (4074 <nrf_cc310_bl_hash_update_internal+0xe4>)
    4000:	2204      	movs	r2, #4
    4002:	601a      	str	r2, [r3, #0]
    4004:	f8d9 3000 	ldr.w	r3, [r9]
    4008:	2b00      	cmp	r3, #0
    400a:	d1fb      	bne.n	4004 <nrf_cc310_bl_hash_update_internal+0x74>
    400c:	f8db a000 	ldr.w	sl, [fp]
    4010:	f1ba 0f00 	cmp.w	sl, #0
    4014:	d1fa      	bne.n	400c <nrf_cc310_bl_hash_update_internal+0x7c>
    4016:	f8d8 300c 	ldr.w	r3, [r8, #12]
    401a:	4620      	mov	r0, r4
    401c:	4798      	blx	r3
    401e:	683b      	ldr	r3, [r7, #0]
    4020:	6263      	str	r3, [r4, #36]	; 0x24
    4022:	6833      	ldr	r3, [r6, #0]
    4024:	62a3      	str	r3, [r4, #40]	; 0x28
    4026:	4b14      	ldr	r3, [pc, #80]	; (4078 <nrf_cc310_bl_hash_update_internal+0xe8>)
    4028:	f8c3 a000 	str.w	sl, [r3]
    402c:	f8c3 a144 	str.w	sl, [r3, #324]	; 0x144
    4030:	f8d9 3000 	ldr.w	r3, [r9]
    4034:	2b00      	cmp	r3, #0
    4036:	d1fb      	bne.n	4030 <nrf_cc310_bl_hash_update_internal+0xa0>
    4038:	602b      	str	r3, [r5, #0]
    403a:	b003      	add	sp, #12
    403c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4040:	6a23      	ldr	r3, [r4, #32]
    4042:	2b01      	cmp	r3, #1
    4044:	bf04      	itt	eq
    4046:	4a0c      	ldreq	r2, [pc, #48]	; (4078 <nrf_cc310_bl_hash_update_internal+0xe8>)
    4048:	6013      	streq	r3, [r2, #0]
    404a:	4b0c      	ldr	r3, [pc, #48]	; (407c <nrf_cc310_bl_hash_update_internal+0xec>)
    404c:	2040      	movs	r0, #64	; 0x40
    404e:	6019      	str	r1, [r3, #0]
    4050:	f8c3 a004 	str.w	sl, [r3, #4]
    4054:	f000 fc50 	bl	48f8 <SaSi_HalWaitInterrupt>
    4058:	e7d4      	b.n	4004 <nrf_cc310_bl_hash_update_internal+0x74>
    405a:	bf00      	nop
    405c:	5002b910 	.word	0x5002b910
    4060:	5002bc20 	.word	0x5002bc20
    4064:	5002b818 	.word	0x5002b818
    4068:	5002b900 	.word	0x5002b900
    406c:	5002b7cc 	.word	0x5002b7cc
    4070:	5002b7d0 	.word	0x5002b7d0
    4074:	5002b7c8 	.word	0x5002b7c8
    4078:	5002b684 	.word	0x5002b684
    407c:	5002bc28 	.word	0x5002bc28

00004080 <PkaDoubleMdf2Mdf>:
    4080:	b510      	push	{r4, lr}
    4082:	4b54      	ldr	r3, [pc, #336]	; (41d4 <PkaDoubleMdf2Mdf+0x154>)
    4084:	b098      	sub	sp, #96	; 0x60
    4086:	4619      	mov	r1, r3
    4088:	681a      	ldr	r2, [r3, #0]
    408a:	9201      	str	r2, [sp, #4]
    408c:	9a01      	ldr	r2, [sp, #4]
    408e:	07d2      	lsls	r2, r2, #31
    4090:	d5fa      	bpl.n	4088 <PkaDoubleMdf2Mdf+0x8>
    4092:	4b51      	ldr	r3, [pc, #324]	; (41d8 <PkaDoubleMdf2Mdf+0x158>)
    4094:	4a51      	ldr	r2, [pc, #324]	; (41dc <PkaDoubleMdf2Mdf+0x15c>)
    4096:	601a      	str	r2, [r3, #0]
    4098:	680a      	ldr	r2, [r1, #0]
    409a:	9202      	str	r2, [sp, #8]
    409c:	9a02      	ldr	r2, [sp, #8]
    409e:	07d4      	lsls	r4, r2, #31
    40a0:	d5fa      	bpl.n	4098 <PkaDoubleMdf2Mdf+0x18>
    40a2:	4a4f      	ldr	r2, [pc, #316]	; (41e0 <PkaDoubleMdf2Mdf+0x160>)
    40a4:	601a      	str	r2, [r3, #0]
    40a6:	680a      	ldr	r2, [r1, #0]
    40a8:	9203      	str	r2, [sp, #12]
    40aa:	9a03      	ldr	r2, [sp, #12]
    40ac:	07d0      	lsls	r0, r2, #31
    40ae:	d5fa      	bpl.n	40a6 <PkaDoubleMdf2Mdf+0x26>
    40b0:	484c      	ldr	r0, [pc, #304]	; (41e4 <PkaDoubleMdf2Mdf+0x164>)
    40b2:	6018      	str	r0, [r3, #0]
    40b4:	680a      	ldr	r2, [r1, #0]
    40b6:	9204      	str	r2, [sp, #16]
    40b8:	9a04      	ldr	r2, [sp, #16]
    40ba:	07d2      	lsls	r2, r2, #31
    40bc:	d5fa      	bpl.n	40b4 <PkaDoubleMdf2Mdf+0x34>
    40be:	4a4a      	ldr	r2, [pc, #296]	; (41e8 <PkaDoubleMdf2Mdf+0x168>)
    40c0:	601a      	str	r2, [r3, #0]
    40c2:	680a      	ldr	r2, [r1, #0]
    40c4:	9205      	str	r2, [sp, #20]
    40c6:	9a05      	ldr	r2, [sp, #20]
    40c8:	07d4      	lsls	r4, r2, #31
    40ca:	d5fa      	bpl.n	40c2 <PkaDoubleMdf2Mdf+0x42>
    40cc:	4a47      	ldr	r2, [pc, #284]	; (41ec <PkaDoubleMdf2Mdf+0x16c>)
    40ce:	601a      	str	r2, [r3, #0]
    40d0:	680a      	ldr	r2, [r1, #0]
    40d2:	9206      	str	r2, [sp, #24]
    40d4:	9a06      	ldr	r2, [sp, #24]
    40d6:	07d2      	lsls	r2, r2, #31
    40d8:	d5fa      	bpl.n	40d0 <PkaDoubleMdf2Mdf+0x50>
    40da:	4a45      	ldr	r2, [pc, #276]	; (41f0 <PkaDoubleMdf2Mdf+0x170>)
    40dc:	601a      	str	r2, [r3, #0]
    40de:	680a      	ldr	r2, [r1, #0]
    40e0:	9207      	str	r2, [sp, #28]
    40e2:	9a07      	ldr	r2, [sp, #28]
    40e4:	07d4      	lsls	r4, r2, #31
    40e6:	d5fa      	bpl.n	40de <PkaDoubleMdf2Mdf+0x5e>
    40e8:	4a42      	ldr	r2, [pc, #264]	; (41f4 <PkaDoubleMdf2Mdf+0x174>)
    40ea:	601a      	str	r2, [r3, #0]
    40ec:	680a      	ldr	r2, [r1, #0]
    40ee:	9208      	str	r2, [sp, #32]
    40f0:	9a08      	ldr	r2, [sp, #32]
    40f2:	07d2      	lsls	r2, r2, #31
    40f4:	d5fa      	bpl.n	40ec <PkaDoubleMdf2Mdf+0x6c>
    40f6:	4a40      	ldr	r2, [pc, #256]	; (41f8 <PkaDoubleMdf2Mdf+0x178>)
    40f8:	601a      	str	r2, [r3, #0]
    40fa:	680a      	ldr	r2, [r1, #0]
    40fc:	9209      	str	r2, [sp, #36]	; 0x24
    40fe:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4100:	07d4      	lsls	r4, r2, #31
    4102:	d5fa      	bpl.n	40fa <PkaDoubleMdf2Mdf+0x7a>
    4104:	4a3d      	ldr	r2, [pc, #244]	; (41fc <PkaDoubleMdf2Mdf+0x17c>)
    4106:	601a      	str	r2, [r3, #0]
    4108:	680a      	ldr	r2, [r1, #0]
    410a:	920a      	str	r2, [sp, #40]	; 0x28
    410c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    410e:	07d2      	lsls	r2, r2, #31
    4110:	d5fa      	bpl.n	4108 <PkaDoubleMdf2Mdf+0x88>
    4112:	4a3b      	ldr	r2, [pc, #236]	; (4200 <PkaDoubleMdf2Mdf+0x180>)
    4114:	601a      	str	r2, [r3, #0]
    4116:	680a      	ldr	r2, [r1, #0]
    4118:	920b      	str	r2, [sp, #44]	; 0x2c
    411a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    411c:	07d4      	lsls	r4, r2, #31
    411e:	d5fa      	bpl.n	4116 <PkaDoubleMdf2Mdf+0x96>
    4120:	4a38      	ldr	r2, [pc, #224]	; (4204 <PkaDoubleMdf2Mdf+0x184>)
    4122:	601a      	str	r2, [r3, #0]
    4124:	680a      	ldr	r2, [r1, #0]
    4126:	920c      	str	r2, [sp, #48]	; 0x30
    4128:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    412a:	07d2      	lsls	r2, r2, #31
    412c:	d5fa      	bpl.n	4124 <PkaDoubleMdf2Mdf+0xa4>
    412e:	4a36      	ldr	r2, [pc, #216]	; (4208 <PkaDoubleMdf2Mdf+0x188>)
    4130:	601a      	str	r2, [r3, #0]
    4132:	680a      	ldr	r2, [r1, #0]
    4134:	920d      	str	r2, [sp, #52]	; 0x34
    4136:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4138:	07d4      	lsls	r4, r2, #31
    413a:	d5fa      	bpl.n	4132 <PkaDoubleMdf2Mdf+0xb2>
    413c:	4a33      	ldr	r2, [pc, #204]	; (420c <PkaDoubleMdf2Mdf+0x18c>)
    413e:	601a      	str	r2, [r3, #0]
    4140:	680a      	ldr	r2, [r1, #0]
    4142:	920e      	str	r2, [sp, #56]	; 0x38
    4144:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4146:	07d2      	lsls	r2, r2, #31
    4148:	d5fa      	bpl.n	4140 <PkaDoubleMdf2Mdf+0xc0>
    414a:	4a31      	ldr	r2, [pc, #196]	; (4210 <PkaDoubleMdf2Mdf+0x190>)
    414c:	601a      	str	r2, [r3, #0]
    414e:	680a      	ldr	r2, [r1, #0]
    4150:	920f      	str	r2, [sp, #60]	; 0x3c
    4152:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    4154:	07d4      	lsls	r4, r2, #31
    4156:	d5fa      	bpl.n	414e <PkaDoubleMdf2Mdf+0xce>
    4158:	4a2e      	ldr	r2, [pc, #184]	; (4214 <PkaDoubleMdf2Mdf+0x194>)
    415a:	601a      	str	r2, [r3, #0]
    415c:	680a      	ldr	r2, [r1, #0]
    415e:	9210      	str	r2, [sp, #64]	; 0x40
    4160:	9a10      	ldr	r2, [sp, #64]	; 0x40
    4162:	07d2      	lsls	r2, r2, #31
    4164:	d5fa      	bpl.n	415c <PkaDoubleMdf2Mdf+0xdc>
    4166:	4a2c      	ldr	r2, [pc, #176]	; (4218 <PkaDoubleMdf2Mdf+0x198>)
    4168:	601a      	str	r2, [r3, #0]
    416a:	4b1a      	ldr	r3, [pc, #104]	; (41d4 <PkaDoubleMdf2Mdf+0x154>)
    416c:	4619      	mov	r1, r3
    416e:	681c      	ldr	r4, [r3, #0]
    4170:	9411      	str	r4, [sp, #68]	; 0x44
    4172:	9c11      	ldr	r4, [sp, #68]	; 0x44
    4174:	07e4      	lsls	r4, r4, #31
    4176:	d5fa      	bpl.n	416e <PkaDoubleMdf2Mdf+0xee>
    4178:	4b17      	ldr	r3, [pc, #92]	; (41d8 <PkaDoubleMdf2Mdf+0x158>)
    417a:	6018      	str	r0, [r3, #0]
    417c:	6808      	ldr	r0, [r1, #0]
    417e:	9012      	str	r0, [sp, #72]	; 0x48
    4180:	9812      	ldr	r0, [sp, #72]	; 0x48
    4182:	07c4      	lsls	r4, r0, #31
    4184:	d5fa      	bpl.n	417c <PkaDoubleMdf2Mdf+0xfc>
    4186:	601a      	str	r2, [r3, #0]
    4188:	680a      	ldr	r2, [r1, #0]
    418a:	9213      	str	r2, [sp, #76]	; 0x4c
    418c:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    418e:	07d0      	lsls	r0, r2, #31
    4190:	d5fa      	bpl.n	4188 <PkaDoubleMdf2Mdf+0x108>
    4192:	4a12      	ldr	r2, [pc, #72]	; (41dc <PkaDoubleMdf2Mdf+0x15c>)
    4194:	601a      	str	r2, [r3, #0]
    4196:	680a      	ldr	r2, [r1, #0]
    4198:	9214      	str	r2, [sp, #80]	; 0x50
    419a:	9a14      	ldr	r2, [sp, #80]	; 0x50
    419c:	07d2      	lsls	r2, r2, #31
    419e:	d5fa      	bpl.n	4196 <PkaDoubleMdf2Mdf+0x116>
    41a0:	4a1e      	ldr	r2, [pc, #120]	; (421c <PkaDoubleMdf2Mdf+0x19c>)
    41a2:	601a      	str	r2, [r3, #0]
    41a4:	680a      	ldr	r2, [r1, #0]
    41a6:	9215      	str	r2, [sp, #84]	; 0x54
    41a8:	9a15      	ldr	r2, [sp, #84]	; 0x54
    41aa:	07d4      	lsls	r4, r2, #31
    41ac:	d5fa      	bpl.n	41a4 <PkaDoubleMdf2Mdf+0x124>
    41ae:	4a1c      	ldr	r2, [pc, #112]	; (4220 <PkaDoubleMdf2Mdf+0x1a0>)
    41b0:	601a      	str	r2, [r3, #0]
    41b2:	680a      	ldr	r2, [r1, #0]
    41b4:	9216      	str	r2, [sp, #88]	; 0x58
    41b6:	9a16      	ldr	r2, [sp, #88]	; 0x58
    41b8:	07d0      	lsls	r0, r2, #31
    41ba:	d5fa      	bpl.n	41b2 <PkaDoubleMdf2Mdf+0x132>
    41bc:	4a19      	ldr	r2, [pc, #100]	; (4224 <PkaDoubleMdf2Mdf+0x1a4>)
    41be:	601a      	str	r2, [r3, #0]
    41c0:	680a      	ldr	r2, [r1, #0]
    41c2:	9217      	str	r2, [sp, #92]	; 0x5c
    41c4:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    41c6:	07d2      	lsls	r2, r2, #31
    41c8:	d5fa      	bpl.n	41c0 <PkaDoubleMdf2Mdf+0x140>
    41ca:	4a17      	ldr	r2, [pc, #92]	; (4228 <PkaDoubleMdf2Mdf+0x1a8>)
    41cc:	601a      	str	r2, [r3, #0]
    41ce:	b018      	add	sp, #96	; 0x60
    41d0:	bd10      	pop	{r4, pc}
    41d2:	bf00      	nop
    41d4:	5002b0b0 	.word	0x5002b0b0
    41d8:	5002b080 	.word	0x5002b080
    41dc:	21659300 	.word	0x21659300
    41e0:	90310400 	.word	0x90310400
    41e4:	90659640 	.word	0x90659640
    41e8:	21618300 	.word	0x21618300
    41ec:	2130c300 	.word	0x2130c300
    41f0:	9064c300 	.word	0x9064c300
    41f4:	90618100 	.word	0x90618100
    41f8:	21104600 	.word	0x21104600
    41fc:	21118100 	.word	0x21118100
    4200:	21444100 	.word	0x21444100
    4204:	2920c300 	.word	0x2920c300
    4208:	c810460c 	.word	0xc810460c
    420c:	21318600 	.word	0x21318600
    4210:	2160c300 	.word	0x2160c300
    4214:	2928c140 	.word	0x2928c140
    4218:	21659640 	.word	0x21659640
    421c:	90311300 	.word	0x90311300
    4220:	29259640 	.word	0x29259640
    4224:	c8144659 	.word	0xc8144659
    4228:	49320440 	.word	0x49320440

0000422c <PkaDoubleMdf2Jcb>:
    422c:	b510      	push	{r4, lr}
    422e:	4b49      	ldr	r3, [pc, #292]	; (4354 <PkaDoubleMdf2Jcb+0x128>)
    4230:	b094      	sub	sp, #80	; 0x50
    4232:	4619      	mov	r1, r3
    4234:	681a      	ldr	r2, [r3, #0]
    4236:	9200      	str	r2, [sp, #0]
    4238:	9a00      	ldr	r2, [sp, #0]
    423a:	07d2      	lsls	r2, r2, #31
    423c:	d5fa      	bpl.n	4234 <PkaDoubleMdf2Jcb+0x8>
    423e:	4b46      	ldr	r3, [pc, #280]	; (4358 <PkaDoubleMdf2Jcb+0x12c>)
    4240:	4a46      	ldr	r2, [pc, #280]	; (435c <PkaDoubleMdf2Jcb+0x130>)
    4242:	601a      	str	r2, [r3, #0]
    4244:	680a      	ldr	r2, [r1, #0]
    4246:	9201      	str	r2, [sp, #4]
    4248:	9a01      	ldr	r2, [sp, #4]
    424a:	07d4      	lsls	r4, r2, #31
    424c:	d5fa      	bpl.n	4244 <PkaDoubleMdf2Jcb+0x18>
    424e:	4a44      	ldr	r2, [pc, #272]	; (4360 <PkaDoubleMdf2Jcb+0x134>)
    4250:	601a      	str	r2, [r3, #0]
    4252:	680a      	ldr	r2, [r1, #0]
    4254:	9202      	str	r2, [sp, #8]
    4256:	9a02      	ldr	r2, [sp, #8]
    4258:	07d0      	lsls	r0, r2, #31
    425a:	d5fa      	bpl.n	4252 <PkaDoubleMdf2Jcb+0x26>
    425c:	4841      	ldr	r0, [pc, #260]	; (4364 <PkaDoubleMdf2Jcb+0x138>)
    425e:	6018      	str	r0, [r3, #0]
    4260:	680a      	ldr	r2, [r1, #0]
    4262:	9203      	str	r2, [sp, #12]
    4264:	9a03      	ldr	r2, [sp, #12]
    4266:	07d2      	lsls	r2, r2, #31
    4268:	d5fa      	bpl.n	4260 <PkaDoubleMdf2Jcb+0x34>
    426a:	4a3f      	ldr	r2, [pc, #252]	; (4368 <PkaDoubleMdf2Jcb+0x13c>)
    426c:	601a      	str	r2, [r3, #0]
    426e:	680a      	ldr	r2, [r1, #0]
    4270:	9204      	str	r2, [sp, #16]
    4272:	9a04      	ldr	r2, [sp, #16]
    4274:	07d4      	lsls	r4, r2, #31
    4276:	d5fa      	bpl.n	426e <PkaDoubleMdf2Jcb+0x42>
    4278:	4a3c      	ldr	r2, [pc, #240]	; (436c <PkaDoubleMdf2Jcb+0x140>)
    427a:	601a      	str	r2, [r3, #0]
    427c:	680a      	ldr	r2, [r1, #0]
    427e:	9205      	str	r2, [sp, #20]
    4280:	9a05      	ldr	r2, [sp, #20]
    4282:	07d2      	lsls	r2, r2, #31
    4284:	d5fa      	bpl.n	427c <PkaDoubleMdf2Jcb+0x50>
    4286:	4a3a      	ldr	r2, [pc, #232]	; (4370 <PkaDoubleMdf2Jcb+0x144>)
    4288:	601a      	str	r2, [r3, #0]
    428a:	680a      	ldr	r2, [r1, #0]
    428c:	9206      	str	r2, [sp, #24]
    428e:	9a06      	ldr	r2, [sp, #24]
    4290:	07d4      	lsls	r4, r2, #31
    4292:	d5fa      	bpl.n	428a <PkaDoubleMdf2Jcb+0x5e>
    4294:	4a37      	ldr	r2, [pc, #220]	; (4374 <PkaDoubleMdf2Jcb+0x148>)
    4296:	601a      	str	r2, [r3, #0]
    4298:	680a      	ldr	r2, [r1, #0]
    429a:	9207      	str	r2, [sp, #28]
    429c:	9a07      	ldr	r2, [sp, #28]
    429e:	07d2      	lsls	r2, r2, #31
    42a0:	d5fa      	bpl.n	4298 <PkaDoubleMdf2Jcb+0x6c>
    42a2:	4a35      	ldr	r2, [pc, #212]	; (4378 <PkaDoubleMdf2Jcb+0x14c>)
    42a4:	601a      	str	r2, [r3, #0]
    42a6:	680a      	ldr	r2, [r1, #0]
    42a8:	9208      	str	r2, [sp, #32]
    42aa:	9a08      	ldr	r2, [sp, #32]
    42ac:	07d4      	lsls	r4, r2, #31
    42ae:	d5fa      	bpl.n	42a6 <PkaDoubleMdf2Jcb+0x7a>
    42b0:	4a32      	ldr	r2, [pc, #200]	; (437c <PkaDoubleMdf2Jcb+0x150>)
    42b2:	601a      	str	r2, [r3, #0]
    42b4:	680a      	ldr	r2, [r1, #0]
    42b6:	9209      	str	r2, [sp, #36]	; 0x24
    42b8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    42ba:	07d2      	lsls	r2, r2, #31
    42bc:	d5fa      	bpl.n	42b4 <PkaDoubleMdf2Jcb+0x88>
    42be:	4a30      	ldr	r2, [pc, #192]	; (4380 <PkaDoubleMdf2Jcb+0x154>)
    42c0:	601a      	str	r2, [r3, #0]
    42c2:	680a      	ldr	r2, [r1, #0]
    42c4:	920a      	str	r2, [sp, #40]	; 0x28
    42c6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    42c8:	07d4      	lsls	r4, r2, #31
    42ca:	d5fa      	bpl.n	42c2 <PkaDoubleMdf2Jcb+0x96>
    42cc:	4a2d      	ldr	r2, [pc, #180]	; (4384 <PkaDoubleMdf2Jcb+0x158>)
    42ce:	601a      	str	r2, [r3, #0]
    42d0:	680a      	ldr	r2, [r1, #0]
    42d2:	920b      	str	r2, [sp, #44]	; 0x2c
    42d4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    42d6:	07d2      	lsls	r2, r2, #31
    42d8:	d5fa      	bpl.n	42d0 <PkaDoubleMdf2Jcb+0xa4>
    42da:	4a2b      	ldr	r2, [pc, #172]	; (4388 <PkaDoubleMdf2Jcb+0x15c>)
    42dc:	601a      	str	r2, [r3, #0]
    42de:	680a      	ldr	r2, [r1, #0]
    42e0:	920c      	str	r2, [sp, #48]	; 0x30
    42e2:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    42e4:	07d4      	lsls	r4, r2, #31
    42e6:	d5fa      	bpl.n	42de <PkaDoubleMdf2Jcb+0xb2>
    42e8:	4a28      	ldr	r2, [pc, #160]	; (438c <PkaDoubleMdf2Jcb+0x160>)
    42ea:	601a      	str	r2, [r3, #0]
    42ec:	680a      	ldr	r2, [r1, #0]
    42ee:	920d      	str	r2, [sp, #52]	; 0x34
    42f0:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    42f2:	07d2      	lsls	r2, r2, #31
    42f4:	d5fa      	bpl.n	42ec <PkaDoubleMdf2Jcb+0xc0>
    42f6:	4a26      	ldr	r2, [pc, #152]	; (4390 <PkaDoubleMdf2Jcb+0x164>)
    42f8:	601a      	str	r2, [r3, #0]
    42fa:	680a      	ldr	r2, [r1, #0]
    42fc:	920e      	str	r2, [sp, #56]	; 0x38
    42fe:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4300:	07d4      	lsls	r4, r2, #31
    4302:	d5fa      	bpl.n	42fa <PkaDoubleMdf2Jcb+0xce>
    4304:	4a23      	ldr	r2, [pc, #140]	; (4394 <PkaDoubleMdf2Jcb+0x168>)
    4306:	601a      	str	r2, [r3, #0]
    4308:	680a      	ldr	r2, [r1, #0]
    430a:	920f      	str	r2, [sp, #60]	; 0x3c
    430c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    430e:	07d2      	lsls	r2, r2, #31
    4310:	d5fa      	bpl.n	4308 <PkaDoubleMdf2Jcb+0xdc>
    4312:	4a21      	ldr	r2, [pc, #132]	; (4398 <PkaDoubleMdf2Jcb+0x16c>)
    4314:	601a      	str	r2, [r3, #0]
    4316:	4b0f      	ldr	r3, [pc, #60]	; (4354 <PkaDoubleMdf2Jcb+0x128>)
    4318:	4619      	mov	r1, r3
    431a:	681c      	ldr	r4, [r3, #0]
    431c:	9410      	str	r4, [sp, #64]	; 0x40
    431e:	9c10      	ldr	r4, [sp, #64]	; 0x40
    4320:	07e4      	lsls	r4, r4, #31
    4322:	d5fa      	bpl.n	431a <PkaDoubleMdf2Jcb+0xee>
    4324:	4b0c      	ldr	r3, [pc, #48]	; (4358 <PkaDoubleMdf2Jcb+0x12c>)
    4326:	6018      	str	r0, [r3, #0]
    4328:	6808      	ldr	r0, [r1, #0]
    432a:	9011      	str	r0, [sp, #68]	; 0x44
    432c:	9811      	ldr	r0, [sp, #68]	; 0x44
    432e:	07c4      	lsls	r4, r0, #31
    4330:	d5fa      	bpl.n	4328 <PkaDoubleMdf2Jcb+0xfc>
    4332:	601a      	str	r2, [r3, #0]
    4334:	680a      	ldr	r2, [r1, #0]
    4336:	9212      	str	r2, [sp, #72]	; 0x48
    4338:	9a12      	ldr	r2, [sp, #72]	; 0x48
    433a:	07d0      	lsls	r0, r2, #31
    433c:	d5fa      	bpl.n	4334 <PkaDoubleMdf2Jcb+0x108>
    433e:	4a17      	ldr	r2, [pc, #92]	; (439c <PkaDoubleMdf2Jcb+0x170>)
    4340:	601a      	str	r2, [r3, #0]
    4342:	680a      	ldr	r2, [r1, #0]
    4344:	9213      	str	r2, [sp, #76]	; 0x4c
    4346:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    4348:	07d2      	lsls	r2, r2, #31
    434a:	d5fa      	bpl.n	4342 <PkaDoubleMdf2Jcb+0x116>
    434c:	4a14      	ldr	r2, [pc, #80]	; (43a0 <PkaDoubleMdf2Jcb+0x174>)
    434e:	601a      	str	r2, [r3, #0]
    4350:	b014      	add	sp, #80	; 0x50
    4352:	bd10      	pop	{r4, pc}
    4354:	5002b0b0 	.word	0x5002b0b0
    4358:	5002b080 	.word	0x5002b080
    435c:	21659080 	.word	0x21659080
    4360:	90090400 	.word	0x90090400
    4364:	90659640 	.word	0x90659640
    4368:	21618080 	.word	0x21618080
    436c:	21082080 	.word	0x21082080
    4370:	90642080 	.word	0x90642080
    4374:	90618100 	.word	0x90618100
    4378:	21104600 	.word	0x21104600
    437c:	21118100 	.word	0x21118100
    4380:	21444100 	.word	0x21444100
    4384:	29202080 	.word	0x29202080
    4388:	c8104602 	.word	0xc8104602
    438c:	21098600 	.word	0x21098600
    4390:	21602080 	.word	0x21602080
    4394:	29282140 	.word	0x29282140
    4398:	21659640 	.word	0x21659640
    439c:	29259640 	.word	0x29259640
    43a0:	c8144659 	.word	0xc8144659

000043a4 <PkaAddJcbAfn2Mdf>:
    43a4:	b510      	push	{r4, lr}
    43a6:	4b50      	ldr	r3, [pc, #320]	; (44e8 <PkaAddJcbAfn2Mdf+0x144>)
    43a8:	b096      	sub	sp, #88	; 0x58
    43aa:	461c      	mov	r4, r3
    43ac:	681a      	ldr	r2, [r3, #0]
    43ae:	9201      	str	r2, [sp, #4]
    43b0:	9a01      	ldr	r2, [sp, #4]
    43b2:	07d2      	lsls	r2, r2, #31
    43b4:	d5fa      	bpl.n	43ac <PkaAddJcbAfn2Mdf+0x8>
    43b6:	4b4d      	ldr	r3, [pc, #308]	; (44ec <PkaAddJcbAfn2Mdf+0x148>)
    43b8:	4a4d      	ldr	r2, [pc, #308]	; (44f0 <PkaAddJcbAfn2Mdf+0x14c>)
    43ba:	601a      	str	r2, [r3, #0]
    43bc:	6822      	ldr	r2, [r4, #0]
    43be:	9202      	str	r2, [sp, #8]
    43c0:	9a02      	ldr	r2, [sp, #8]
    43c2:	07d2      	lsls	r2, r2, #31
    43c4:	d5fa      	bpl.n	43bc <PkaAddJcbAfn2Mdf+0x18>
    43c6:	4a4b      	ldr	r2, [pc, #300]	; (44f4 <PkaAddJcbAfn2Mdf+0x150>)
    43c8:	601a      	str	r2, [r3, #0]
    43ca:	4a4b      	ldr	r2, [pc, #300]	; (44f8 <PkaAddJcbAfn2Mdf+0x154>)
    43cc:	ea42 4080 	orr.w	r0, r2, r0, lsl #18
    43d0:	6822      	ldr	r2, [r4, #0]
    43d2:	9203      	str	r2, [sp, #12]
    43d4:	9a03      	ldr	r2, [sp, #12]
    43d6:	07d2      	lsls	r2, r2, #31
    43d8:	d5fa      	bpl.n	43d0 <PkaAddJcbAfn2Mdf+0x2c>
    43da:	6018      	str	r0, [r3, #0]
    43dc:	6822      	ldr	r2, [r4, #0]
    43de:	9204      	str	r2, [sp, #16]
    43e0:	9a04      	ldr	r2, [sp, #16]
    43e2:	07d0      	lsls	r0, r2, #31
    43e4:	d5fa      	bpl.n	43dc <PkaAddJcbAfn2Mdf+0x38>
    43e6:	4a45      	ldr	r2, [pc, #276]	; (44fc <PkaAddJcbAfn2Mdf+0x158>)
    43e8:	601a      	str	r2, [r3, #0]
    43ea:	f5a2 0280 	sub.w	r2, r2, #4194304	; 0x400000
    43ee:	ea42 4181 	orr.w	r1, r2, r1, lsl #18
    43f2:	6822      	ldr	r2, [r4, #0]
    43f4:	9205      	str	r2, [sp, #20]
    43f6:	9a05      	ldr	r2, [sp, #20]
    43f8:	07d2      	lsls	r2, r2, #31
    43fa:	d5fa      	bpl.n	43f2 <PkaAddJcbAfn2Mdf+0x4e>
    43fc:	6019      	str	r1, [r3, #0]
    43fe:	6822      	ldr	r2, [r4, #0]
    4400:	9206      	str	r2, [sp, #24]
    4402:	9a06      	ldr	r2, [sp, #24]
    4404:	07d0      	lsls	r0, r2, #31
    4406:	d5fa      	bpl.n	43fe <PkaAddJcbAfn2Mdf+0x5a>
    4408:	4a3d      	ldr	r2, [pc, #244]	; (4500 <PkaAddJcbAfn2Mdf+0x15c>)
    440a:	601a      	str	r2, [r3, #0]
    440c:	6822      	ldr	r2, [r4, #0]
    440e:	9207      	str	r2, [sp, #28]
    4410:	9a07      	ldr	r2, [sp, #28]
    4412:	07d1      	lsls	r1, r2, #31
    4414:	d5fa      	bpl.n	440c <PkaAddJcbAfn2Mdf+0x68>
    4416:	4a3b      	ldr	r2, [pc, #236]	; (4504 <PkaAddJcbAfn2Mdf+0x160>)
    4418:	601a      	str	r2, [r3, #0]
    441a:	6822      	ldr	r2, [r4, #0]
    441c:	9208      	str	r2, [sp, #32]
    441e:	9a08      	ldr	r2, [sp, #32]
    4420:	07d2      	lsls	r2, r2, #31
    4422:	d5fa      	bpl.n	441a <PkaAddJcbAfn2Mdf+0x76>
    4424:	4a38      	ldr	r2, [pc, #224]	; (4508 <PkaAddJcbAfn2Mdf+0x164>)
    4426:	601a      	str	r2, [r3, #0]
    4428:	6822      	ldr	r2, [r4, #0]
    442a:	9209      	str	r2, [sp, #36]	; 0x24
    442c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    442e:	07d0      	lsls	r0, r2, #31
    4430:	d5fa      	bpl.n	4428 <PkaAddJcbAfn2Mdf+0x84>
    4432:	4a36      	ldr	r2, [pc, #216]	; (450c <PkaAddJcbAfn2Mdf+0x168>)
    4434:	601a      	str	r2, [r3, #0]
    4436:	6822      	ldr	r2, [r4, #0]
    4438:	920a      	str	r2, [sp, #40]	; 0x28
    443a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    443c:	07d1      	lsls	r1, r2, #31
    443e:	d5fa      	bpl.n	4436 <PkaAddJcbAfn2Mdf+0x92>
    4440:	4a33      	ldr	r2, [pc, #204]	; (4510 <PkaAddJcbAfn2Mdf+0x16c>)
    4442:	601a      	str	r2, [r3, #0]
    4444:	6822      	ldr	r2, [r4, #0]
    4446:	920b      	str	r2, [sp, #44]	; 0x2c
    4448:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    444a:	07d2      	lsls	r2, r2, #31
    444c:	d5fa      	bpl.n	4444 <PkaAddJcbAfn2Mdf+0xa0>
    444e:	4a31      	ldr	r2, [pc, #196]	; (4514 <PkaAddJcbAfn2Mdf+0x170>)
    4450:	601a      	str	r2, [r3, #0]
    4452:	6822      	ldr	r2, [r4, #0]
    4454:	920c      	str	r2, [sp, #48]	; 0x30
    4456:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    4458:	07d0      	lsls	r0, r2, #31
    445a:	d5fa      	bpl.n	4452 <PkaAddJcbAfn2Mdf+0xae>
    445c:	4a2e      	ldr	r2, [pc, #184]	; (4518 <PkaAddJcbAfn2Mdf+0x174>)
    445e:	601a      	str	r2, [r3, #0]
    4460:	6822      	ldr	r2, [r4, #0]
    4462:	920d      	str	r2, [sp, #52]	; 0x34
    4464:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4466:	07d1      	lsls	r1, r2, #31
    4468:	d5fa      	bpl.n	4460 <PkaAddJcbAfn2Mdf+0xbc>
    446a:	4a2c      	ldr	r2, [pc, #176]	; (451c <PkaAddJcbAfn2Mdf+0x178>)
    446c:	601a      	str	r2, [r3, #0]
    446e:	6822      	ldr	r2, [r4, #0]
    4470:	920e      	str	r2, [sp, #56]	; 0x38
    4472:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    4474:	07d2      	lsls	r2, r2, #31
    4476:	d5fa      	bpl.n	446e <PkaAddJcbAfn2Mdf+0xca>
    4478:	4a29      	ldr	r2, [pc, #164]	; (4520 <PkaAddJcbAfn2Mdf+0x17c>)
    447a:	601a      	str	r2, [r3, #0]
    447c:	6822      	ldr	r2, [r4, #0]
    447e:	920f      	str	r2, [sp, #60]	; 0x3c
    4480:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    4482:	07d0      	lsls	r0, r2, #31
    4484:	d5fa      	bpl.n	447c <PkaAddJcbAfn2Mdf+0xd8>
    4486:	4a27      	ldr	r2, [pc, #156]	; (4524 <PkaAddJcbAfn2Mdf+0x180>)
    4488:	601a      	str	r2, [r3, #0]
    448a:	6821      	ldr	r1, [r4, #0]
    448c:	9110      	str	r1, [sp, #64]	; 0x40
    448e:	9910      	ldr	r1, [sp, #64]	; 0x40
    4490:	07c9      	lsls	r1, r1, #31
    4492:	d5fa      	bpl.n	448a <PkaAddJcbAfn2Mdf+0xe6>
    4494:	601a      	str	r2, [r3, #0]
    4496:	4b14      	ldr	r3, [pc, #80]	; (44e8 <PkaAddJcbAfn2Mdf+0x144>)
    4498:	461a      	mov	r2, r3
    449a:	6819      	ldr	r1, [r3, #0]
    449c:	9111      	str	r1, [sp, #68]	; 0x44
    449e:	9911      	ldr	r1, [sp, #68]	; 0x44
    44a0:	07c8      	lsls	r0, r1, #31
    44a2:	d5fa      	bpl.n	449a <PkaAddJcbAfn2Mdf+0xf6>
    44a4:	4b11      	ldr	r3, [pc, #68]	; (44ec <PkaAddJcbAfn2Mdf+0x148>)
    44a6:	4920      	ldr	r1, [pc, #128]	; (4528 <PkaAddJcbAfn2Mdf+0x184>)
    44a8:	6019      	str	r1, [r3, #0]
    44aa:	6811      	ldr	r1, [r2, #0]
    44ac:	9112      	str	r1, [sp, #72]	; 0x48
    44ae:	9912      	ldr	r1, [sp, #72]	; 0x48
    44b0:	07c9      	lsls	r1, r1, #31
    44b2:	d5fa      	bpl.n	44aa <PkaAddJcbAfn2Mdf+0x106>
    44b4:	491d      	ldr	r1, [pc, #116]	; (452c <PkaAddJcbAfn2Mdf+0x188>)
    44b6:	6019      	str	r1, [r3, #0]
    44b8:	6811      	ldr	r1, [r2, #0]
    44ba:	9113      	str	r1, [sp, #76]	; 0x4c
    44bc:	9913      	ldr	r1, [sp, #76]	; 0x4c
    44be:	07cc      	lsls	r4, r1, #31
    44c0:	d5fa      	bpl.n	44b8 <PkaAddJcbAfn2Mdf+0x114>
    44c2:	490b      	ldr	r1, [pc, #44]	; (44f0 <PkaAddJcbAfn2Mdf+0x14c>)
    44c4:	6019      	str	r1, [r3, #0]
    44c6:	6811      	ldr	r1, [r2, #0]
    44c8:	9114      	str	r1, [sp, #80]	; 0x50
    44ca:	9914      	ldr	r1, [sp, #80]	; 0x50
    44cc:	07c8      	lsls	r0, r1, #31
    44ce:	d5fa      	bpl.n	44c6 <PkaAddJcbAfn2Mdf+0x122>
    44d0:	4917      	ldr	r1, [pc, #92]	; (4530 <PkaAddJcbAfn2Mdf+0x18c>)
    44d2:	6019      	str	r1, [r3, #0]
    44d4:	6811      	ldr	r1, [r2, #0]
    44d6:	9115      	str	r1, [sp, #84]	; 0x54
    44d8:	9915      	ldr	r1, [sp, #84]	; 0x54
    44da:	07c9      	lsls	r1, r1, #31
    44dc:	d5fa      	bpl.n	44d4 <PkaAddJcbAfn2Mdf+0x130>
    44de:	4a15      	ldr	r2, [pc, #84]	; (4534 <PkaAddJcbAfn2Mdf+0x190>)
    44e0:	601a      	str	r2, [r3, #0]
    44e2:	b016      	add	sp, #88	; 0x58
    44e4:	bd10      	pop	{r4, pc}
    44e6:	bf00      	nop
    44e8:	5002b0b0 	.word	0x5002b0b0
    44ec:	5002b080 	.word	0x5002b080
    44f0:	90410440 	.word	0x90410440
    44f4:	29298600 	.word	0x29298600
    44f8:	c80110d8 	.word	0xc80110d8
    44fc:	90411440 	.word	0x90411440
    4500:	29211440 	.word	0x29211440
    4504:	21651440 	.word	0x21651440
    4508:	90403400 	.word	0x90403400
    450c:	900c3100 	.word	0x900c3100
    4510:	900c40c0 	.word	0x900c40c0
    4514:	292030c0 	.word	0x292030c0
    4518:	900d9640 	.word	0x900d9640
    451c:	90604100 	.word	0x90604100
    4520:	c8451603 	.word	0xc8451603
    4524:	21118600 	.word	0x21118600
    4528:	21604100 	.word	0x21604100
    452c:	c8444659 	.word	0xc8444659
    4530:	90451440 	.word	0x90451440
    4534:	902d1440 	.word	0x902d1440

00004538 <PkaJcb2Afn>:
    4538:	b570      	push	{r4, r5, r6, lr}
    453a:	4826      	ldr	r0, [pc, #152]	; (45d4 <PkaJcb2Afn+0x9c>)
    453c:	b088      	sub	sp, #32
    453e:	4605      	mov	r5, r0
    4540:	6804      	ldr	r4, [r0, #0]
    4542:	9400      	str	r4, [sp, #0]
    4544:	9c00      	ldr	r4, [sp, #0]
    4546:	07e6      	lsls	r6, r4, #31
    4548:	d5fa      	bpl.n	4540 <PkaJcb2Afn+0x8>
    454a:	4823      	ldr	r0, [pc, #140]	; (45d8 <PkaJcb2Afn+0xa0>)
    454c:	4c23      	ldr	r4, [pc, #140]	; (45dc <PkaJcb2Afn+0xa4>)
    454e:	6004      	str	r4, [r0, #0]
    4550:	4c23      	ldr	r4, [pc, #140]	; (45e0 <PkaJcb2Afn+0xa8>)
    4552:	ea44 4383 	orr.w	r3, r4, r3, lsl #18
    4556:	682c      	ldr	r4, [r5, #0]
    4558:	9401      	str	r4, [sp, #4]
    455a:	9c01      	ldr	r4, [sp, #4]
    455c:	07e4      	lsls	r4, r4, #31
    455e:	d5fa      	bpl.n	4556 <PkaJcb2Afn+0x1e>
    4560:	6003      	str	r3, [r0, #0]
    4562:	0193      	lsls	r3, r2, #6
    4564:	ea43 4282 	orr.w	r2, r3, r2, lsl #18
    4568:	f042 4410 	orr.w	r4, r2, #2415919104	; 0x90000000
    456c:	f444 44c0 	orr.w	r4, r4, #24576	; 0x6000
    4570:	682b      	ldr	r3, [r5, #0]
    4572:	9302      	str	r3, [sp, #8]
    4574:	9b02      	ldr	r3, [sp, #8]
    4576:	07de      	lsls	r6, r3, #31
    4578:	d5fa      	bpl.n	4570 <PkaJcb2Afn+0x38>
    457a:	6004      	str	r4, [r0, #0]
    457c:	682b      	ldr	r3, [r5, #0]
    457e:	9303      	str	r3, [sp, #12]
    4580:	9b03      	ldr	r3, [sp, #12]
    4582:	07db      	lsls	r3, r3, #31
    4584:	d5fa      	bpl.n	457c <PkaJcb2Afn+0x44>
    4586:	4b17      	ldr	r3, [pc, #92]	; (45e4 <PkaJcb2Afn+0xac>)
    4588:	6003      	str	r3, [r0, #0]
    458a:	018b      	lsls	r3, r1, #6
    458c:	ea43 4181 	orr.w	r1, r3, r1, lsl #18
    4590:	f041 4310 	orr.w	r3, r1, #2415919104	; 0x90000000
    4594:	f443 43c0 	orr.w	r3, r3, #24576	; 0x6000
    4598:	682e      	ldr	r6, [r5, #0]
    459a:	9604      	str	r6, [sp, #16]
    459c:	9e04      	ldr	r6, [sp, #16]
    459e:	07f6      	lsls	r6, r6, #31
    45a0:	d5fa      	bpl.n	4598 <PkaJcb2Afn+0x60>
    45a2:	6003      	str	r3, [r0, #0]
    45a4:	682b      	ldr	r3, [r5, #0]
    45a6:	9305      	str	r3, [sp, #20]
    45a8:	9b05      	ldr	r3, [sp, #20]
    45aa:	07de      	lsls	r6, r3, #31
    45ac:	d5fa      	bpl.n	45a4 <PkaJcb2Afn+0x6c>
    45ae:	6004      	str	r4, [r0, #0]
    45b0:	f041 4158 	orr.w	r1, r1, #3623878656	; 0xd8000000
    45b4:	682b      	ldr	r3, [r5, #0]
    45b6:	9306      	str	r3, [sp, #24]
    45b8:	9b06      	ldr	r3, [sp, #24]
    45ba:	07dc      	lsls	r4, r3, #31
    45bc:	d5fa      	bpl.n	45b4 <PkaJcb2Afn+0x7c>
    45be:	6001      	str	r1, [r0, #0]
    45c0:	f042 4258 	orr.w	r2, r2, #3623878656	; 0xd8000000
    45c4:	682b      	ldr	r3, [r5, #0]
    45c6:	9307      	str	r3, [sp, #28]
    45c8:	9b07      	ldr	r3, [sp, #28]
    45ca:	07db      	lsls	r3, r3, #31
    45cc:	d5fa      	bpl.n	45c4 <PkaJcb2Afn+0x8c>
    45ce:	6002      	str	r2, [r0, #0]
    45d0:	b008      	add	sp, #32
    45d2:	bd70      	pop	{r4, r5, r6, pc}
    45d4:	5002b0b0 	.word	0x5002b0b0
    45d8:	5002b080 	.word	0x5002b080
    45dc:	290221c0 	.word	0x290221c0
    45e0:	98007180 	.word	0x98007180
    45e4:	90186180 	.word	0x90186180

000045e8 <PkaAddAff>:
    45e8:	4b35      	ldr	r3, [pc, #212]	; (46c0 <PkaAddAff+0xd8>)
    45ea:	b08e      	sub	sp, #56	; 0x38
    45ec:	4619      	mov	r1, r3
    45ee:	681a      	ldr	r2, [r3, #0]
    45f0:	9200      	str	r2, [sp, #0]
    45f2:	9a00      	ldr	r2, [sp, #0]
    45f4:	07d2      	lsls	r2, r2, #31
    45f6:	d5fa      	bpl.n	45ee <PkaAddAff+0x6>
    45f8:	4b32      	ldr	r3, [pc, #200]	; (46c4 <PkaAddAff+0xdc>)
    45fa:	4a33      	ldr	r2, [pc, #204]	; (46c8 <PkaAddAff+0xe0>)
    45fc:	601a      	str	r2, [r3, #0]
    45fe:	680a      	ldr	r2, [r1, #0]
    4600:	9201      	str	r2, [sp, #4]
    4602:	9a01      	ldr	r2, [sp, #4]
    4604:	07d0      	lsls	r0, r2, #31
    4606:	d5fa      	bpl.n	45fe <PkaAddAff+0x16>
    4608:	4a30      	ldr	r2, [pc, #192]	; (46cc <PkaAddAff+0xe4>)
    460a:	601a      	str	r2, [r3, #0]
    460c:	680a      	ldr	r2, [r1, #0]
    460e:	9202      	str	r2, [sp, #8]
    4610:	9a02      	ldr	r2, [sp, #8]
    4612:	07d2      	lsls	r2, r2, #31
    4614:	d5fa      	bpl.n	460c <PkaAddAff+0x24>
    4616:	4a2e      	ldr	r2, [pc, #184]	; (46d0 <PkaAddAff+0xe8>)
    4618:	601a      	str	r2, [r3, #0]
    461a:	680a      	ldr	r2, [r1, #0]
    461c:	9203      	str	r2, [sp, #12]
    461e:	9a03      	ldr	r2, [sp, #12]
    4620:	07d0      	lsls	r0, r2, #31
    4622:	d5fa      	bpl.n	461a <PkaAddAff+0x32>
    4624:	4a2b      	ldr	r2, [pc, #172]	; (46d4 <PkaAddAff+0xec>)
    4626:	601a      	str	r2, [r3, #0]
    4628:	680a      	ldr	r2, [r1, #0]
    462a:	9204      	str	r2, [sp, #16]
    462c:	9a04      	ldr	r2, [sp, #16]
    462e:	07d2      	lsls	r2, r2, #31
    4630:	d5fa      	bpl.n	4628 <PkaAddAff+0x40>
    4632:	4a29      	ldr	r2, [pc, #164]	; (46d8 <PkaAddAff+0xf0>)
    4634:	601a      	str	r2, [r3, #0]
    4636:	680a      	ldr	r2, [r1, #0]
    4638:	9205      	str	r2, [sp, #20]
    463a:	9a05      	ldr	r2, [sp, #20]
    463c:	07d0      	lsls	r0, r2, #31
    463e:	d5fa      	bpl.n	4636 <PkaAddAff+0x4e>
    4640:	4a26      	ldr	r2, [pc, #152]	; (46dc <PkaAddAff+0xf4>)
    4642:	601a      	str	r2, [r3, #0]
    4644:	680a      	ldr	r2, [r1, #0]
    4646:	9206      	str	r2, [sp, #24]
    4648:	9a06      	ldr	r2, [sp, #24]
    464a:	07d2      	lsls	r2, r2, #31
    464c:	d5fa      	bpl.n	4644 <PkaAddAff+0x5c>
    464e:	4a24      	ldr	r2, [pc, #144]	; (46e0 <PkaAddAff+0xf8>)
    4650:	601a      	str	r2, [r3, #0]
    4652:	680a      	ldr	r2, [r1, #0]
    4654:	9207      	str	r2, [sp, #28]
    4656:	9a07      	ldr	r2, [sp, #28]
    4658:	07d0      	lsls	r0, r2, #31
    465a:	d5fa      	bpl.n	4652 <PkaAddAff+0x6a>
    465c:	4a21      	ldr	r2, [pc, #132]	; (46e4 <PkaAddAff+0xfc>)
    465e:	601a      	str	r2, [r3, #0]
    4660:	680a      	ldr	r2, [r1, #0]
    4662:	9208      	str	r2, [sp, #32]
    4664:	9a08      	ldr	r2, [sp, #32]
    4666:	07d2      	lsls	r2, r2, #31
    4668:	d5fa      	bpl.n	4660 <PkaAddAff+0x78>
    466a:	4a1f      	ldr	r2, [pc, #124]	; (46e8 <PkaAddAff+0x100>)
    466c:	601a      	str	r2, [r3, #0]
    466e:	680a      	ldr	r2, [r1, #0]
    4670:	9209      	str	r2, [sp, #36]	; 0x24
    4672:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4674:	07d0      	lsls	r0, r2, #31
    4676:	d5fa      	bpl.n	466e <PkaAddAff+0x86>
    4678:	4a1c      	ldr	r2, [pc, #112]	; (46ec <PkaAddAff+0x104>)
    467a:	601a      	str	r2, [r3, #0]
    467c:	680a      	ldr	r2, [r1, #0]
    467e:	920a      	str	r2, [sp, #40]	; 0x28
    4680:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    4682:	07d2      	lsls	r2, r2, #31
    4684:	d5fa      	bpl.n	467c <PkaAddAff+0x94>
    4686:	4a1a      	ldr	r2, [pc, #104]	; (46f0 <PkaAddAff+0x108>)
    4688:	601a      	str	r2, [r3, #0]
    468a:	6808      	ldr	r0, [r1, #0]
    468c:	900b      	str	r0, [sp, #44]	; 0x2c
    468e:	980b      	ldr	r0, [sp, #44]	; 0x2c
    4690:	07c0      	lsls	r0, r0, #31
    4692:	d5fa      	bpl.n	468a <PkaAddAff+0xa2>
    4694:	601a      	str	r2, [r3, #0]
    4696:	680a      	ldr	r2, [r1, #0]
    4698:	920c      	str	r2, [sp, #48]	; 0x30
    469a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    469c:	07d0      	lsls	r0, r2, #31
    469e:	d5fa      	bpl.n	4696 <PkaAddAff+0xae>
    46a0:	4a14      	ldr	r2, [pc, #80]	; (46f4 <PkaAddAff+0x10c>)
    46a2:	601a      	str	r2, [r3, #0]
    46a4:	680a      	ldr	r2, [r1, #0]
    46a6:	920d      	str	r2, [sp, #52]	; 0x34
    46a8:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    46aa:	07d2      	lsls	r2, r2, #31
    46ac:	d5fa      	bpl.n	46a4 <PkaAddAff+0xbc>
    46ae:	4a12      	ldr	r2, [pc, #72]	; (46f8 <PkaAddAff+0x110>)
    46b0:	601a      	str	r2, [r3, #0]
    46b2:	210e      	movs	r1, #14
    46b4:	230d      	movs	r3, #13
    46b6:	220f      	movs	r2, #15
    46b8:	2000      	movs	r0, #0
    46ba:	b00e      	add	sp, #56	; 0x38
    46bc:	f7ff bf3c 	b.w	4538 <PkaJcb2Afn>
    46c0:	5002b0b0 	.word	0x5002b0b0
    46c4:	5002b080 	.word	0x5002b080
    46c8:	29014380 	.word	0x29014380
    46cc:	21396340 	.word	0x21396340
    46d0:	29017080 	.word	0x29017080
    46d4:	21542080 	.word	0x21542080
    46d8:	9034d100 	.word	0x9034d100
    46dc:	903440c0 	.word	0x903440c0
    46e0:	292030c0 	.word	0x292030c0
    46e4:	900d53c0 	.word	0x900d53c0
    46e8:	90384100 	.word	0x90384100
    46ec:	c8082383 	.word	0xc8082383
    46f0:	2110e380 	.word	0x2110e380
    46f4:	21384100 	.word	0x21384100
    46f8:	c80843cf 	.word	0xc80843cf

000046fc <PkaSum2ScalarMullt>:
    46fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    4700:	2301      	movs	r3, #1
    4702:	b092      	sub	sp, #72	; 0x48
    4704:	e9cd 3303 	strd	r3, r3, [sp, #12]
    4708:	4b62      	ldr	r3, [pc, #392]	; (4894 <PkaSum2ScalarMullt+0x198>)
    470a:	461d      	mov	r5, r3
    470c:	681a      	ldr	r2, [r3, #0]
    470e:	9205      	str	r2, [sp, #20]
    4710:	9a05      	ldr	r2, [sp, #20]
    4712:	07d2      	lsls	r2, r2, #31
    4714:	d5fa      	bpl.n	470c <PkaSum2ScalarMullt+0x10>
    4716:	4c60      	ldr	r4, [pc, #384]	; (4898 <PkaSum2ScalarMullt+0x19c>)
    4718:	4b60      	ldr	r3, [pc, #384]	; (489c <PkaSum2ScalarMullt+0x1a0>)
    471a:	6023      	str	r3, [r4, #0]
    471c:	4b60      	ldr	r3, [pc, #384]	; (48a0 <PkaSum2ScalarMullt+0x1a4>)
    471e:	4619      	mov	r1, r3
    4720:	681a      	ldr	r2, [r3, #0]
    4722:	9206      	str	r2, [sp, #24]
    4724:	9a06      	ldr	r2, [sp, #24]
    4726:	07d7      	lsls	r7, r2, #31
    4728:	d5fa      	bpl.n	4720 <PkaSum2ScalarMullt+0x24>
    472a:	4b5e      	ldr	r3, [pc, #376]	; (48a4 <PkaSum2ScalarMullt+0x1a8>)
    472c:	681a      	ldr	r2, [r3, #0]
    472e:	04d6      	lsls	r6, r2, #19
    4730:	f100 80a8 	bmi.w	4884 <PkaSum2ScalarMullt+0x188>
    4734:	682a      	ldr	r2, [r5, #0]
    4736:	9207      	str	r2, [sp, #28]
    4738:	9a07      	ldr	r2, [sp, #28]
    473a:	07d0      	lsls	r0, r2, #31
    473c:	d5fa      	bpl.n	4734 <PkaSum2ScalarMullt+0x38>
    473e:	4a5a      	ldr	r2, [pc, #360]	; (48a8 <PkaSum2ScalarMullt+0x1ac>)
    4740:	6022      	str	r2, [r4, #0]
    4742:	680a      	ldr	r2, [r1, #0]
    4744:	9208      	str	r2, [sp, #32]
    4746:	9a08      	ldr	r2, [sp, #32]
    4748:	07d2      	lsls	r2, r2, #31
    474a:	d5fa      	bpl.n	4742 <PkaSum2ScalarMullt+0x46>
    474c:	681e      	ldr	r6, [r3, #0]
    474e:	f3c6 3600 	ubfx	r6, r6, #12, #1
    4752:	2e00      	cmp	r6, #0
    4754:	f040 8098 	bne.w	4888 <PkaSum2ScalarMullt+0x18c>
    4758:	2012      	movs	r0, #18
    475a:	f7ff f8f9 	bl	3950 <PkaGetRegEffectiveSizeInBits>
    475e:	4607      	mov	r7, r0
    4760:	2013      	movs	r0, #19
    4762:	f7ff f8f5 	bl	3950 <PkaGetRegEffectiveSizeInBits>
    4766:	4287      	cmp	r7, r0
    4768:	bf8c      	ite	hi
    476a:	2012      	movhi	r0, #18
    476c:	2013      	movls	r0, #19
    476e:	f7ff f8ef 	bl	3950 <PkaGetRegEffectiveSizeInBits>
    4772:	1e47      	subs	r7, r0, #1
    4774:	f7ff ff38 	bl	45e8 <PkaAddAff>
    4778:	ab03      	add	r3, sp, #12
    477a:	aa01      	add	r2, sp, #4
    477c:	4639      	mov	r1, r7
    477e:	2012      	movs	r0, #18
    4780:	f7ff f92c 	bl	39dc <PkaGetNextMsBit>
    4784:	ab04      	add	r3, sp, #16
    4786:	4680      	mov	r8, r0
    4788:	aa02      	add	r2, sp, #8
    478a:	4639      	mov	r1, r7
    478c:	2013      	movs	r0, #19
    478e:	f7ff f925 	bl	39dc <PkaGetNextMsBit>
    4792:	eb00 0048 	add.w	r0, r0, r8, lsl #1
    4796:	2802      	cmp	r0, #2
    4798:	d032      	beq.n	4800 <PkaSum2ScalarMullt+0x104>
    479a:	2803      	cmp	r0, #3
    479c:	d03e      	beq.n	481c <PkaSum2ScalarMullt+0x120>
    479e:	2801      	cmp	r0, #1
    47a0:	d174      	bne.n	488c <PkaSum2ScalarMullt+0x190>
    47a2:	682b      	ldr	r3, [r5, #0]
    47a4:	9309      	str	r3, [sp, #36]	; 0x24
    47a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    47a8:	07db      	lsls	r3, r3, #31
    47aa:	d5fa      	bpl.n	47a2 <PkaSum2ScalarMullt+0xa6>
    47ac:	4b3f      	ldr	r3, [pc, #252]	; (48ac <PkaSum2ScalarMullt+0x1b0>)
    47ae:	6023      	str	r3, [r4, #0]
    47b0:	682b      	ldr	r3, [r5, #0]
    47b2:	930a      	str	r3, [sp, #40]	; 0x28
    47b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    47b6:	07d8      	lsls	r0, r3, #31
    47b8:	d5fa      	bpl.n	47b0 <PkaSum2ScalarMullt+0xb4>
    47ba:	4b3d      	ldr	r3, [pc, #244]	; (48b0 <PkaSum2ScalarMullt+0x1b4>)
    47bc:	6023      	str	r3, [r4, #0]
    47be:	682b      	ldr	r3, [r5, #0]
    47c0:	930f      	str	r3, [sp, #60]	; 0x3c
    47c2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    47c4:	07d9      	lsls	r1, r3, #31
    47c6:	d5fa      	bpl.n	47be <PkaSum2ScalarMullt+0xc2>
    47c8:	4b3a      	ldr	r3, [pc, #232]	; (48b4 <PkaSum2ScalarMullt+0x1b8>)
    47ca:	6023      	str	r3, [r4, #0]
    47cc:	682b      	ldr	r3, [r5, #0]
    47ce:	9310      	str	r3, [sp, #64]	; 0x40
    47d0:	9b10      	ldr	r3, [sp, #64]	; 0x40
    47d2:	07da      	lsls	r2, r3, #31
    47d4:	d5fa      	bpl.n	47cc <PkaSum2ScalarMullt+0xd0>
    47d6:	4b38      	ldr	r3, [pc, #224]	; (48b8 <PkaSum2ScalarMullt+0x1bc>)
    47d8:	6023      	str	r3, [r4, #0]
    47da:	682b      	ldr	r3, [r5, #0]
    47dc:	9311      	str	r3, [sp, #68]	; 0x44
    47de:	9b11      	ldr	r3, [sp, #68]	; 0x44
    47e0:	07db      	lsls	r3, r3, #31
    47e2:	d5fa      	bpl.n	47da <PkaSum2ScalarMullt+0xde>
    47e4:	4b35      	ldr	r3, [pc, #212]	; (48bc <PkaSum2ScalarMullt+0x1c0>)
    47e6:	6023      	str	r3, [r4, #0]
    47e8:	3f01      	subs	r7, #1
    47ea:	d525      	bpl.n	4838 <PkaSum2ScalarMullt+0x13c>
    47ec:	2310      	movs	r3, #16
    47ee:	2219      	movs	r2, #25
    47f0:	2118      	movs	r1, #24
    47f2:	2000      	movs	r0, #0
    47f4:	f7ff fea0 	bl	4538 <PkaJcb2Afn>
    47f8:	4630      	mov	r0, r6
    47fa:	b012      	add	sp, #72	; 0x48
    47fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    4800:	682b      	ldr	r3, [r5, #0]
    4802:	930b      	str	r3, [sp, #44]	; 0x2c
    4804:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    4806:	07d9      	lsls	r1, r3, #31
    4808:	d5fa      	bpl.n	4800 <PkaSum2ScalarMullt+0x104>
    480a:	4b2d      	ldr	r3, [pc, #180]	; (48c0 <PkaSum2ScalarMullt+0x1c4>)
    480c:	6023      	str	r3, [r4, #0]
    480e:	682b      	ldr	r3, [r5, #0]
    4810:	930c      	str	r3, [sp, #48]	; 0x30
    4812:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    4814:	07da      	lsls	r2, r3, #31
    4816:	d5fa      	bpl.n	480e <PkaSum2ScalarMullt+0x112>
    4818:	4b2a      	ldr	r3, [pc, #168]	; (48c4 <PkaSum2ScalarMullt+0x1c8>)
    481a:	e7cf      	b.n	47bc <PkaSum2ScalarMullt+0xc0>
    481c:	682b      	ldr	r3, [r5, #0]
    481e:	930d      	str	r3, [sp, #52]	; 0x34
    4820:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    4822:	07db      	lsls	r3, r3, #31
    4824:	d5fa      	bpl.n	481c <PkaSum2ScalarMullt+0x120>
    4826:	4b28      	ldr	r3, [pc, #160]	; (48c8 <PkaSum2ScalarMullt+0x1cc>)
    4828:	6023      	str	r3, [r4, #0]
    482a:	682b      	ldr	r3, [r5, #0]
    482c:	930e      	str	r3, [sp, #56]	; 0x38
    482e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    4830:	07d8      	lsls	r0, r3, #31
    4832:	d5fa      	bpl.n	482a <PkaSum2ScalarMullt+0x12e>
    4834:	4b25      	ldr	r3, [pc, #148]	; (48cc <PkaSum2ScalarMullt+0x1d0>)
    4836:	e7c1      	b.n	47bc <PkaSum2ScalarMullt+0xc0>
    4838:	ab03      	add	r3, sp, #12
    483a:	aa01      	add	r2, sp, #4
    483c:	4639      	mov	r1, r7
    483e:	2012      	movs	r0, #18
    4840:	f7ff f8cc 	bl	39dc <PkaGetNextMsBit>
    4844:	ab04      	add	r3, sp, #16
    4846:	4604      	mov	r4, r0
    4848:	aa02      	add	r2, sp, #8
    484a:	4639      	mov	r1, r7
    484c:	2013      	movs	r0, #19
    484e:	f7ff f8c5 	bl	39dc <PkaGetNextMsBit>
    4852:	eb10 0444 	adds.w	r4, r0, r4, lsl #1
    4856:	d102      	bne.n	485e <PkaSum2ScalarMullt+0x162>
    4858:	f7ff fc12 	bl	4080 <PkaDoubleMdf2Mdf>
    485c:	e7c4      	b.n	47e8 <PkaSum2ScalarMullt+0xec>
    485e:	f7ff fce5 	bl	422c <PkaDoubleMdf2Jcb>
    4862:	2c02      	cmp	r4, #2
    4864:	d008      	beq.n	4878 <PkaSum2ScalarMullt+0x17c>
    4866:	2c03      	cmp	r4, #3
    4868:	d009      	beq.n	487e <PkaSum2ScalarMullt+0x182>
    486a:	2c01      	cmp	r4, #1
    486c:	d110      	bne.n	4890 <PkaSum2ScalarMullt+0x194>
    486e:	2117      	movs	r1, #23
    4870:	2016      	movs	r0, #22
    4872:	f7ff fd97 	bl	43a4 <PkaAddJcbAfn2Mdf>
    4876:	e7b7      	b.n	47e8 <PkaSum2ScalarMullt+0xec>
    4878:	2115      	movs	r1, #21
    487a:	2014      	movs	r0, #20
    487c:	e7f9      	b.n	4872 <PkaSum2ScalarMullt+0x176>
    487e:	210f      	movs	r1, #15
    4880:	200e      	movs	r0, #14
    4882:	e7f6      	b.n	4872 <PkaSum2ScalarMullt+0x176>
    4884:	4e12      	ldr	r6, [pc, #72]	; (48d0 <PkaSum2ScalarMullt+0x1d4>)
    4886:	e7b7      	b.n	47f8 <PkaSum2ScalarMullt+0xfc>
    4888:	4e12      	ldr	r6, [pc, #72]	; (48d4 <PkaSum2ScalarMullt+0x1d8>)
    488a:	e7b5      	b.n	47f8 <PkaSum2ScalarMullt+0xfc>
    488c:	4e12      	ldr	r6, [pc, #72]	; (48d8 <PkaSum2ScalarMullt+0x1dc>)
    488e:	e7b3      	b.n	47f8 <PkaSum2ScalarMullt+0xfc>
    4890:	4e12      	ldr	r6, [pc, #72]	; (48dc <PkaSum2ScalarMullt+0x1e0>)
    4892:	e7b1      	b.n	47f8 <PkaSum2ScalarMullt+0xfc>
    4894:	5002b0b0 	.word	0x5002b0b0
    4898:	5002b080 	.word	0x5002b080
    489c:	514a0800 	.word	0x514a0800
    48a0:	5002b0b4 	.word	0x5002b0b4
    48a4:	5002b088 	.word	0x5002b088
    48a8:	514e0800 	.word	0x514e0800
    48ac:	495a0600 	.word	0x495a0600
    48b0:	495e0640 	.word	0x495e0640
    48b4:	41420400 	.word	0x41420400
    48b8:	49421400 	.word	0x49421400
    48bc:	492e0440 	.word	0x492e0440
    48c0:	49520600 	.word	0x49520600
    48c4:	49560640 	.word	0x49560640
    48c8:	493a0600 	.word	0x493a0600
    48cc:	493e0640 	.word	0x493e0640
    48d0:	00f10806 	.word	0x00f10806
    48d4:	00f10807 	.word	0x00f10807
    48d8:	00f10804 	.word	0x00f10804
    48dc:	00f10805 	.word	0x00f10805

000048e0 <SaSi_HalClearInterruptBit>:
    48e0:	4b01      	ldr	r3, [pc, #4]	; (48e8 <SaSi_HalClearInterruptBit+0x8>)
    48e2:	6018      	str	r0, [r3, #0]
    48e4:	4770      	bx	lr
    48e6:	bf00      	nop
    48e8:	5002ba08 	.word	0x5002ba08

000048ec <SaSi_HalMaskInterrupt>:
    48ec:	4b01      	ldr	r3, [pc, #4]	; (48f4 <SaSi_HalMaskInterrupt+0x8>)
    48ee:	6018      	str	r0, [r3, #0]
    48f0:	4770      	bx	lr
    48f2:	bf00      	nop
    48f4:	5002ba04 	.word	0x5002ba04

000048f8 <SaSi_HalWaitInterrupt>:
    48f8:	4a03      	ldr	r2, [pc, #12]	; (4908 <SaSi_HalWaitInterrupt+0x10>)
    48fa:	6813      	ldr	r3, [r2, #0]
    48fc:	4218      	tst	r0, r3
    48fe:	d0fc      	beq.n	48fa <SaSi_HalWaitInterrupt+0x2>
    4900:	4a02      	ldr	r2, [pc, #8]	; (490c <SaSi_HalWaitInterrupt+0x14>)
    4902:	6010      	str	r0, [r2, #0]
    4904:	4618      	mov	r0, r3
    4906:	4770      	bx	lr
    4908:	5002ba00 	.word	0x5002ba00
    490c:	5002ba08 	.word	0x5002ba08

00004910 <flash_device_base>:

int flash_device_base(uint8_t fd_id, uintptr_t *ret)
{
    if (fd_id != FLASH_DEVICE_ID) {
    4910:	b908      	cbnz	r0, 4916 <flash_device_base+0x6>
        BOOT_LOG_ERR("invalid flash ID %d; expected %d",
                     fd_id, FLASH_DEVICE_ID);
        return -EINVAL;
    }
    *ret = FLASH_DEVICE_BASE;
    4912:	6008      	str	r0, [r1, #0]
    return 0;
    4914:	4770      	bx	lr
        return -EINVAL;
    4916:	f06f 0015 	mvn.w	r0, #21
}
    491a:	4770      	bx	lr

0000491c <flash_area_id_from_multi_image_slot>:
 * MCUBoot uses continuous numbering for the primary slot, the secondary slot,
 * and the scratch while zephyr might number it differently.
 */
int flash_area_id_from_multi_image_slot(int image_index, int slot)
{
    switch (slot) {
    491c:	4608      	mov	r0, r1
    491e:	b129      	cbz	r1, 492c <flash_area_id_from_multi_image_slot+0x10>
#if defined(CONFIG_BOOT_SWAP_USING_SCRATCH)
    case 2: return FLASH_AREA_IMAGE_SCRATCH;
#endif
    }

    return -EINVAL; /* flash_area_open will fail on that */
    4920:	2901      	cmp	r1, #1
    4922:	bf0c      	ite	eq
    4924:	4608      	moveq	r0, r1
    4926:	f06f 0015 	mvnne.w	r0, #21
    492a:	4770      	bx	lr
    case 0: return FLASH_AREA_IMAGE_PRIMARY(image_index);
    492c:	2003      	movs	r0, #3
}
    492e:	4770      	bx	lr

00004930 <flash_area_get_device_id>:

uint8_t flash_area_get_device_id(const struct flash_area *fa)
{
	(void)fa;
	return FLASH_DEVICE_ID;
}
    4930:	2000      	movs	r0, #0
    4932:	4770      	bx	lr

00004934 <os_heap_init>:
    mbedtls_memory_buffer_alloc_init(mempool, sizeof(mempool));
}
#else
void os_heap_init(void)
{
}
    4934:	4770      	bx	lr

00004936 <bootutil_tlv_iter_begin>:
 *          -1 on errors
 */
int
bootutil_tlv_iter_begin(struct image_tlv_iter *it, const struct image_header *hdr,
                        const struct flash_area *fap, uint16_t type, bool prot)
{
    4936:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    493a:	460e      	mov	r6, r1
    493c:	4617      	mov	r7, r2
    493e:	4699      	mov	r9, r3
    uint32_t off_;
    struct image_tlv_info info;

    if (it == NULL || hdr == NULL || fap == NULL) {
    4940:	4604      	mov	r4, r0
    4942:	b928      	cbnz	r0, 4950 <bootutil_tlv_iter_begin+0x1a>
        return -1;
    4944:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
    // position on first TLV
    it->tlv_off = off_ + sizeof(info);
    return 0;
}
    4948:	4640      	mov	r0, r8
    494a:	b003      	add	sp, #12
    494c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (it == NULL || hdr == NULL || fap == NULL) {
    4950:	2900      	cmp	r1, #0
    4952:	d0f7      	beq.n	4944 <bootutil_tlv_iter_begin+0xe>
    4954:	2a00      	cmp	r2, #0
    4956:	d0f5      	beq.n	4944 <bootutil_tlv_iter_begin+0xe>
    off_ = BOOT_TLV_OFF(hdr);
    4958:	68cb      	ldr	r3, [r1, #12]
    495a:	890d      	ldrh	r5, [r1, #8]
    495c:	441d      	add	r5, r3
    if (LOAD_IMAGE_DATA(hdr, fap, off_, &info, sizeof(info))) {
    495e:	2304      	movs	r3, #4
    4960:	eb0d 0203 	add.w	r2, sp, r3
    4964:	4629      	mov	r1, r5
    4966:	4638      	mov	r0, r7
    4968:	f000 fcaf 	bl	52ca <flash_area_read>
    496c:	4680      	mov	r8, r0
    496e:	2800      	cmp	r0, #0
    4970:	d1e8      	bne.n	4944 <bootutil_tlv_iter_begin+0xe>
    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
    4972:	f8bd 1004 	ldrh.w	r1, [sp, #4]
        if (hdr->ih_protect_tlv_size != info.it_tlv_tot) {
    4976:	8973      	ldrh	r3, [r6, #10]
    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
    4978:	f646 1208 	movw	r2, #26888	; 0x6908
    497c:	4291      	cmp	r1, r2
    497e:	d123      	bne.n	49c8 <bootutil_tlv_iter_begin+0x92>
        if (hdr->ih_protect_tlv_size != info.it_tlv_tot) {
    4980:	f8bd 1006 	ldrh.w	r1, [sp, #6]
    4984:	4299      	cmp	r1, r3
    4986:	d1dd      	bne.n	4944 <bootutil_tlv_iter_begin+0xe>
        if (LOAD_IMAGE_DATA(hdr, fap, off_ + info.it_tlv_tot,
    4988:	2304      	movs	r3, #4
    498a:	eb0d 0203 	add.w	r2, sp, r3
    498e:	4429      	add	r1, r5
    4990:	4638      	mov	r0, r7
    4992:	f000 fc9a 	bl	52ca <flash_area_read>
    4996:	2800      	cmp	r0, #0
    4998:	d1d4      	bne.n	4944 <bootutil_tlv_iter_begin+0xe>
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
    499a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    499e:	f646 1307 	movw	r3, #26887	; 0x6907
    49a2:	429a      	cmp	r2, r3
    49a4:	d1ce      	bne.n	4944 <bootutil_tlv_iter_begin+0xe>
    it->prot = prot;
    49a6:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
    49aa:	72a3      	strb	r3, [r4, #10]
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
    49ac:	8973      	ldrh	r3, [r6, #10]
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
    49ae:	f8bd 2006 	ldrh.w	r2, [sp, #6]
    it->type = type;
    49b2:	f8a4 9008 	strh.w	r9, [r4, #8]
    it->prot_end = off_ + it->hdr->ih_protect_tlv_size;
    49b6:	442b      	add	r3, r5
    49b8:	60e3      	str	r3, [r4, #12]
    it->tlv_off = off_ + sizeof(info);
    49ba:	3504      	adds	r5, #4
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
    49bc:	4413      	add	r3, r2
    it->fap = fap;
    49be:	e9c4 6700 	strd	r6, r7, [r4]
    it->tlv_end = off_ + it->hdr->ih_protect_tlv_size + info.it_tlv_tot;
    49c2:	6163      	str	r3, [r4, #20]
    it->tlv_off = off_ + sizeof(info);
    49c4:	6125      	str	r5, [r4, #16]
    return 0;
    49c6:	e7bf      	b.n	4948 <bootutil_tlv_iter_begin+0x12>
    } else if (hdr->ih_protect_tlv_size != 0) {
    49c8:	2b00      	cmp	r3, #0
    49ca:	d0e6      	beq.n	499a <bootutil_tlv_iter_begin+0x64>
    49cc:	e7ba      	b.n	4944 <bootutil_tlv_iter_begin+0xe>

000049ce <bootutil_tlv_iter_next>:
 *          -1 on errors
 */
int
bootutil_tlv_iter_next(struct image_tlv_iter *it, uint32_t *off, uint16_t *len,
                       uint16_t *type)
{
    49ce:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    49d2:	460f      	mov	r7, r1
    49d4:	4690      	mov	r8, r2
    49d6:	461e      	mov	r6, r3
    struct image_tlv tlv;
    int rc;

    if (it == NULL || it->hdr == NULL || it->fap == NULL) {
    49d8:	4604      	mov	r4, r0
    49da:	b920      	cbnz	r0, 49e6 <bootutil_tlv_iter_next+0x18>
        return -1;
    49dc:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff

        it->tlv_off += sizeof(tlv) + tlv.it_len;
    }

    return 1;
}
    49e0:	b003      	add	sp, #12
    49e2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    if (it == NULL || it->hdr == NULL || it->fap == NULL) {
    49e6:	6803      	ldr	r3, [r0, #0]
    49e8:	2b00      	cmp	r3, #0
    49ea:	d0f7      	beq.n	49dc <bootutil_tlv_iter_next+0xe>
    49ec:	6843      	ldr	r3, [r0, #4]
    49ee:	2b00      	cmp	r3, #0
    49f0:	d0f4      	beq.n	49dc <bootutil_tlv_iter_next+0xe>
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
    49f2:	f64f 79ff 	movw	r9, #65535	; 0xffff
    while (it->tlv_off < it->tlv_end) {
    49f6:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
    49fa:	429a      	cmp	r2, r3
    49fc:	d216      	bcs.n	4a2c <bootutil_tlv_iter_next+0x5e>
        if (it->hdr->ih_protect_tlv_size > 0 && it->tlv_off == it->prot_end) {
    49fe:	6823      	ldr	r3, [r4, #0]
    4a00:	895b      	ldrh	r3, [r3, #10]
    4a02:	b123      	cbz	r3, 4a0e <bootutil_tlv_iter_next+0x40>
    4a04:	68e3      	ldr	r3, [r4, #12]
    4a06:	4293      	cmp	r3, r2
            it->tlv_off += sizeof(struct image_tlv_info);
    4a08:	bf04      	itt	eq
    4a0a:	3304      	addeq	r3, #4
    4a0c:	6123      	streq	r3, [r4, #16]
        rc = LOAD_IMAGE_DATA(it->hdr, it->fap, it->tlv_off, &tlv, sizeof tlv);
    4a0e:	2304      	movs	r3, #4
    4a10:	6921      	ldr	r1, [r4, #16]
    4a12:	6860      	ldr	r0, [r4, #4]
    4a14:	eb0d 0203 	add.w	r2, sp, r3
    4a18:	f000 fc57 	bl	52ca <flash_area_read>
        if (rc) {
    4a1c:	2800      	cmp	r0, #0
    4a1e:	d1dd      	bne.n	49dc <bootutil_tlv_iter_next+0xe>
        if (it->prot && it->tlv_off >= it->prot_end) {
    4a20:	7aa3      	ldrb	r3, [r4, #10]
    4a22:	6925      	ldr	r5, [r4, #16]
    4a24:	b123      	cbz	r3, 4a30 <bootutil_tlv_iter_next+0x62>
    4a26:	68e3      	ldr	r3, [r4, #12]
    4a28:	42ab      	cmp	r3, r5
    4a2a:	d801      	bhi.n	4a30 <bootutil_tlv_iter_next+0x62>
            return 1;
    4a2c:	2001      	movs	r0, #1
    4a2e:	e7d7      	b.n	49e0 <bootutil_tlv_iter_next+0x12>
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
    4a30:	8921      	ldrh	r1, [r4, #8]
        it->tlv_off += sizeof(tlv) + tlv.it_len;
    4a32:	f8bd 2006 	ldrh.w	r2, [sp, #6]
        if (it->type == IMAGE_TLV_ANY || tlv.it_type == it->type) {
    4a36:	4549      	cmp	r1, r9
    4a38:	f102 0304 	add.w	r3, r2, #4
    4a3c:	d003      	beq.n	4a46 <bootutil_tlv_iter_next+0x78>
    4a3e:	f8bd c004 	ldrh.w	ip, [sp, #4]
    4a42:	458c      	cmp	ip, r1
    4a44:	d10b      	bne.n	4a5e <bootutil_tlv_iter_next+0x90>
            if (type != NULL) {
    4a46:	b116      	cbz	r6, 4a4e <bootutil_tlv_iter_next+0x80>
                *type = tlv.it_type;
    4a48:	f8bd 1004 	ldrh.w	r1, [sp, #4]
    4a4c:	8031      	strh	r1, [r6, #0]
            *off = it->tlv_off + sizeof(tlv);
    4a4e:	3504      	adds	r5, #4
    4a50:	603d      	str	r5, [r7, #0]
            *len = tlv.it_len;
    4a52:	f8a8 2000 	strh.w	r2, [r8]
            it->tlv_off += sizeof(tlv) + tlv.it_len;
    4a56:	6922      	ldr	r2, [r4, #16]
    4a58:	4413      	add	r3, r2
    4a5a:	6123      	str	r3, [r4, #16]
            return 0;
    4a5c:	e7c0      	b.n	49e0 <bootutil_tlv_iter_next+0x12>
        it->tlv_off += sizeof(tlv) + tlv.it_len;
    4a5e:	442b      	add	r3, r5
    4a60:	6123      	str	r3, [r4, #16]
    4a62:	e7c8      	b.n	49f6 <bootutil_tlv_iter_next+0x28>

00004a64 <bootutil_read_bigint>:
{
    4a64:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4a66:	460c      	mov	r4, r1
    4a68:	4606      	mov	r6, r0
    4a6a:	4611      	mov	r1, r2
    if (mbedtls_asn1_get_tag(cp, end, &len, MBEDTLS_ASN1_INTEGER)) {
    4a6c:	2302      	movs	r3, #2
    4a6e:	aa01      	add	r2, sp, #4
    4a70:	4620      	mov	r0, r4
    4a72:	f000 fad0 	bl	5016 <mbedtls_asn1_get_tag>
    4a76:	4605      	mov	r5, r0
    4a78:	b9e8      	cbnz	r0, 4ab6 <bootutil_read_bigint+0x52>
    if (len >= NUM_ECC_BYTES) {
    4a7a:	9a01      	ldr	r2, [sp, #4]
    4a7c:	2a1f      	cmp	r2, #31
    4a7e:	d90e      	bls.n	4a9e <bootutil_read_bigint+0x3a>
        memcpy(i, *cp + len - NUM_ECC_BYTES, NUM_ECC_BYTES);
    4a80:	6823      	ldr	r3, [r4, #0]
    4a82:	f1a2 0120 	sub.w	r1, r2, #32
    4a86:	4419      	add	r1, r3
    4a88:	2220      	movs	r2, #32
    4a8a:	4630      	mov	r0, r6
        memcpy(i + NUM_ECC_BYTES - len, *cp, len);
    4a8c:	f000 fce4 	bl	5458 <memcpy>
    *cp += len;
    4a90:	6823      	ldr	r3, [r4, #0]
    4a92:	9a01      	ldr	r2, [sp, #4]
    4a94:	4413      	add	r3, r2
    4a96:	6023      	str	r3, [r4, #0]
}
    4a98:	4628      	mov	r0, r5
    4a9a:	b002      	add	sp, #8
    4a9c:	bd70      	pop	{r4, r5, r6, pc}
        memset(i, 0, NUM_ECC_BYTES - len);
    4a9e:	4601      	mov	r1, r0
    4aa0:	f1c2 0220 	rsb	r2, r2, #32
    4aa4:	4630      	mov	r0, r6
    4aa6:	f000 fce2 	bl	546e <memset>
        memcpy(i + NUM_ECC_BYTES - len, *cp, len);
    4aaa:	9a01      	ldr	r2, [sp, #4]
    4aac:	6821      	ldr	r1, [r4, #0]
    4aae:	f1c2 0020 	rsb	r0, r2, #32
    4ab2:	4430      	add	r0, r6
    4ab4:	e7ea      	b.n	4a8c <bootutil_read_bigint+0x28>
        return -3;
    4ab6:	f06f 0502 	mvn.w	r5, #2
    4aba:	e7ed      	b.n	4a98 <bootutil_read_bigint+0x34>

00004abc <boot_fih_memequal>:
    return memcmp(s1, s2, n);
    4abc:	f000 bca3 	b.w	5406 <memcmp>

00004ac0 <boot_trailer_sz>:
    return BOOT_STATUS_MAX_ENTRIES * boot_status_entry_sz(min_write_sz);
    4ac0:	f44f 7340 	mov.w	r3, #768	; 0x300
    4ac4:	4358      	muls	r0, r3
}
    4ac6:	3030      	adds	r0, #48	; 0x30
    4ac8:	4770      	bx	lr

00004aca <boot_status_entries>:
    if (flash_area_get_id(fap) == FLASH_AREA_IMAGE_PRIMARY(image_index) ||
    4aca:	780b      	ldrb	r3, [r1, #0]
    4acc:	f003 03fd 	and.w	r3, r3, #253	; 0xfd
        return BOOT_STATUS_STATE_COUNT * BOOT_STATUS_MAX_ENTRIES;
    4ad0:	2b01      	cmp	r3, #1
}
    4ad2:	bf14      	ite	ne
    4ad4:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
    4ad8:	f44f 7040 	moveq.w	r0, #768	; 0x300
    4adc:	4770      	bx	lr

00004ade <boot_status_off>:
{
    4ade:	b510      	push	{r4, lr}
    4ae0:	4604      	mov	r4, r0
    elem_sz = flash_area_align(fap);
    4ae2:	f000 fc41 	bl	5368 <flash_area_align>
    return flash_area_get_size(fap) - off_from_end;
    4ae6:	68a3      	ldr	r3, [r4, #8]
}
    4ae8:	f44f 7240 	mov.w	r2, #768	; 0x300
    return flash_area_get_size(fap) - off_from_end;
    4aec:	3b30      	subs	r3, #48	; 0x30
}
    4aee:	fb02 3010 	mls	r0, r2, r0, r3
    4af2:	bd10      	pop	{r4, pc}

00004af4 <boot_write_copy_done>:
    return ALIGN_DOWN(boot_magic_off(fap) - BOOT_MAX_ALIGN, BOOT_MAX_ALIGN);
    4af4:	6881      	ldr	r1, [r0, #8]
    4af6:	3918      	subs	r1, #24
    4af8:	f021 0107 	bic.w	r1, r1, #7

    off = boot_copy_done_off(fap);
    BOOT_LOG_DBG("writing copy_done; fa_id=%d off=0x%lx (0x%lx)",
                 flash_area_get_id(fap), (unsigned long)off,
                 (unsigned long)(flash_area_get_off(fap) + off));
    return boot_write_trailer_flag(fap, off, BOOT_FLAG_SET);
    4afc:	2201      	movs	r2, #1
    4afe:	3908      	subs	r1, #8
    4b00:	f000 bf89 	b.w	5a16 <boot_write_trailer_flag>

00004b04 <boot_write_swap_size>:
}

int
boot_write_swap_size(const struct flash_area *fap, uint32_t swap_size)
{
    4b04:	b513      	push	{r0, r1, r4, lr}
    4b06:	4604      	mov	r4, r0
    4b08:	9101      	str	r1, [sp, #4]
    return boot_swap_info_off(fap) - BOOT_MAX_ALIGN;
    4b0a:	f000 ff21 	bl	5950 <boot_swap_info_off>

    off = boot_swap_size_off(fap);
    BOOT_LOG_DBG("writing swap_size; fa_id=%d off=0x%lx (0x%lx)",
                 flash_area_get_id(fap), (unsigned long)off,
                 (unsigned long)flash_area_get_off(fap) + off);
    return boot_write_trailer(fap, off, (const uint8_t *) &swap_size, 4);
    4b0e:	2304      	movs	r3, #4
    4b10:	f1a0 0108 	sub.w	r1, r0, #8
    4b14:	eb0d 0203 	add.w	r2, sp, r3
    4b18:	4620      	mov	r0, r4
    4b1a:	f000 ff50 	bl	59be <boot_write_trailer>
}
    4b1e:	b002      	add	sp, #8
    4b20:	bd10      	pop	{r4, pc}

00004b22 <boot_read_image_headers>:
{
    4b22:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4b24:	4613      	mov	r3, r2
            rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
    4b26:	9201      	str	r2, [sp, #4]
{
    4b28:	460e      	mov	r6, r1
            rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
    4b2a:	4602      	mov	r2, r0
    4b2c:	2100      	movs	r1, #0
{
    4b2e:	4605      	mov	r5, r0
            rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
    4b30:	f7fb ff0c 	bl	94c <boot_read_image_header>
        if (rc != 0) {
    4b34:	4604      	mov	r4, r0
    4b36:	b950      	cbnz	r0, 4b4e <boot_read_image_headers+0x2c>
            rc = boot_read_image_header(state, i, boot_img_hdr(state, i), bs);
    4b38:	9b01      	ldr	r3, [sp, #4]
    4b3a:	f105 022c 	add.w	r2, r5, #44	; 0x2c
    4b3e:	2101      	movs	r1, #1
    4b40:	4628      	mov	r0, r5
    4b42:	f7fb ff03 	bl	94c <boot_read_image_header>
        if (rc != 0) {
    4b46:	b110      	cbz	r0, 4b4e <boot_read_image_headers+0x2c>
            if (i > 0 && !require_all) {
    4b48:	2e00      	cmp	r6, #0
    4b4a:	bf18      	it	ne
    4b4c:	4604      	movne	r4, r0
}
    4b4e:	4620      	mov	r0, r4
    4b50:	b002      	add	sp, #8
    4b52:	bd70      	pop	{r4, r5, r6, pc}

00004b54 <boot_read_image_size.isra.0>:
boot_read_image_size(struct boot_loader_state *state, int slot, uint32_t *size)
    4b54:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4b56:	4605      	mov	r5, r0
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
    4b58:	2000      	movs	r0, #0
boot_read_image_size(struct boot_loader_state *state, int slot, uint32_t *size)
    4b5a:	460c      	mov	r4, r1
    4b5c:	4616      	mov	r6, r2
    area_id = flash_area_id_from_multi_image_slot(BOOT_CURR_IMG(state), slot);
    4b5e:	f7ff fedd 	bl	491c <flash_area_id_from_multi_image_slot>
    rc = flash_area_open(area_id, &fap);
    4b62:	4669      	mov	r1, sp
    4b64:	b2c0      	uxtb	r0, r0
    4b66:	f7fc f9b1 	bl	ecc <flash_area_open>
    if (rc != 0) {
    4b6a:	bb30      	cbnz	r0, 4bba <boot_read_image_size.isra.0+0x66>
    off = BOOT_TLV_OFF(boot_img_hdr(state, slot));
    4b6c:	212c      	movs	r1, #44	; 0x2c
    4b6e:	fb01 5404 	mla	r4, r1, r4, r5
    if (flash_area_read(fap, off, &info, sizeof(info))) {
    4b72:	9800      	ldr	r0, [sp, #0]
    off = BOOT_TLV_OFF(boot_img_hdr(state, slot));
    4b74:	8921      	ldrh	r1, [r4, #8]
    4b76:	68e3      	ldr	r3, [r4, #12]
    4b78:	18cd      	adds	r5, r1, r3
    if (flash_area_read(fap, off, &info, sizeof(info))) {
    4b7a:	2304      	movs	r3, #4
    4b7c:	eb0d 0203 	add.w	r2, sp, r3
    4b80:	4629      	mov	r1, r5
    4b82:	f000 fba2 	bl	52ca <flash_area_read>
    4b86:	b9c0      	cbnz	r0, 4bba <boot_read_image_size.isra.0+0x66>
    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
    4b88:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    protect_tlv_size = boot_img_hdr(state, slot)->ih_protect_tlv_size;
    4b8c:	8964      	ldrh	r4, [r4, #10]
    if (info.it_magic == IMAGE_TLV_PROT_INFO_MAGIC) {
    4b8e:	f646 1308 	movw	r3, #26888	; 0x6908
    4b92:	429a      	cmp	r2, r3
    4b94:	d116      	bne.n	4bc4 <boot_read_image_size.isra.0+0x70>
        if (protect_tlv_size != info.it_tlv_tot) {
    4b96:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    4b9a:	429c      	cmp	r4, r3
    4b9c:	d10d      	bne.n	4bba <boot_read_image_size.isra.0+0x66>
        if (flash_area_read(fap, off + info.it_tlv_tot, &info, sizeof(info))) {
    4b9e:	2304      	movs	r3, #4
    4ba0:	9800      	ldr	r0, [sp, #0]
    4ba2:	eb0d 0203 	add.w	r2, sp, r3
    4ba6:	1961      	adds	r1, r4, r5
    4ba8:	f000 fb8f 	bl	52ca <flash_area_read>
    4bac:	b928      	cbnz	r0, 4bba <boot_read_image_size.isra.0+0x66>
    if (info.it_magic != IMAGE_TLV_INFO_MAGIC) {
    4bae:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    4bb2:	f646 1307 	movw	r3, #26887	; 0x6907
    4bb6:	429a      	cmp	r2, r3
    4bb8:	d007      	beq.n	4bca <boot_read_image_size.isra.0+0x76>
    flash_area_close(fap);
    4bba:	9800      	ldr	r0, [sp, #0]
    4bbc:	f000 fb84 	bl	52c8 <flash_area_close>
}
    4bc0:	b002      	add	sp, #8
    4bc2:	bd70      	pop	{r4, r5, r6, pc}
    } else if (protect_tlv_size != 0) {
    4bc4:	2c00      	cmp	r4, #0
    4bc6:	d0f2      	beq.n	4bae <boot_read_image_size.isra.0+0x5a>
    4bc8:	e7f7      	b.n	4bba <boot_read_image_size.isra.0+0x66>
    *size = off + protect_tlv_size + info.it_tlv_tot;
    4bca:	f8bd 1006 	ldrh.w	r1, [sp, #6]
    4bce:	4421      	add	r1, r4
    4bd0:	4429      	add	r1, r5
    4bd2:	6031      	str	r1, [r6, #0]
    rc = 0;
    4bd4:	e7f1      	b.n	4bba <boot_read_image_size.isra.0+0x66>

00004bd6 <boot_read_sectors>:
{
    4bd6:	b537      	push	{r0, r1, r2, r4, r5, lr}
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
    4bd8:	6a42      	ldr	r2, [r0, #36]	; 0x24
{
    4bda:	4604      	mov	r4, r0
    uint32_t num_sectors = BOOT_MAX_IMG_SECTORS;
    4bdc:	f44f 7580 	mov.w	r5, #256	; 0x100
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
    4be0:	a901      	add	r1, sp, #4
    4be2:	2003      	movs	r0, #3
    uint32_t num_sectors = BOOT_MAX_IMG_SECTORS;
    4be4:	9501      	str	r5, [sp, #4]
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
    4be6:	f7fc f98f 	bl	f08 <flash_area_get_sectors>
    if (rc != 0) {
    4bea:	b958      	cbnz	r0, 4c04 <boot_read_sectors+0x2e>
    *out_num_sectors = num_sectors;
    4bec:	9b01      	ldr	r3, [sp, #4]
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
    4bee:	6d22      	ldr	r2, [r4, #80]	; 0x50
    *out_num_sectors = num_sectors;
    4bf0:	62a3      	str	r3, [r4, #40]	; 0x28
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
    4bf2:	a901      	add	r1, sp, #4
    4bf4:	2001      	movs	r0, #1
    uint32_t num_sectors = BOOT_MAX_IMG_SECTORS;
    4bf6:	9501      	str	r5, [sp, #4]
    rc = flash_area_get_sectors(flash_area, &num_sectors, out_sectors);
    4bf8:	f7fc f986 	bl	f08 <flash_area_get_sectors>
    if (rc != 0) {
    4bfc:	4605      	mov	r5, r0
    4bfe:	b128      	cbz	r0, 4c0c <boot_read_sectors+0x36>
        return BOOT_EFLASH_SEC;
    4c00:	2509      	movs	r5, #9
    4c02:	e000      	b.n	4c06 <boot_read_sectors+0x30>
        return BOOT_EFLASH;
    4c04:	2501      	movs	r5, #1
}
    4c06:	4628      	mov	r0, r5
    4c08:	b003      	add	sp, #12
    4c0a:	bd30      	pop	{r4, r5, pc}
    *out_num_sectors = num_sectors;
    4c0c:	9b01      	ldr	r3, [sp, #4]
    elem_sz = flash_area_align(BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT));
    4c0e:	6a20      	ldr	r0, [r4, #32]
    *out_num_sectors = num_sectors;
    4c10:	6563      	str	r3, [r4, #84]	; 0x54
    elem_sz = flash_area_align(BOOT_IMG_AREA(state, BOOT_PRIMARY_SLOT));
    4c12:	f000 fba9 	bl	5368 <flash_area_align>
    BOOT_WRITE_SZ(state) = boot_write_sz(state);
    4c16:	65e0      	str	r0, [r4, #92]	; 0x5c
    return 0;
    4c18:	e7f5      	b.n	4c06 <boot_read_sectors+0x30>

00004c1a <boot_status_reset>:
    bs->idx = BOOT_STATUS_IDX_0;
    4c1a:	2301      	movs	r3, #1
    4c1c:	6003      	str	r3, [r0, #0]
    bs->state = BOOT_STATUS_STATE_0;
    4c1e:	f103 2301 	add.w	r3, r3, #16777472	; 0x1000100
    4c22:	6043      	str	r3, [r0, #4]
    bs->swap_size = 0;
    4c24:	2300      	movs	r3, #0
    bs->source = 0;
    4c26:	e9c0 3302 	strd	r3, r3, [r0, #8]
}
    4c2a:	4770      	bx	lr

00004c2c <boot_status_is_reset>:
            bs->idx == BOOT_STATUS_IDX_0 &&
    4c2c:	7943      	ldrb	r3, [r0, #5]
    4c2e:	2b01      	cmp	r3, #1
    4c30:	d107      	bne.n	4c42 <boot_status_is_reset+0x16>
    return (bs->op == BOOT_STATUS_OP_MOVE &&
    4c32:	6803      	ldr	r3, [r0, #0]
    4c34:	2b01      	cmp	r3, #1
    4c36:	d104      	bne.n	4c42 <boot_status_is_reset+0x16>
            bs->idx == BOOT_STATUS_IDX_0 &&
    4c38:	7900      	ldrb	r0, [r0, #4]
    4c3a:	1e43      	subs	r3, r0, #1
    4c3c:	4258      	negs	r0, r3
    4c3e:	4158      	adcs	r0, r3
    4c40:	4770      	bx	lr
    4c42:	2000      	movs	r0, #0
}
    4c44:	4770      	bx	lr

00004c46 <boot_write_status>:
{
    4c46:	b570      	push	{r4, r5, r6, lr}
    4c48:	b086      	sub	sp, #24
    4c4a:	4606      	mov	r6, r0
    4c4c:	460d      	mov	r5, r1
    rc = flash_area_open(area_id, &fap);
    4c4e:	2003      	movs	r0, #3
    4c50:	a903      	add	r1, sp, #12
    4c52:	f7fc f93b 	bl	ecc <flash_area_open>
    if (rc != 0) {
    4c56:	bb30      	cbnz	r0, 4ca6 <boot_write_status+0x60>
    off = boot_status_off(fap) +
    4c58:	9803      	ldr	r0, [sp, #12]
    4c5a:	f7ff ff40 	bl	4ade <boot_status_off>
          boot_status_internal_off(bs, BOOT_WRITE_SZ(state));
    4c5e:	6df1      	ldr	r1, [r6, #92]	; 0x5c
    off = boot_status_off(fap) +
    4c60:	4604      	mov	r4, r0
          boot_status_internal_off(bs, BOOT_WRITE_SZ(state));
    4c62:	4628      	mov	r0, r5
    4c64:	f000 f933 	bl	4ece <boot_status_internal_off>
    off = boot_status_off(fap) +
    4c68:	4404      	add	r4, r0
    align = flash_area_align(fap);
    4c6a:	9803      	ldr	r0, [sp, #12]
    4c6c:	f000 fb7c 	bl	5368 <flash_area_align>
    4c70:	9001      	str	r0, [sp, #4]
    erased_val = flash_area_erased_val(fap);
    4c72:	9803      	ldr	r0, [sp, #12]
    4c74:	f000 fb81 	bl	537a <flash_area_erased_val>
    memset(buf, erased_val, BOOT_MAX_ALIGN);
    4c78:	2208      	movs	r2, #8
    erased_val = flash_area_erased_val(fap);
    4c7a:	4601      	mov	r1, r0
    memset(buf, erased_val, BOOT_MAX_ALIGN);
    4c7c:	a804      	add	r0, sp, #16
    4c7e:	f000 fbf6 	bl	546e <memset>
    buf[0] = bs->state;
    4c82:	792a      	ldrb	r2, [r5, #4]
    4c84:	f88d 2010 	strb.w	r2, [sp, #16]
    rc = flash_area_write(fap, off, buf, align);
    4c88:	4621      	mov	r1, r4
    4c8a:	9b01      	ldr	r3, [sp, #4]
    4c8c:	9803      	ldr	r0, [sp, #12]
    4c8e:	aa04      	add	r2, sp, #16
    4c90:	f000 fb37 	bl	5302 <flash_area_write>
    if (rc != 0) {
    4c94:	1e04      	subs	r4, r0, #0
    flash_area_close(fap);
    4c96:	9803      	ldr	r0, [sp, #12]
    if (rc != 0) {
    4c98:	bf18      	it	ne
    4c9a:	2401      	movne	r4, #1
    flash_area_close(fap);
    4c9c:	f000 fb14 	bl	52c8 <flash_area_close>
}
    4ca0:	4620      	mov	r0, r4
    4ca2:	b006      	add	sp, #24
    4ca4:	bd70      	pop	{r4, r5, r6, pc}
        return BOOT_EFLASH;
    4ca6:	2401      	movs	r4, #1
    4ca8:	e7fa      	b.n	4ca0 <boot_write_status+0x5a>

00004caa <boot_erase_region>:
    return flash_area_erase(fap, off, sz);
    4caa:	f000 bb46 	b.w	533a <flash_area_erase>

00004cae <swap_erase_trailer_sectors>:

#if defined(MCUBOOT_SWAP_USING_SCRATCH) || defined(MCUBOOT_SWAP_USING_MOVE)
int
swap_erase_trailer_sectors(const struct boot_loader_state *state,
                           const struct flash_area *fap)
{
    4cae:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    4cb2:	460e      	mov	r6, r1
    int rc;

    BOOT_LOG_DBG("erasing trailer; fa_id=%d", flash_area_get_id(fap));

    image_index = BOOT_CURR_IMG(state);
    fa_id_primary = flash_area_id_from_multi_image_slot(image_index,
    4cb4:	2100      	movs	r1, #0
{
    4cb6:	4607      	mov	r7, r0
    fa_id_primary = flash_area_id_from_multi_image_slot(image_index,
    4cb8:	4608      	mov	r0, r1
    4cba:	f7ff fe2f 	bl	491c <flash_area_id_from_multi_image_slot>
            BOOT_PRIMARY_SLOT);
    fa_id_secondary = flash_area_id_from_multi_image_slot(image_index,
    4cbe:	2101      	movs	r1, #1
    fa_id_primary = flash_area_id_from_multi_image_slot(image_index,
    4cc0:	4604      	mov	r4, r0
    fa_id_secondary = flash_area_id_from_multi_image_slot(image_index,
    4cc2:	2000      	movs	r0, #0
    4cc4:	f7ff fe2a 	bl	491c <flash_area_id_from_multi_image_slot>
            BOOT_SECONDARY_SLOT);

    if (flash_area_get_id(fap) == fa_id_primary) {
    4cc8:	7833      	ldrb	r3, [r6, #0]
    4cca:	42a3      	cmp	r3, r4
    4ccc:	d020      	beq.n	4d10 <swap_erase_trailer_sectors+0x62>
        slot = BOOT_PRIMARY_SLOT;
    } else if (flash_area_get_id(fap) == fa_id_secondary) {
    4cce:	4283      	cmp	r3, r0
    4cd0:	d120      	bne.n	4d14 <swap_erase_trailer_sectors+0x66>
        slot = BOOT_SECONDARY_SLOT;
    4cd2:	2501      	movs	r5, #1
    return BOOT_IMG(state, slot).num_sectors;
    4cd4:	232c      	movs	r3, #44	; 0x2c
    4cd6:	fb03 7505 	mla	r5, r3, r5, r7
        return BOOT_EFLASH;
    }

    /* delete starting from last sector and moving to beginning */
    sector = boot_img_num_sectors(state, slot) - 1;
    trailer_sz = boot_trailer_sz(BOOT_WRITE_SZ(state));
    4cda:	6df8      	ldr	r0, [r7, #92]	; 0x5c
    sector = boot_img_num_sectors(state, slot) - 1;
    4cdc:	6aac      	ldr	r4, [r5, #40]	; 0x28
    trailer_sz = boot_trailer_sz(BOOT_WRITE_SZ(state));
    4cde:	f7ff feef 	bl	4ac0 <boot_trailer_sz>
    sector = boot_img_num_sectors(state, slot) - 1;
    4ce2:	3c01      	subs	r4, #1
    trailer_sz = boot_trailer_sz(BOOT_WRITE_SZ(state));
    4ce4:	4680      	mov	r8, r0
    total_sz = 0;
    4ce6:	2700      	movs	r7, #0
    return flash_sector_get_size(&BOOT_IMG(state, slot).sectors[sector]);
    4ce8:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    4cea:	eb03 02c4 	add.w	r2, r3, r4, lsl #3
    return flash_sector_get_off(&BOOT_IMG(state, slot).sectors[sector]) -
    4cee:	f853 1034 	ldr.w	r1, [r3, r4, lsl #3]
	return fs->fs_size;
    4cf2:	f8d2 9004 	ldr.w	r9, [r2, #4]
    4cf6:	681b      	ldr	r3, [r3, #0]
    do {
        sz = boot_img_sector_size(state, slot, sector);
        off = boot_img_sector_off(state, slot, sector);
        rc = boot_erase_region(fap, off, sz);
    4cf8:	464a      	mov	r2, r9
    4cfa:	1ac9      	subs	r1, r1, r3
    4cfc:	4630      	mov	r0, r6
        assert(rc == 0);

        sector--;
        total_sz += sz;
    4cfe:	444f      	add	r7, r9
        rc = boot_erase_region(fap, off, sz);
    4d00:	f7ff ffd3 	bl	4caa <boot_erase_region>
    } while (total_sz < trailer_sz);
    4d04:	45b8      	cmp	r8, r7
        sector--;
    4d06:	f104 34ff 	add.w	r4, r4, #4294967295	; 0xffffffff
    } while (total_sz < trailer_sz);
    4d0a:	d8ed      	bhi.n	4ce8 <swap_erase_trailer_sectors+0x3a>

    return rc;
}
    4d0c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        slot = BOOT_PRIMARY_SLOT;
    4d10:	2500      	movs	r5, #0
    4d12:	e7df      	b.n	4cd4 <swap_erase_trailer_sectors+0x26>
        return BOOT_EFLASH;
    4d14:	2001      	movs	r0, #1
    4d16:	e7f9      	b.n	4d0c <swap_erase_trailer_sectors+0x5e>

00004d18 <swap_status_init>:

int
swap_status_init(const struct boot_loader_state *state,
                 const struct flash_area *fap,
                 const struct boot_status *bs)
{
    4d18:	b537      	push	{r0, r1, r2, r4, r5, lr}
    4d1a:	4615      	mov	r5, r2
    4d1c:	460c      	mov	r4, r1

    image_index = BOOT_CURR_IMG(state);

    BOOT_LOG_DBG("initializing status; fa_id=%d", flash_area_get_id(fap));

    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY(image_index),
    4d1e:	2001      	movs	r0, #1
    4d20:	4669      	mov	r1, sp
    4d22:	f000 fe8f 	bl	5a44 <boot_read_swap_state_by_id>
            &swap_state);
    assert(rc == 0);

    if (bs->swap_type != BOOT_SWAP_TYPE_NONE) {
    4d26:	79e9      	ldrb	r1, [r5, #7]
    4d28:	2901      	cmp	r1, #1
    4d2a:	d003      	beq.n	4d34 <swap_status_init+0x1c>
        rc = boot_write_swap_info(fap, bs->swap_type, image_index);
    4d2c:	2200      	movs	r2, #0
    4d2e:	4620      	mov	r0, r4
    4d30:	f000 fe9c 	bl	5a6c <boot_write_swap_info>
        assert(rc == 0);
    }

    if (swap_state.image_ok == BOOT_FLAG_SET) {
    4d34:	f89d 3003 	ldrb.w	r3, [sp, #3]
    4d38:	2b01      	cmp	r3, #1
    4d3a:	d102      	bne.n	4d42 <swap_status_init+0x2a>
        rc = boot_write_image_ok(fap);
    4d3c:	4620      	mov	r0, r4
    4d3e:	f000 fe74 	bl	5a2a <boot_write_image_ok>
        assert(rc == 0);
    }

    rc = boot_write_swap_size(fap, bs->swap_size);
    4d42:	68a9      	ldr	r1, [r5, #8]
    4d44:	4620      	mov	r0, r4
    4d46:	f7ff fedd 	bl	4b04 <boot_write_swap_size>

    rc = boot_write_enc_key(fap, 1, bs);
    assert(rc == 0);
#endif

    rc = boot_write_magic(fap);
    4d4a:	4620      	mov	r0, r4
    4d4c:	f7fd fb5a 	bl	2404 <boot_write_magic>
    assert(rc == 0);

    return 0;
}
    4d50:	2000      	movs	r0, #0
    4d52:	b003      	add	sp, #12
    4d54:	bd30      	pop	{r4, r5, pc}

00004d56 <swap_read_status>:

int
swap_read_status(struct boot_loader_state *state, struct boot_status *bs)
{
    4d56:	b573      	push	{r0, r1, r4, r5, r6, lr}
    4d58:	460d      	mov	r5, r1
    4d5a:	4606      	mov	r6, r0
    uint32_t off;
    uint8_t swap_info;
    int area_id;
    int rc;

    bs->source = swap_status_source(state);
    4d5c:	f000 f8f7 	bl	4f4e <swap_status_source>
    4d60:	4604      	mov	r4, r0
    4d62:	60e8      	str	r0, [r5, #12]
    switch (bs->source) {
    4d64:	b358      	cbz	r0, 4dbe <swap_read_status+0x68>
    4d66:	2802      	cmp	r0, #2
    4d68:	d12e      	bne.n	4dc8 <swap_read_status+0x72>
    default:
        assert(0);
        return BOOT_EBADARGS;
    }

    rc = flash_area_open(area_id, &fap);
    4d6a:	a901      	add	r1, sp, #4
    4d6c:	2003      	movs	r0, #3
    4d6e:	f7fc f8ad 	bl	ecc <flash_area_open>
    if (rc != 0) {
    4d72:	bb58      	cbnz	r0, 4dcc <swap_read_status+0x76>
        return BOOT_EFLASH;
    }

    rc = swap_read_status_bytes(fap, state, bs);
    4d74:	9801      	ldr	r0, [sp, #4]
    4d76:	462a      	mov	r2, r5
    4d78:	4631      	mov	r1, r6
    4d7a:	f000 f859 	bl	4e30 <swap_read_status_bytes>
    if (rc == 0) {
    4d7e:	4604      	mov	r4, r0
    4d80:	b9d0      	cbnz	r0, 4db8 <swap_read_status+0x62>
        off = boot_swap_info_off(fap);
    4d82:	9801      	ldr	r0, [sp, #4]
    4d84:	f000 fde4 	bl	5950 <boot_swap_info_off>
        rc = flash_area_read(fap, off, &swap_info, sizeof swap_info);
    4d88:	2301      	movs	r3, #1
        off = boot_swap_info_off(fap);
    4d8a:	4601      	mov	r1, r0
        rc = flash_area_read(fap, off, &swap_info, sizeof swap_info);
    4d8c:	f10d 0203 	add.w	r2, sp, #3
    4d90:	9801      	ldr	r0, [sp, #4]
    4d92:	f000 fa9a 	bl	52ca <flash_area_read>
        if (rc != 0) {
    4d96:	4604      	mov	r4, r0
    4d98:	b9a0      	cbnz	r0, 4dc4 <swap_read_status+0x6e>
            rc = BOOT_EFLASH;
            goto done;
        }

        if (bootutil_buffer_is_erased(fap, &swap_info, sizeof swap_info)) {
    4d9a:	9801      	ldr	r0, [sp, #4]
    4d9c:	2201      	movs	r2, #1
    4d9e:	f10d 0103 	add.w	r1, sp, #3
    4da2:	f000 fde9 	bl	5978 <bootutil_buffer_is_erased>
    4da6:	b110      	cbz	r0, 4dae <swap_read_status+0x58>
            BOOT_SET_SWAP_INFO(swap_info, 0, BOOT_SWAP_TYPE_NONE);
    4da8:	2301      	movs	r3, #1
    4daa:	f88d 3003 	strb.w	r3, [sp, #3]
            rc = 0;
        }

        /* Extract the swap type info */
        bs->swap_type = BOOT_GET_SWAP_TYPE(swap_info);
    4dae:	f89d 3003 	ldrb.w	r3, [sp, #3]
    4db2:	f003 030f 	and.w	r3, r3, #15
    4db6:	71eb      	strb	r3, [r5, #7]
    }

done:
    flash_area_close(fap);
    4db8:	9801      	ldr	r0, [sp, #4]
    4dba:	f000 fa85 	bl	52c8 <flash_area_close>

    return rc;
}
    4dbe:	4620      	mov	r0, r4
    4dc0:	b002      	add	sp, #8
    4dc2:	bd70      	pop	{r4, r5, r6, pc}
            rc = BOOT_EFLASH;
    4dc4:	2401      	movs	r4, #1
    4dc6:	e7f7      	b.n	4db8 <swap_read_status+0x62>
    switch (bs->source) {
    4dc8:	2407      	movs	r4, #7
    4dca:	e7f8      	b.n	4dbe <swap_read_status+0x68>
        return BOOT_EFLASH;
    4dcc:	2401      	movs	r4, #1
    4dce:	e7f6      	b.n	4dbe <swap_read_status+0x68>

00004dd0 <swap_set_copy_done>:

int
swap_set_copy_done(uint8_t image_index)
{
    4dd0:	b513      	push	{r0, r1, r4, lr}
    const struct flash_area *fap;
    int rc;

    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index),
    4dd2:	2003      	movs	r0, #3
    4dd4:	a901      	add	r1, sp, #4
    4dd6:	f7fc f879 	bl	ecc <flash_area_open>
            &fap);
    if (rc != 0) {
    4dda:	b948      	cbnz	r0, 4df0 <swap_set_copy_done+0x20>
        return BOOT_EFLASH;
    }

    rc = boot_write_copy_done(fap);
    4ddc:	9801      	ldr	r0, [sp, #4]
    4dde:	f7ff fe89 	bl	4af4 <boot_write_copy_done>
    4de2:	4604      	mov	r4, r0
    flash_area_close(fap);
    4de4:	9801      	ldr	r0, [sp, #4]
    4de6:	f000 fa6f 	bl	52c8 <flash_area_close>
    return rc;
}
    4dea:	4620      	mov	r0, r4
    4dec:	b002      	add	sp, #8
    4dee:	bd10      	pop	{r4, pc}
        return BOOT_EFLASH;
    4df0:	2401      	movs	r4, #1
    4df2:	e7fa      	b.n	4dea <swap_set_copy_done+0x1a>

00004df4 <swap_set_image_ok>:

int
swap_set_image_ok(uint8_t image_index)
{
    4df4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    const struct flash_area *fap;
    struct boot_swap_state state;
    int rc;

    rc = flash_area_open(FLASH_AREA_IMAGE_PRIMARY(image_index),
    4df6:	2003      	movs	r0, #3
    4df8:	a901      	add	r1, sp, #4
    4dfa:	f7fc f867 	bl	ecc <flash_area_open>
            &fap);
    if (rc != 0) {
    4dfe:	b9a8      	cbnz	r0, 4e2c <swap_set_image_ok+0x38>
        return BOOT_EFLASH;
    }

    rc = boot_read_swap_state(fap, &state);
    4e00:	9801      	ldr	r0, [sp, #4]
    4e02:	a902      	add	r1, sp, #8
    4e04:	f7fd fb1e 	bl	2444 <boot_read_swap_state>
    if (rc != 0) {
    4e08:	4604      	mov	r4, r0
    4e0a:	b968      	cbnz	r0, 4e28 <swap_set_image_ok+0x34>
        rc = BOOT_EFLASH;
        goto out;
    }

    if (state.image_ok == BOOT_FLAG_UNSET) {
    4e0c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    4e10:	2b03      	cmp	r3, #3
    4e12:	d103      	bne.n	4e1c <swap_set_image_ok+0x28>
        rc = boot_write_image_ok(fap);
    4e14:	9801      	ldr	r0, [sp, #4]
    4e16:	f000 fe08 	bl	5a2a <boot_write_image_ok>
    4e1a:	4604      	mov	r4, r0
    }

out:
    flash_area_close(fap);
    4e1c:	9801      	ldr	r0, [sp, #4]
    4e1e:	f000 fa53 	bl	52c8 <flash_area_close>
    return rc;
}
    4e22:	4620      	mov	r0, r4
    4e24:	b004      	add	sp, #16
    4e26:	bd10      	pop	{r4, pc}
        rc = BOOT_EFLASH;
    4e28:	2401      	movs	r4, #1
    4e2a:	e7f7      	b.n	4e1c <swap_set_image_ok+0x28>
        return BOOT_EFLASH;
    4e2c:	2401      	movs	r4, #1
    4e2e:	e7f8      	b.n	4e22 <swap_set_image_ok+0x2e>

00004e30 <swap_read_status_bytes>:
{
    4e30:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
    4e34:	4607      	mov	r7, r0
    4e36:	460c      	mov	r4, r1
    max_entries = boot_status_entries(BOOT_CURR_IMG(state), fap);
    4e38:	4601      	mov	r1, r0
    4e3a:	2000      	movs	r0, #0
{
    4e3c:	4616      	mov	r6, r2
    max_entries = boot_status_entries(BOOT_CURR_IMG(state), fap);
    4e3e:	f7ff fe44 	bl	4aca <boot_status_entries>
    if (max_entries < 0) {
    4e42:	1e05      	subs	r5, r0, #0
    4e44:	db3f      	blt.n	4ec6 <swap_read_status_bytes+0x96>
    off = boot_status_off(fap);
    4e46:	4638      	mov	r0, r7
    write_sz = BOOT_WRITE_SZ(state);
    4e48:	6de4      	ldr	r4, [r4, #92]	; 0x5c
    off = boot_status_off(fap);
    4e4a:	f7ff fe48 	bl	4ade <boot_status_off>
    for (i = max_entries; i > 0; i--) {
    4e4e:	fa5f f984 	uxtb.w	r9, r4
    4e52:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff
    4e56:	fb09 0808 	mla	r8, r9, r8, r0
    found_idx = -1;
    4e5a:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
    for (i = max_entries; i > 0; i--) {
    4e5e:	b965      	cbnz	r5, 4e7a <swap_read_status_bytes+0x4a>
    if (found_idx == -1) {
    4e60:	1c63      	adds	r3, r4, #1
    4e62:	d006      	beq.n	4e72 <swap_read_status_bytes+0x42>
    } else if (found_idx < move_entries) {
    4e64:	2cff      	cmp	r4, #255	; 0xff
    4e66:	dc22      	bgt.n	4eae <swap_read_status_bytes+0x7e>
        bs->idx = (found_idx  / BOOT_STATUS_MOVE_STATE_COUNT) + BOOT_STATUS_IDX_0;
    4e68:	3401      	adds	r4, #1
        bs->state = (found_idx % BOOT_STATUS_MOVE_STATE_COUNT) + BOOT_STATUS_STATE_0;;
    4e6a:	f240 1301 	movw	r3, #257	; 0x101
        bs->idx = (found_idx  / BOOT_STATUS_MOVE_STATE_COUNT) + BOOT_STATUS_IDX_0;
    4e6e:	6034      	str	r4, [r6, #0]
        bs->state = (found_idx % BOOT_STATUS_MOVE_STATE_COUNT) + BOOT_STATUS_STATE_0;;
    4e70:	80b3      	strh	r3, [r6, #4]
}
    4e72:	4628      	mov	r0, r5
    4e74:	b002      	add	sp, #8
    4e76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        rc = flash_area_read(fap, off + (i - 1) * write_sz, &status, 1);
    4e7a:	2301      	movs	r3, #1
    4e7c:	f10d 0207 	add.w	r2, sp, #7
    4e80:	4641      	mov	r1, r8
    4e82:	4638      	mov	r0, r7
    4e84:	f000 fa21 	bl	52ca <flash_area_read>
        if (rc < 0) {
    4e88:	2800      	cmp	r0, #0
        rc = flash_area_read(fap, off + (i - 1) * write_sz, &status, 1);
    4e8a:	f105 3aff 	add.w	sl, r5, #4294967295	; 0xffffffff
        if (rc < 0) {
    4e8e:	db1c      	blt.n	4eca <swap_read_status_bytes+0x9a>
        if (bootutil_buffer_is_erased(fap, &status, 1)) {
    4e90:	2201      	movs	r2, #1
    4e92:	f10d 0107 	add.w	r1, sp, #7
    4e96:	4638      	mov	r0, r7
    4e98:	f000 fd6e 	bl	5978 <bootutil_buffer_is_erased>
    4e9c:	b918      	cbnz	r0, 4ea6 <swap_read_status_bytes+0x76>
            if (found_idx == -1) {
    4e9e:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
    4ea2:	bf08      	it	eq
    4ea4:	462c      	moveq	r4, r5
    4ea6:	eba8 0809 	sub.w	r8, r8, r9
    4eaa:	4655      	mov	r5, sl
    4eac:	e7d7      	b.n	4e5e <swap_read_status_bytes+0x2e>
        bs->op = BOOT_STATUS_OP_SWAP;
    4eae:	2302      	movs	r3, #2
        bs->idx = ((found_idx - move_entries) / BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_IDX_0;
    4eb0:	f5a4 7480 	sub.w	r4, r4, #256	; 0x100
        bs->op = BOOT_STATUS_OP_SWAP;
    4eb4:	7173      	strb	r3, [r6, #5]
        bs->idx = ((found_idx - move_entries) / BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_IDX_0;
    4eb6:	1063      	asrs	r3, r4, #1
        bs->state = ((found_idx - move_entries) % BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_STATE_0;
    4eb8:	f004 0401 	and.w	r4, r4, #1
        bs->idx = ((found_idx - move_entries) / BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_IDX_0;
    4ebc:	3301      	adds	r3, #1
        bs->state = ((found_idx - move_entries) % BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_STATE_0;
    4ebe:	3401      	adds	r4, #1
        bs->idx = ((found_idx - move_entries) / BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_IDX_0;
    4ec0:	6033      	str	r3, [r6, #0]
        bs->state = ((found_idx - move_entries) % BOOT_STATUS_SWAP_STATE_COUNT) + BOOT_STATUS_STATE_0;
    4ec2:	7134      	strb	r4, [r6, #4]
    4ec4:	e7d5      	b.n	4e72 <swap_read_status_bytes+0x42>
        return BOOT_EBADARGS;
    4ec6:	2507      	movs	r5, #7
    4ec8:	e7d3      	b.n	4e72 <swap_read_status_bytes+0x42>
            return BOOT_EFLASH;
    4eca:	2501      	movs	r5, #1
    4ecc:	e7d1      	b.n	4e72 <swap_read_status_bytes+0x42>

00004ece <boot_status_internal_off>:
{
    4ece:	b530      	push	{r4, r5, lr}
    idx_sz = elem_sz * ((bs->op == BOOT_STATUS_OP_MOVE) ?
    4ed0:	7943      	ldrb	r3, [r0, #5]
           (bs->state - BOOT_STATUS_STATE_0) * elem_sz;
    4ed2:	7902      	ldrb	r2, [r0, #4]
            BOOT_STATUS_MOVE_STATE_COUNT : BOOT_STATUS_SWAP_STATE_COUNT);
    4ed4:	2b01      	cmp	r3, #1
    4ed6:	bf0c      	ite	eq
    4ed8:	2301      	moveq	r3, #1
    4eda:	2302      	movne	r3, #2
    idx_sz = elem_sz * ((bs->op == BOOT_STATUS_OP_MOVE) ?
    4edc:	fb01 f403 	mul.w	r4, r1, r3
           (bs->idx - BOOT_STATUS_IDX_0) * idx_sz +
    4ee0:	6803      	ldr	r3, [r0, #0]
    4ee2:	f103 33ff 	add.w	r3, r3, #4294967295	; 0xffffffff
           (bs->state - BOOT_STATUS_STATE_0) * elem_sz;
    4ee6:	f102 32ff 	add.w	r2, r2, #4294967295	; 0xffffffff
           (bs->idx - BOOT_STATUS_IDX_0) * idx_sz +
    4eea:	fb04 f303 	mul.w	r3, r4, r3
               0 : (BOOT_MAX_IMG_SECTORS * BOOT_STATUS_MOVE_STATE_COUNT * elem_sz)) +
    4eee:	bf14      	ite	ne
    4ef0:	020d      	lslne	r5, r1, #8
    4ef2:	2500      	moveq	r5, #0
           (bs->idx - BOOT_STATUS_IDX_0) * idx_sz +
    4ef4:	fb01 3102 	mla	r1, r1, r2, r3
}
    4ef8:	1948      	adds	r0, r1, r5
    4efa:	bd30      	pop	{r4, r5, pc}

00004efc <boot_slots_compatible>:
{
    4efc:	b530      	push	{r4, r5, lr}
    return BOOT_IMG(state, slot).num_sectors;
    4efe:	6a82      	ldr	r2, [r0, #40]	; 0x28
    4f00:	6d44      	ldr	r4, [r0, #84]	; 0x54
    if ((num_sectors_pri != num_sectors_sec) &&
    4f02:	4294      	cmp	r4, r2
    4f04:	d002      	beq.n	4f0c <boot_slots_compatible+0x10>
            (num_sectors_pri != (num_sectors_sec + 1))) {
    4f06:	1c63      	adds	r3, r4, #1
    if ((num_sectors_pri != num_sectors_sec) &&
    4f08:	4293      	cmp	r3, r2
    4f0a:	d11c      	bne.n	4f46 <boot_slots_compatible+0x4a>
    if (num_sectors_pri > BOOT_MAX_IMG_SECTORS) {
    4f0c:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    4f10:	d819      	bhi.n	4f46 <boot_slots_compatible+0x4a>
    for (i = 0; i < num_sectors_sec; i++) {
    4f12:	2300      	movs	r3, #0
    size_t sector_sz_pri = 0;
    4f14:	4619      	mov	r1, r3
    for (i = 0; i < num_sectors_sec; i++) {
    4f16:	42a3      	cmp	r3, r4
    4f18:	d109      	bne.n	4f2e <boot_slots_compatible+0x32>
    if (num_sectors_pri > num_sectors_sec) {
    4f1a:	4293      	cmp	r3, r2
    4f1c:	d215      	bcs.n	4f4a <boot_slots_compatible+0x4e>
    4f1e:	6a42      	ldr	r2, [r0, #36]	; 0x24
    4f20:	eb02 03c3 	add.w	r3, r2, r3, lsl #3
        if (sector_sz_pri != boot_img_sector_size(state, BOOT_PRIMARY_SLOT, i)) {
    4f24:	6858      	ldr	r0, [r3, #4]
    4f26:	1a43      	subs	r3, r0, r1
    4f28:	4258      	negs	r0, r3
    4f2a:	4158      	adcs	r0, r3
}
    4f2c:	bd30      	pop	{r4, r5, pc}
    4f2e:	6a41      	ldr	r1, [r0, #36]	; 0x24
    4f30:	6d05      	ldr	r5, [r0, #80]	; 0x50
    4f32:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
    4f36:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
    4f3a:	6849      	ldr	r1, [r1, #4]
        if (sector_sz_pri != sector_sz_sec) {
    4f3c:	686d      	ldr	r5, [r5, #4]
    4f3e:	428d      	cmp	r5, r1
    4f40:	d101      	bne.n	4f46 <boot_slots_compatible+0x4a>
    for (i = 0; i < num_sectors_sec; i++) {
    4f42:	3301      	adds	r3, #1
    4f44:	e7e7      	b.n	4f16 <boot_slots_compatible+0x1a>
        return 0;
    4f46:	2000      	movs	r0, #0
    4f48:	e7f0      	b.n	4f2c <boot_slots_compatible+0x30>
    return 1;
    4f4a:	2001      	movs	r0, #1
    4f4c:	e7ee      	b.n	4f2c <boot_slots_compatible+0x30>

00004f4e <swap_status_source>:
{
    4f4e:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_PRIMARY(image_index),
    4f50:	2003      	movs	r0, #3
    4f52:	4669      	mov	r1, sp
    4f54:	f000 fd76 	bl	5a44 <boot_read_swap_state_by_id>
    rc = boot_read_swap_state_by_id(FLASH_AREA_IMAGE_SECONDARY(image_index),
    4f58:	a902      	add	r1, sp, #8
    4f5a:	2001      	movs	r0, #1
    4f5c:	f000 fd72 	bl	5a44 <boot_read_swap_state_by_id>
    if (state_primary_slot.magic == BOOT_MAGIC_GOOD &&
    4f60:	f89d 3000 	ldrb.w	r3, [sp]
    4f64:	2b01      	cmp	r3, #1
    4f66:	d10c      	bne.n	4f82 <swap_status_source+0x34>
    4f68:	f89d 2002 	ldrb.w	r2, [sp, #2]
    BOOT_LOG_SWAP_STATE("Secondary image", &state_secondary_slot);
    4f6c:	f89d 3008 	ldrb.w	r3, [sp, #8]
    if (state_primary_slot.magic == BOOT_MAGIC_GOOD &&
    4f70:	2a03      	cmp	r2, #3
    4f72:	d106      	bne.n	4f82 <swap_status_source+0x34>
        return source;
    4f74:	2b01      	cmp	r3, #1
    4f76:	bf0c      	ite	eq
    4f78:	2000      	moveq	r0, #0
    4f7a:	2002      	movne	r0, #2
}
    4f7c:	b005      	add	sp, #20
    4f7e:	f85d fb04 	ldr.w	pc, [sp], #4
    return BOOT_STATUS_SOURCE_NONE;
    4f82:	2000      	movs	r0, #0
    4f84:	e7fa      	b.n	4f7c <swap_status_source+0x2e>

00004f86 <mbedtls_asn1_get_len>:
 */
int mbedtls_asn1_get_len( unsigned char **p,
                  const unsigned char *end,
                  size_t *len )
{
    if( ( end - *p ) < 1 )
    4f86:	6803      	ldr	r3, [r0, #0]
{
    4f88:	b570      	push	{r4, r5, r6, lr}
    if( ( end - *p ) < 1 )
    4f8a:	1acd      	subs	r5, r1, r3
    4f8c:	2d00      	cmp	r5, #0
    4f8e:	dd0d      	ble.n	4fac <mbedtls_asn1_get_len+0x26>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( ( **p & 0x80 ) == 0 )
    4f90:	f993 6000 	ldrsb.w	r6, [r3]
    4f94:	781c      	ldrb	r4, [r3, #0]
    4f96:	2e00      	cmp	r6, #0
    4f98:	db0b      	blt.n	4fb2 <mbedtls_asn1_get_len+0x2c>
        *len = *(*p)++;
    4f9a:	1c5c      	adds	r4, r3, #1
    4f9c:	6004      	str	r4, [r0, #0]
    4f9e:	781b      	ldrb	r3, [r3, #0]
    4fa0:	6013      	str	r3, [r2, #0]
        default:
            return( MBEDTLS_ERR_ASN1_INVALID_LENGTH );
        }
    }

    if( *len > (size_t) ( end - *p ) )
    4fa2:	6803      	ldr	r3, [r0, #0]
    4fa4:	1ac9      	subs	r1, r1, r3
    4fa6:	6813      	ldr	r3, [r2, #0]
    4fa8:	428b      	cmp	r3, r1
    4faa:	d932      	bls.n	5012 <mbedtls_asn1_get_len+0x8c>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
    4fac:	f06f 005f 	mvn.w	r0, #95	; 0x5f

    return( 0 );
}
    4fb0:	bd70      	pop	{r4, r5, r6, pc}
        switch( **p & 0x7F )
    4fb2:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    4fb6:	3c01      	subs	r4, #1
    4fb8:	2c03      	cmp	r4, #3
    4fba:	d827      	bhi.n	500c <mbedtls_asn1_get_len+0x86>
    4fbc:	e8df f004 	tbb	[pc, r4]
    4fc0:	1e120902 	.word	0x1e120902
            if( ( end - *p ) < 2 )
    4fc4:	2d01      	cmp	r5, #1
    4fc6:	d0f1      	beq.n	4fac <mbedtls_asn1_get_len+0x26>
            *len = (*p)[1];
    4fc8:	785c      	ldrb	r4, [r3, #1]
    4fca:	6014      	str	r4, [r2, #0]
            (*p) += 2;
    4fcc:	3302      	adds	r3, #2
            (*p) += 5;
    4fce:	6003      	str	r3, [r0, #0]
            break;
    4fd0:	e7e7      	b.n	4fa2 <mbedtls_asn1_get_len+0x1c>
            if( ( end - *p ) < 3 )
    4fd2:	2d02      	cmp	r5, #2
    4fd4:	ddea      	ble.n	4fac <mbedtls_asn1_get_len+0x26>
            *len = ( (size_t)(*p)[1] << 8 ) | (*p)[2];
    4fd6:	f8b3 4001 	ldrh.w	r4, [r3, #1]
    4fda:	ba64      	rev16	r4, r4
    4fdc:	b2a4      	uxth	r4, r4
    4fde:	6014      	str	r4, [r2, #0]
            (*p) += 3;
    4fe0:	3303      	adds	r3, #3
    4fe2:	e7f4      	b.n	4fce <mbedtls_asn1_get_len+0x48>
            if( ( end - *p ) < 4 )
    4fe4:	2d03      	cmp	r5, #3
    4fe6:	dde1      	ble.n	4fac <mbedtls_asn1_get_len+0x26>
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
    4fe8:	789c      	ldrb	r4, [r3, #2]
            *len = ( (size_t)(*p)[1] << 16 ) |
    4fea:	785d      	ldrb	r5, [r3, #1]
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
    4fec:	0224      	lsls	r4, r4, #8
            *len = ( (size_t)(*p)[1] << 16 ) |
    4fee:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
                   ( (size_t)(*p)[2] << 8  ) | (*p)[3];
    4ff2:	78dd      	ldrb	r5, [r3, #3]
    4ff4:	432c      	orrs	r4, r5
            *len = ( (size_t)(*p)[1] << 16 ) |
    4ff6:	6014      	str	r4, [r2, #0]
            (*p) += 4;
    4ff8:	3304      	adds	r3, #4
    4ffa:	e7e8      	b.n	4fce <mbedtls_asn1_get_len+0x48>
            if( ( end - *p ) < 5 )
    4ffc:	2d04      	cmp	r5, #4
    4ffe:	ddd5      	ble.n	4fac <mbedtls_asn1_get_len+0x26>
            *len = ( (size_t)(*p)[1] << 24 ) | ( (size_t)(*p)[2] << 16 ) |
    5000:	f8d3 4001 	ldr.w	r4, [r3, #1]
    5004:	ba24      	rev	r4, r4
    5006:	6014      	str	r4, [r2, #0]
            (*p) += 5;
    5008:	3305      	adds	r3, #5
    500a:	e7e0      	b.n	4fce <mbedtls_asn1_get_len+0x48>
        switch( **p & 0x7F )
    500c:	f06f 0063 	mvn.w	r0, #99	; 0x63
    5010:	e7ce      	b.n	4fb0 <mbedtls_asn1_get_len+0x2a>
    return( 0 );
    5012:	2000      	movs	r0, #0
    5014:	e7cc      	b.n	4fb0 <mbedtls_asn1_get_len+0x2a>

00005016 <mbedtls_asn1_get_tag>:

int mbedtls_asn1_get_tag( unsigned char **p,
                  const unsigned char *end,
                  size_t *len, int tag )
{
    5016:	b470      	push	{r4, r5, r6}
    if( ( end - *p ) < 1 )
    5018:	6804      	ldr	r4, [r0, #0]
    501a:	1b0e      	subs	r6, r1, r4
    501c:	2e00      	cmp	r6, #0
    501e:	dd07      	ble.n	5030 <mbedtls_asn1_get_tag+0x1a>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    if( **p != tag )
    5020:	7826      	ldrb	r6, [r4, #0]
    5022:	429e      	cmp	r6, r3
    5024:	d108      	bne.n	5038 <mbedtls_asn1_get_tag+0x22>
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );

    (*p)++;
    5026:	3401      	adds	r4, #1
    5028:	6004      	str	r4, [r0, #0]

    return( mbedtls_asn1_get_len( p, end, len ) );
}
    502a:	bc70      	pop	{r4, r5, r6}
    return( mbedtls_asn1_get_len( p, end, len ) );
    502c:	f7ff bfab 	b.w	4f86 <mbedtls_asn1_get_len>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
    5030:	f06f 005f 	mvn.w	r0, #95	; 0x5f
}
    5034:	bc70      	pop	{r4, r5, r6}
    5036:	4770      	bx	lr
        return( MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
    5038:	f06f 0061 	mvn.w	r0, #97	; 0x61
    503c:	e7fa      	b.n	5034 <mbedtls_asn1_get_tag+0x1e>

0000503e <mbedtls_asn1_get_bitstring_null>:
/*
 * Get a bit string without unused bits
 */
int mbedtls_asn1_get_bitstring_null( unsigned char **p, const unsigned char *end,
                             size_t *len )
{
    503e:	b538      	push	{r3, r4, r5, lr}
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;

    if( ( ret = mbedtls_asn1_get_tag( p, end, len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
    5040:	2303      	movs	r3, #3
{
    5042:	4604      	mov	r4, r0
    if( ( ret = mbedtls_asn1_get_tag( p, end, len, MBEDTLS_ASN1_BIT_STRING ) ) != 0 )
    5044:	f7ff ffe7 	bl	5016 <mbedtls_asn1_get_tag>
    5048:	b918      	cbnz	r0, 5052 <mbedtls_asn1_get_bitstring_null+0x14>
        return( ret );

    if( *len == 0 )
    504a:	6813      	ldr	r3, [r2, #0]
    504c:	b913      	cbnz	r3, 5054 <mbedtls_asn1_get_bitstring_null+0x16>
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
    504e:	f06f 0067 	mvn.w	r0, #103	; 0x67
    if( **p != 0 )
        return( MBEDTLS_ERR_ASN1_INVALID_DATA );
    ++( *p );

    return( 0 );
}
    5052:	bd38      	pop	{r3, r4, r5, pc}
    --( *len );
    5054:	3b01      	subs	r3, #1
    5056:	6013      	str	r3, [r2, #0]
    if( **p != 0 )
    5058:	6823      	ldr	r3, [r4, #0]
    505a:	781a      	ldrb	r2, [r3, #0]
    505c:	2a00      	cmp	r2, #0
    505e:	d1f6      	bne.n	504e <mbedtls_asn1_get_bitstring_null+0x10>
    ++( *p );
    5060:	3301      	adds	r3, #1
    5062:	6023      	str	r3, [r4, #0]
    return( 0 );
    5064:	e7f5      	b.n	5052 <mbedtls_asn1_get_bitstring_null+0x14>

00005066 <mbedtls_asn1_get_alg>:
}

int mbedtls_asn1_get_alg( unsigned char **p,
                  const unsigned char *end,
                  mbedtls_asn1_buf *alg, mbedtls_asn1_buf *params )
{
    5066:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    506a:	4690      	mov	r8, r2
    506c:	461f      	mov	r7, r3
    int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;
    size_t len;

    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
    506e:	aa01      	add	r2, sp, #4
    5070:	2330      	movs	r3, #48	; 0x30
{
    5072:	4605      	mov	r5, r0
    5074:	4689      	mov	r9, r1
    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
    5076:	f7ff ffce 	bl	5016 <mbedtls_asn1_get_tag>
    507a:	4604      	mov	r4, r0
    507c:	b9f8      	cbnz	r0, 50be <mbedtls_asn1_get_alg+0x58>
            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        return( ret );

    if( ( end - *p ) < 1 )
    507e:	682e      	ldr	r6, [r5, #0]
    5080:	eba9 0906 	sub.w	r9, r9, r6
    5084:	f1b9 0f00 	cmp.w	r9, #0
    5088:	dd35      	ble.n	50f6 <mbedtls_asn1_get_alg+0x90>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );

    alg->tag = **p;
    end = *p + len;
    508a:	9901      	ldr	r1, [sp, #4]
    alg->tag = **p;
    508c:	7833      	ldrb	r3, [r6, #0]
    508e:	4642      	mov	r2, r8
    end = *p + len;
    5090:	440e      	add	r6, r1
    alg->tag = **p;
    5092:	f842 3b04 	str.w	r3, [r2], #4

    if( ( ret = mbedtls_asn1_get_tag( p, end, &alg->len, MBEDTLS_ASN1_OID ) ) != 0 )
    5096:	4631      	mov	r1, r6
    5098:	2306      	movs	r3, #6
    509a:	4628      	mov	r0, r5
    509c:	f7ff ffbb 	bl	5016 <mbedtls_asn1_get_tag>
    50a0:	4604      	mov	r4, r0
    50a2:	b960      	cbnz	r0, 50be <mbedtls_asn1_get_alg+0x58>
        return( ret );

    alg->p = *p;
    50a4:	682a      	ldr	r2, [r5, #0]
    *p += alg->len;
    50a6:	f8d8 1004 	ldr.w	r1, [r8, #4]
    alg->p = *p;
    50aa:	f8c8 2008 	str.w	r2, [r8, #8]
    *p += alg->len;
    50ae:	1853      	adds	r3, r2, r1

    if( *p == end )
    50b0:	42b3      	cmp	r3, r6
    *p += alg->len;
    50b2:	602b      	str	r3, [r5, #0]
    if( *p == end )
    50b4:	d107      	bne.n	50c6 <mbedtls_asn1_get_alg+0x60>
    {
        mbedtls_platform_zeroize( params, sizeof(mbedtls_asn1_buf) );
    50b6:	210c      	movs	r1, #12
    50b8:	4638      	mov	r0, r7
    50ba:	f7fe f8c9 	bl	3250 <mbedtls_platform_zeroize>

    if( *p != end )
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );

    return( 0 );
}
    50be:	4620      	mov	r0, r4
    50c0:	b003      	add	sp, #12
    50c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    params->tag = **p;
    50c6:	5c51      	ldrb	r1, [r2, r1]
    50c8:	463a      	mov	r2, r7
    (*p)++;
    50ca:	3301      	adds	r3, #1
    params->tag = **p;
    50cc:	f842 1b04 	str.w	r1, [r2], #4
    if( ( ret = mbedtls_asn1_get_len( p, end, &params->len ) ) != 0 )
    50d0:	4628      	mov	r0, r5
    (*p)++;
    50d2:	602b      	str	r3, [r5, #0]
    if( ( ret = mbedtls_asn1_get_len( p, end, &params->len ) ) != 0 )
    50d4:	4631      	mov	r1, r6
    50d6:	f7ff ff56 	bl	4f86 <mbedtls_asn1_get_len>
    50da:	4604      	mov	r4, r0
    50dc:	2800      	cmp	r0, #0
    50de:	d1ee      	bne.n	50be <mbedtls_asn1_get_alg+0x58>
    params->p = *p;
    50e0:	682b      	ldr	r3, [r5, #0]
    *p += params->len;
    50e2:	687a      	ldr	r2, [r7, #4]
    params->p = *p;
    50e4:	60bb      	str	r3, [r7, #8]
    *p += params->len;
    50e6:	4413      	add	r3, r2
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    50e8:	42b3      	cmp	r3, r6
    *p += params->len;
    50ea:	602b      	str	r3, [r5, #0]
        return( MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
    50ec:	bf0c      	ite	eq
    50ee:	4604      	moveq	r4, r0
    50f0:	f06f 0465 	mvnne.w	r4, #101	; 0x65
    50f4:	e7e3      	b.n	50be <mbedtls_asn1_get_alg+0x58>
        return( MBEDTLS_ERR_ASN1_OUT_OF_DATA );
    50f6:	f06f 045f 	mvn.w	r4, #95	; 0x5f
    50fa:	e7e0      	b.n	50be <mbedtls_asn1_get_alg+0x58>

000050fc <cc310_sha256_update>:
{
    50fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    if ((uint32_t) data < CONFIG_SRAM_BASE_ADDRESS) {
    50fe:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
{
    5102:	af00      	add	r7, sp, #0
    5104:	4605      	mov	r5, r0
    5106:	4614      	mov	r4, r2
    if ((uint32_t) data < CONFIG_SRAM_BASE_ADDRESS) {
    5108:	d210      	bcs.n	512c <cc310_sha256_update+0x30>
        uint8_t stack_buffer[data_len];
    510a:	1dd3      	adds	r3, r2, #7
    510c:	f023 0307 	bic.w	r3, r3, #7
    if ((uint32_t) data < CONFIG_SRAM_BASE_ADDRESS) {
    5110:	466e      	mov	r6, sp
        uint8_t stack_buffer[data_len];
    5112:	ebad 0d03 	sub.w	sp, sp, r3
        memcpy(stack_buffer, data, block_len);
    5116:	4668      	mov	r0, sp
    5118:	f000 f99e 	bl	5458 <memcpy>
        nrf_cc310_bl_hash_sha256_update(ctx, stack_buffer, block_len);
    511c:	4669      	mov	r1, sp
    511e:	4622      	mov	r2, r4
    5120:	4628      	mov	r0, r5
    5122:	f7fe fb4f 	bl	37c4 <nrf_cc310_bl_hash_sha256_update>
    5126:	46b5      	mov	sp, r6
};
    5128:	46bd      	mov	sp, r7
    512a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        nrf_cc310_bl_hash_sha256_update(ctx, data, data_len);
    512c:	f7fe fb4a 	bl	37c4 <nrf_cc310_bl_hash_sha256_update>
};
    5130:	e7fa      	b.n	5128 <cc310_sha256_update+0x2c>

00005132 <sys_notify_validate>:

int sys_notify_validate(struct sys_notify *notify)
{
	int rv = 0;

	if (notify == NULL) {
    5132:	b160      	cbz	r0, 514e <sys_notify_validate+0x1c>
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    5134:	6843      	ldr	r3, [r0, #4]
	return method & SYS_NOTIFY_METHOD_MASK;
    5136:	f003 0303 	and.w	r3, r3, #3
		return -EINVAL;
	}

	/* Validate configuration based on mode */
	switch (sys_notify_get_method(notify)) {
    513a:	2b01      	cmp	r3, #1
    513c:	d003      	beq.n	5146 <sys_notify_validate+0x14>
    513e:	2b03      	cmp	r3, #3
    5140:	d105      	bne.n	514e <sys_notify_validate+0x1c>
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		if (notify->method.callback == NULL) {
    5142:	6803      	ldr	r3, [r0, #0]
    5144:	b11b      	cbz	r3, 514e <sys_notify_validate+0x1c>
		break;
	}

	/* Clear the result here instead of in all callers. */
	if (rv == 0) {
		notify->result = 0;
    5146:	2300      	movs	r3, #0
    5148:	6083      	str	r3, [r0, #8]
    514a:	4618      	mov	r0, r3
    514c:	4770      	bx	lr
		return -EINVAL;
    514e:	f06f 0015 	mvn.w	r0, #21
	}

	return rv;
}
    5152:	4770      	bx	lr

00005154 <sys_notify_finalize>:
	uint32_t method = notify->flags >> SYS_NOTIFY_METHOD_POS;
    5154:	6843      	ldr	r3, [r0, #4]
	uint32_t method = sys_notify_get_method(notify);

	/* Store the result and capture secondary notification
	 * information.
	 */
	notify->result = res;
    5156:	6081      	str	r1, [r0, #8]
	return method & SYS_NOTIFY_METHOD_MASK;
    5158:	f003 0303 	and.w	r3, r3, #3
	switch (method) {
    515c:	2b03      	cmp	r3, #3
    515e:	f04f 0200 	mov.w	r2, #0
	case SYS_NOTIFY_METHOD_SPINWAIT:
		break;
	case SYS_NOTIFY_METHOD_CALLBACK:
		rv = notify->method.callback;
    5162:	bf0c      	ite	eq
    5164:	6803      	ldreq	r3, [r0, #0]
	sys_notify_generic_callback rv = NULL;
    5166:	4613      	movne	r3, r2
	/* Mark completion by clearing the flags field to the
	 * completed state, releasing any spin-waiters, then complete
	 * secondary notification.
	 */
	compiler_barrier();
	notify->flags = SYS_NOTIFY_METHOD_COMPLETED;
    5168:	6042      	str	r2, [r0, #4]
	if (IS_ENABLED(CONFIG_POLL) && (sig != NULL)) {
		k_poll_signal_raise(sig, res);
	}

	return rv;
}
    516a:	4618      	mov	r0, r3
    516c:	4770      	bx	lr

0000516e <process_recheck>:
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    516e:	8b03      	ldrh	r3, [r0, #24]
	if ((state == ONOFF_STATE_OFF)
    5170:	f013 0307 	ands.w	r3, r3, #7
    5174:	d105      	bne.n	5182 <process_recheck+0x14>
	    && !sys_slist_is_empty(&mgr->clients)) {
    5176:	6803      	ldr	r3, [r0, #0]
		evt = EVT_START;
    5178:	2b00      	cmp	r3, #0
    517a:	bf0c      	ite	eq
    517c:	2000      	moveq	r0, #0
    517e:	2003      	movne	r0, #3
    5180:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ON)
    5182:	2b02      	cmp	r3, #2
    5184:	d105      	bne.n	5192 <process_recheck+0x24>
		   && (mgr->refs == 0U)) {
    5186:	8b43      	ldrh	r3, [r0, #26]
		evt = EVT_STOP;
    5188:	2b00      	cmp	r3, #0
    518a:	bf14      	ite	ne
    518c:	2000      	movne	r0, #0
    518e:	2004      	moveq	r0, #4
    5190:	4770      	bx	lr
	} else if ((state == ONOFF_STATE_ERROR)
    5192:	2b01      	cmp	r3, #1
    5194:	d105      	bne.n	51a2 <process_recheck+0x34>
		   && !sys_slist_is_empty(&mgr->clients)) {
    5196:	6803      	ldr	r3, [r0, #0]
		evt = EVT_RESET;
    5198:	2b00      	cmp	r3, #0
    519a:	bf0c      	ite	eq
    519c:	2000      	moveq	r0, #0
    519e:	2005      	movne	r0, #5
    51a0:	4770      	bx	lr
	int evt = EVT_NOP;
    51a2:	2000      	movs	r0, #0
}
    51a4:	4770      	bx	lr

000051a6 <notify_one>:
{
    51a6:	b573      	push	{r0, r1, r4, r5, r6, lr}
    51a8:	460d      	mov	r5, r1
    51aa:	4606      	mov	r6, r0
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    51ac:	4619      	mov	r1, r3
    51ae:	1d28      	adds	r0, r5, #4
{
    51b0:	9201      	str	r2, [sp, #4]
		(onoff_client_callback)sys_notify_finalize(&cli->notify, res);
    51b2:	9300      	str	r3, [sp, #0]
    51b4:	f7ff ffce 	bl	5154 <sys_notify_finalize>
	if (cb) {
    51b8:	4604      	mov	r4, r0
    51ba:	b140      	cbz	r0, 51ce <notify_one+0x28>
		cb(mgr, cli, state, res);
    51bc:	e9dd 3200 	ldrd	r3, r2, [sp]
    51c0:	4629      	mov	r1, r5
    51c2:	4630      	mov	r0, r6
    51c4:	46a4      	mov	ip, r4
}
    51c6:	b002      	add	sp, #8
    51c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		cb(mgr, cli, state, res);
    51cc:	4760      	bx	ip
}
    51ce:	b002      	add	sp, #8
    51d0:	bd70      	pop	{r4, r5, r6, pc}

000051d2 <transition_complete>:
{
    51d2:	b410      	push	{r4}
    51d4:	f04f 0420 	mov.w	r4, #32
    51d8:	f3ef 8211 	mrs	r2, BASEPRI
    51dc:	f384 8812 	msr	BASEPRI_MAX, r4
    51e0:	f3bf 8f6f 	isb	sy
	mgr->last_res = res;
    51e4:	6141      	str	r1, [r0, #20]
}
    51e6:	f85d 4b04 	ldr.w	r4, [sp], #4
	process_event(mgr, EVT_COMPLETE, key);
    51ea:	2101      	movs	r1, #1
    51ec:	f7fb bd8a 	b.w	d04 <process_event>

000051f0 <validate_args>:
{
    51f0:	b510      	push	{r4, lr}
    51f2:	460c      	mov	r4, r1
	if ((mgr == NULL) || (cli == NULL)) {
    51f4:	b140      	cbz	r0, 5208 <validate_args+0x18>
    51f6:	b139      	cbz	r1, 5208 <validate_args+0x18>
	int rv = sys_notify_validate(&cli->notify);
    51f8:	1d08      	adds	r0, r1, #4
    51fa:	f7ff ff9a 	bl	5132 <sys_notify_validate>
	if ((rv == 0)
    51fe:	b928      	cbnz	r0, 520c <validate_args+0x1c>
	    && ((cli->notify.flags
    5200:	68a3      	ldr	r3, [r4, #8]
    5202:	f033 0303 	bics.w	r3, r3, #3
    5206:	d001      	beq.n	520c <validate_args+0x1c>
		rv = -EINVAL;
    5208:	f06f 0015 	mvn.w	r0, #21
}
    520c:	bd10      	pop	{r4, pc}

0000520e <onoff_manager_init>:
{
    520e:	b538      	push	{r3, r4, r5, lr}
    5210:	460c      	mov	r4, r1
	if ((mgr == NULL)
    5212:	4605      	mov	r5, r0
    5214:	b158      	cbz	r0, 522e <onoff_manager_init+0x20>
	    || (transitions == NULL)
    5216:	b151      	cbz	r1, 522e <onoff_manager_init+0x20>
	    || (transitions->start == NULL)
    5218:	680b      	ldr	r3, [r1, #0]
    521a:	b143      	cbz	r3, 522e <onoff_manager_init+0x20>
	    || (transitions->stop == NULL)) {
    521c:	684b      	ldr	r3, [r1, #4]
    521e:	b133      	cbz	r3, 522e <onoff_manager_init+0x20>
	*mgr = (struct onoff_manager)ONOFF_MANAGER_INITIALIZER(transitions);
    5220:	221c      	movs	r2, #28
    5222:	2100      	movs	r1, #0
    5224:	f000 f923 	bl	546e <memset>
    5228:	612c      	str	r4, [r5, #16]
	return 0;
    522a:	2000      	movs	r0, #0
}
    522c:	bd38      	pop	{r3, r4, r5, pc}
		return -EINVAL;
    522e:	f06f 0015 	mvn.w	r0, #21
    5232:	e7fb      	b.n	522c <onoff_manager_init+0x1e>

00005234 <onoff_request>:

int onoff_request(struct onoff_manager *mgr,
		  struct onoff_client *cli)
{
    5234:	b570      	push	{r4, r5, r6, lr}
    5236:	4604      	mov	r4, r0
    5238:	460e      	mov	r6, r1
	bool add_client = false;        /* add client to pending list */
	bool start = false;             /* trigger a start transition */
	bool notify = false;            /* do client notification */
	int rv = validate_args(mgr, cli);
    523a:	f7ff ffd9 	bl	51f0 <validate_args>

	if (rv < 0) {
    523e:	1e05      	subs	r5, r0, #0
    5240:	db31      	blt.n	52a6 <onoff_request+0x72>
    5242:	f04f 0320 	mov.w	r3, #32
    5246:	f3ef 8111 	mrs	r1, BASEPRI
    524a:	f383 8812 	msr	BASEPRI_MAX, r3
    524e:	f3bf 8f6f 	isb	sy

	k_spinlock_key_t key = k_spin_lock(&mgr->lock);
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;

	/* Reject if this would overflow the reference count. */
	if (mgr->refs == SERVICE_REFS_MAX) {
    5252:	8b63      	ldrh	r3, [r4, #26]
	uint32_t state = mgr->flags & ONOFF_STATE_MASK;
    5254:	8b20      	ldrh	r0, [r4, #24]
	if (mgr->refs == SERVICE_REFS_MAX) {
    5256:	f64f 75ff 	movw	r5, #65535	; 0xffff
    525a:	42ab      	cmp	r3, r5
    525c:	f000 0207 	and.w	r2, r0, #7
    5260:	d02e      	beq.n	52c0 <onoff_request+0x8c>
		rv = -EAGAIN;
		goto out;
	}

	rv = state;
	if (state == ONOFF_STATE_ON) {
    5262:	2a02      	cmp	r2, #2
    5264:	d10e      	bne.n	5284 <onoff_request+0x50>
		/* Increment reference count, notify in exit */
		notify = true;
		mgr->refs += 1U;
    5266:	3301      	adds	r3, #1
    5268:	8363      	strh	r3, [r4, #26]
	rv = state;
    526a:	4615      	mov	r5, r2
		notify = true;
    526c:	2301      	movs	r3, #1
	__asm__ volatile(
    526e:	f381 8811 	msr	BASEPRI, r1
    5272:	f3bf 8f6f 	isb	sy
	if (start) {
		process_event(mgr, EVT_RECHECK, key);
	} else {
		k_spin_unlock(&mgr->lock, key);

		if (notify) {
    5276:	b1b3      	cbz	r3, 52a6 <onoff_request+0x72>
			notify_one(mgr, cli, state, 0);
    5278:	2300      	movs	r3, #0
    527a:	4631      	mov	r1, r6
    527c:	4620      	mov	r0, r4
    527e:	f7ff ff92 	bl	51a6 <notify_one>
    5282:	e010      	b.n	52a6 <onoff_request+0x72>
	} else if ((state == ONOFF_STATE_OFF)
    5284:	0783      	lsls	r3, r0, #30
    5286:	d001      	beq.n	528c <onoff_request+0x58>
		   || (state == ONOFF_STATE_TO_ON)) {
    5288:	2a06      	cmp	r2, #6
    528a:	d10e      	bne.n	52aa <onoff_request+0x76>
	parent->next = child;
    528c:	2300      	movs	r3, #0
    528e:	6033      	str	r3, [r6, #0]
 *
 * @return A pointer on the last node of the list (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_tail(sys_slist_t *list)
{
	return list->tail;
    5290:	6863      	ldr	r3, [r4, #4]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
    5292:	b993      	cbnz	r3, 52ba <onoff_request+0x86>
	list->head = node;
    5294:	e9c4 6600 	strd	r6, r6, [r4]
	if (start) {
    5298:	4615      	mov	r5, r2
    529a:	b962      	cbnz	r2, 52b6 <onoff_request+0x82>
		process_event(mgr, EVT_RECHECK, key);
    529c:	460a      	mov	r2, r1
    529e:	4620      	mov	r0, r4
    52a0:	2102      	movs	r1, #2
    52a2:	f7fb fd2f 	bl	d04 <process_event>
		}
	}

	return rv;
}
    52a6:	4628      	mov	r0, r5
    52a8:	bd70      	pop	{r4, r5, r6, pc}
		rv = -EIO;
    52aa:	2a05      	cmp	r2, #5
    52ac:	bf0c      	ite	eq
    52ae:	f06f 0585 	mvneq.w	r5, #133	; 0x85
    52b2:	f06f 0504 	mvnne.w	r5, #4
    52b6:	2300      	movs	r3, #0
    52b8:	e7d9      	b.n	526e <onoff_request+0x3a>
	parent->next = child;
    52ba:	601e      	str	r6, [r3, #0]
	list->tail = node;
    52bc:	6066      	str	r6, [r4, #4]
}
    52be:	e7eb      	b.n	5298 <onoff_request+0x64>
		rv = -EAGAIN;
    52c0:	f06f 050a 	mvn.w	r5, #10
    52c4:	e7f7      	b.n	52b6 <onoff_request+0x82>

000052c6 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_BUILD_OUTPUT_META, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_COMPAT_INCLUDES, 1);
GEN_ABSOLUTE_SYM_KCONFIG(CONFIG_LEGACY_INCLUDE_PATH, 1);

GEN_ABS_SYM_END
    52c6:	4770      	bx	lr

000052c8 <flash_area_close>:

void flash_area_close(const struct flash_area *fa)
{
	/* nothing to do for now */
}
    52c8:	4770      	bx	lr

000052ca <flash_area_read>:

int flash_area_read(const struct flash_area *fa, off_t off, void *dst,
		    size_t len)
{
    52ca:	b573      	push	{r0, r1, r4, r5, r6, lr}


static inline bool is_in_flash_area_bounds(const struct flash_area *fa,
					   off_t off, size_t len)
{
	return (off >= 0) && ((off + len) <= fa->fa_size);
    52cc:	1e0c      	subs	r4, r1, #0
    52ce:	4605      	mov	r5, r0
    52d0:	9201      	str	r2, [sp, #4]
    52d2:	461e      	mov	r6, r3
    52d4:	db11      	blt.n	52fa <flash_area_read+0x30>
    52d6:	6881      	ldr	r1, [r0, #8]
    52d8:	18e3      	adds	r3, r4, r3
    52da:	428b      	cmp	r3, r1
    52dc:	d80d      	bhi.n	52fa <flash_area_read+0x30>

	if (!is_in_flash_area_bounds(fa, off, len)) {
		return -EINVAL;
	}

	dev = device_get_binding(fa->fa_dev_name);
    52de:	68c0      	ldr	r0, [r0, #12]
    52e0:	f7fd fe42 	bl	2f68 <z_impl_device_get_binding>

	return flash_read(dev, fa->fa_off + off, dst, len);
    52e4:	6869      	ldr	r1, [r5, #4]
    52e6:	4421      	add	r1, r4
				    size_t len)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->read(dev, offset, data, len);
    52e8:	6883      	ldr	r3, [r0, #8]
    52ea:	9a01      	ldr	r2, [sp, #4]
    52ec:	681c      	ldr	r4, [r3, #0]
    52ee:	4633      	mov	r3, r6
    52f0:	46a4      	mov	ip, r4
}
    52f2:	b002      	add	sp, #8
    52f4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    52f8:	4760      	bx	ip
    52fa:	f06f 0015 	mvn.w	r0, #21
    52fe:	b002      	add	sp, #8
    5300:	bd70      	pop	{r4, r5, r6, pc}

00005302 <flash_area_write>:

int flash_area_write(const struct flash_area *fa, off_t off, const void *src,
		     size_t len)
{
    5302:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5304:	1e0c      	subs	r4, r1, #0
    5306:	4605      	mov	r5, r0
    5308:	9201      	str	r2, [sp, #4]
    530a:	461e      	mov	r6, r3
    530c:	db11      	blt.n	5332 <flash_area_write+0x30>
    530e:	6881      	ldr	r1, [r0, #8]
    5310:	18e3      	adds	r3, r4, r3
    5312:	428b      	cmp	r3, r1
    5314:	d80d      	bhi.n	5332 <flash_area_write+0x30>

	if (!is_in_flash_area_bounds(fa, off, len)) {
		return -EINVAL;
	}

	flash_dev = device_get_binding(fa->fa_dev_name);
    5316:	68c0      	ldr	r0, [r0, #12]
    5318:	f7fd fe26 	bl	2f68 <z_impl_device_get_binding>

	rc = flash_write(flash_dev, fa->fa_off + off, (void *)src, len);
    531c:	6869      	ldr	r1, [r5, #4]
    531e:	4421      	add	r1, r4
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;
	int rc;

	rc = api->write(dev, offset, data, len);
    5320:	6883      	ldr	r3, [r0, #8]
    5322:	9a01      	ldr	r2, [sp, #4]
    5324:	685c      	ldr	r4, [r3, #4]
    5326:	4633      	mov	r3, r6
    5328:	46a4      	mov	ip, r4

	return rc;
}
    532a:	b002      	add	sp, #8
    532c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    5330:	4760      	bx	ip
    5332:	f06f 0015 	mvn.w	r0, #21
    5336:	b002      	add	sp, #8
    5338:	bd70      	pop	{r4, r5, r6, pc}

0000533a <flash_area_erase>:

int flash_area_erase(const struct flash_area *fa, off_t off, size_t len)
{
    533a:	b570      	push	{r4, r5, r6, lr}
    533c:	1e0c      	subs	r4, r1, #0
    533e:	4605      	mov	r5, r0
    5340:	4616      	mov	r6, r2
    5342:	db0e      	blt.n	5362 <flash_area_erase+0x28>
    5344:	18a3      	adds	r3, r4, r2
    5346:	6882      	ldr	r2, [r0, #8]
    5348:	4293      	cmp	r3, r2
    534a:	d80a      	bhi.n	5362 <flash_area_erase+0x28>

	if (!is_in_flash_area_bounds(fa, off, len)) {
		return -EINVAL;
	}

	flash_dev = device_get_binding(fa->fa_dev_name);
    534c:	68c0      	ldr	r0, [r0, #12]
    534e:	f7fd fe0b 	bl	2f68 <z_impl_device_get_binding>

	rc = flash_erase(flash_dev, fa->fa_off + off, len);
    5352:	6869      	ldr	r1, [r5, #4]
    5354:	4421      	add	r1, r4
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;
	int rc;

	rc = api->erase(dev, offset, size);
    5356:	6883      	ldr	r3, [r0, #8]
    5358:	4632      	mov	r2, r6
    535a:	689b      	ldr	r3, [r3, #8]

	return rc;
}
    535c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    5360:	4718      	bx	r3
    5362:	f06f 0015 	mvn.w	r0, #21
    5366:	bd70      	pop	{r4, r5, r6, pc}

00005368 <flash_area_align>:

uint32_t flash_area_align(const struct flash_area *fa)
{
    5368:	b508      	push	{r3, lr}
	const struct device *dev;

	dev = device_get_binding(fa->fa_dev_name);
    536a:	68c0      	ldr	r0, [r0, #12]
    536c:	f7fd fdfc 	bl	2f68 <z_impl_device_get_binding>
static inline size_t z_impl_flash_get_write_block_size(const struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->get_parameters(dev)->write_block_size;
    5370:	6883      	ldr	r3, [r0, #8]
    5372:	68db      	ldr	r3, [r3, #12]
    5374:	4798      	blx	r3

	return flash_get_write_block_size(dev);
}
    5376:	6800      	ldr	r0, [r0, #0]
    5378:	bd08      	pop	{r3, pc}

0000537a <flash_area_erased_val>:
{
	return device_get_binding(fa->fa_dev_name);
}

uint8_t flash_area_erased_val(const struct flash_area *fa)
{
    537a:	b508      	push	{r3, lr}
	const struct flash_parameters *param;

	param = flash_get_parameters(device_get_binding(fa->fa_dev_name));
    537c:	68c0      	ldr	r0, [r0, #12]
    537e:	f7fd fdf3 	bl	2f68 <z_impl_device_get_binding>
static inline const struct flash_parameters *z_impl_flash_get_parameters(const struct device *dev)
{
	const struct flash_driver_api *api =
		(const struct flash_driver_api *)dev->api;

	return api->get_parameters(dev);
    5382:	6883      	ldr	r3, [r0, #8]
    5384:	68db      	ldr	r3, [r3, #12]
    5386:	4798      	blx	r3

	return param->erase_value;
}
    5388:	7900      	ldrb	r0, [r0, #4]
    538a:	bd08      	pop	{r3, pc}

0000538c <get_sectors_cb>:
{
    538c:	b570      	push	{r4, r5, r6, lr}
	if (info->start_offset < data->area_off) {
    538e:	6802      	ldr	r2, [r0, #0]
    5390:	684c      	ldr	r4, [r1, #4]
    5392:	42a2      	cmp	r2, r4
    5394:	d316      	bcc.n	53c4 <get_sectors_cb+0x38>
	} else if (info->start_offset >= data->area_off + data->area_len) {
    5396:	688b      	ldr	r3, [r1, #8]
    5398:	4423      	add	r3, r4
    539a:	429a      	cmp	r2, r3
    539c:	d206      	bcs.n	53ac <get_sectors_cb+0x20>
	} else if (data->ret_idx >= data->ret_len) {
    539e:	e9d1 3504 	ldrd	r3, r5, [r1, #16]
    53a2:	42ab      	cmp	r3, r5
    53a4:	d304      	bcc.n	53b0 <get_sectors_cb+0x24>
		data->status = -ENOMEM;
    53a6:	f06f 030b 	mvn.w	r3, #11
    53aa:	618b      	str	r3, [r1, #24]
		*bail_value = false;
    53ac:	2000      	movs	r0, #0
    53ae:	e00a      	b.n	53c6 <get_sectors_cb+0x3a>
	ret[data->ret_idx].fs_off = info->start_offset - data->area_off;
    53b0:	68cd      	ldr	r5, [r1, #12]
    53b2:	1b12      	subs	r2, r2, r4
    53b4:	eb05 06c3 	add.w	r6, r5, r3, lsl #3
    53b8:	f845 2033 	str.w	r2, [r5, r3, lsl #3]
	ret[data->ret_idx].fs_size = info->size;
    53bc:	6842      	ldr	r2, [r0, #4]
    53be:	6072      	str	r2, [r6, #4]
	data->ret_idx++;
    53c0:	3301      	adds	r3, #1
    53c2:	610b      	str	r3, [r1, #16]
		*bail_value = true;
    53c4:	2001      	movs	r0, #1
}
    53c6:	bd70      	pop	{r4, r5, r6, pc}

000053c8 <abort_function>:
	while(1);
    53c8:	e7fe      	b.n	53c8 <abort_function>

000053ca <nrf_cc3xx_platform_mutex_init>:
/** @brief Function to initialize the nrf_cc3xx_platform mutex APIs
 */
void nrf_cc3xx_platform_mutex_init(void)
{
	// No thread-safe mutexes are required
}
    53ca:	4770      	bx	lr

000053cc <z_arm_fatal_error>:
{

	if (esf != NULL) {
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
    53cc:	f000 bbf4 	b.w	5bb8 <z_fatal_error>

000053d0 <z_do_kernel_oops>:
 *   fault handler will executed instead of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
    53d0:	4601      	mov	r1, r0
	z_fatal_error(reason, esf);
    53d2:	6800      	ldr	r0, [r0, #0]
    53d4:	f000 bbf0 	b.w	5bb8 <z_fatal_error>

000053d8 <z_irq_spurious>:
 */
void z_irq_spurious(const void *unused)
{
	ARG_UNUSED(unused);

	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
    53d8:	2100      	movs	r1, #0
    53da:	2001      	movs	r0, #1
    53dc:	f7ff bff6 	b.w	53cc <z_arm_fatal_error>

000053e0 <z_arm_nmi>:
 * Simply call what is installed in 'static void(*handler)(void)'.
 *
 */

void z_arm_nmi(void)
{
    53e0:	b508      	push	{r3, lr}
	handler();
    53e2:	f7fb fe25 	bl	1030 <z_SysNmiOnReset>
	z_arm_int_exit();
}
    53e6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
    53ea:	f7fb bea7 	b.w	113c <z_arm_exc_exit>

000053ee <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
    53ee:	3801      	subs	r0, #1
    53f0:	3901      	subs	r1, #1
    53f2:	f810 3f01 	ldrb.w	r3, [r0, #1]!
    53f6:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    53fa:	4293      	cmp	r3, r2
    53fc:	d101      	bne.n	5402 <strcmp+0x14>
    53fe:	2b00      	cmp	r3, #0
    5400:	d1f7      	bne.n	53f2 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
    5402:	1a98      	subs	r0, r3, r2
    5404:	4770      	bx	lr

00005406 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
    5406:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
    5408:	b162      	cbz	r2, 5424 <memcmp+0x1e>
    540a:	4603      	mov	r3, r0
    540c:	3901      	subs	r1, #1
    540e:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
    5410:	f813 0b01 	ldrb.w	r0, [r3], #1
    5414:	f811 2f01 	ldrb.w	r2, [r1, #1]!
    5418:	42a3      	cmp	r3, r4
    541a:	d001      	beq.n	5420 <memcmp+0x1a>
    541c:	4290      	cmp	r0, r2
    541e:	d0f7      	beq.n	5410 <memcmp+0xa>
		c1++;
		c2++;
	}

	return *c1 - *c2;
    5420:	1a80      	subs	r0, r0, r2
}
    5422:	bd10      	pop	{r4, pc}
		return 0;
    5424:	4610      	mov	r0, r2
    5426:	e7fc      	b.n	5422 <memcmp+0x1c>

00005428 <memmove>:
void *memmove(void *d, const void *s, size_t n)
{
	char *dest = d;
	const char *src  = s;

	if ((size_t) (dest - src) < n) {
    5428:	1a43      	subs	r3, r0, r1
    542a:	4293      	cmp	r3, r2
{
    542c:	b510      	push	{r4, lr}
    542e:	eb00 0302 	add.w	r3, r0, r2
	if ((size_t) (dest - src) < n) {
    5432:	d308      	bcc.n	5446 <memmove+0x1e>
    5434:	3901      	subs	r1, #1
	char *dest = d;
    5436:	4602      	mov	r2, r0
			n--;
			dest[n] = src[n];
		}
	} else {
		/* It is safe to perform a forward-copy */
		while (n > 0) {
    5438:	429a      	cmp	r2, r3
    543a:	d007      	beq.n	544c <memmove+0x24>
			*dest = *src;
    543c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
    5440:	f802 4b01 	strb.w	r4, [r2], #1
			dest++;
			src++;
			n--;
    5444:	e7f8      	b.n	5438 <memmove+0x10>
    5446:	440a      	add	r2, r1
		while (n > 0) {
    5448:	428a      	cmp	r2, r1
    544a:	d100      	bne.n	544e <memmove+0x26>
		}
	}

	return d;
}
    544c:	bd10      	pop	{r4, pc}
			dest[n] = src[n];
    544e:	f812 4d01 	ldrb.w	r4, [r2, #-1]!
    5452:	f803 4d01 	strb.w	r4, [r3, #-1]!
    5456:	e7f7      	b.n	5448 <memmove+0x20>

00005458 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *ZRESTRICT d, const void *ZRESTRICT s, size_t n)
{
    5458:	b510      	push	{r4, lr}
    545a:	1e43      	subs	r3, r0, #1
    545c:	440a      	add	r2, r1
	}
#endif

	/* do byte-sized copying until finished */

	while (n > 0) {
    545e:	4291      	cmp	r1, r2
    5460:	d100      	bne.n	5464 <memcpy+0xc>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
    5462:	bd10      	pop	{r4, pc}
		*(d_byte++) = *(s_byte++);
    5464:	f811 4b01 	ldrb.w	r4, [r1], #1
    5468:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
    546c:	e7f7      	b.n	545e <memcpy+0x6>

0000546e <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
    546e:	b2c9      	uxtb	r1, r1
	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;
#endif

	while (n > 0) {
    5470:	4402      	add	r2, r0
	unsigned char *d_byte = (unsigned char *)buf;
    5472:	4603      	mov	r3, r0
	while (n > 0) {
    5474:	4293      	cmp	r3, r2
    5476:	d100      	bne.n	547a <memset+0xc>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
    5478:	4770      	bx	lr
		*(d_byte++) = c_byte;
    547a:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
    547e:	e7f9      	b.n	5474 <memset+0x6>

00005480 <get_status>:
	return GET_STATUS(get_sub_data(dev, type)->flags);
    5480:	6903      	ldr	r3, [r0, #16]
    5482:	b2c9      	uxtb	r1, r1
    5484:	220c      	movs	r2, #12
    5486:	fb01 3302 	mla	r3, r1, r2, r3
    548a:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
    548c:	f000 0007 	and.w	r0, r0, #7
    5490:	4770      	bx	lr

00005492 <set_on_state>:
	__asm__ volatile(
    5492:	f04f 0320 	mov.w	r3, #32
    5496:	f3ef 8211 	mrs	r2, BASEPRI
    549a:	f383 8812 	msr	BASEPRI_MAX, r3
    549e:	f3bf 8f6f 	isb	sy
	*flags = CLOCK_CONTROL_STATUS_ON | GET_CTX(*flags);
    54a2:	6803      	ldr	r3, [r0, #0]
    54a4:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
    54a8:	f043 0302 	orr.w	r3, r3, #2
    54ac:	6003      	str	r3, [r0, #0]
	__asm__ volatile(
    54ae:	f382 8811 	msr	BASEPRI, r2
    54b2:	f3bf 8f6f 	isb	sy
}
    54b6:	4770      	bx	lr

000054b8 <stop>:
{
    54b8:	4603      	mov	r3, r0
    54ba:	b570      	push	{r4, r5, r6, lr}
	struct nrf_clock_control_data *data = dev->data;
    54bc:	6900      	ldr	r0, [r0, #16]
	return &data->subsys[type];
    54be:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
    54c0:	f04f 0420 	mov.w	r4, #32
    54c4:	f3ef 8611 	mrs	r6, BASEPRI
    54c8:	f384 8812 	msr	BASEPRI_MAX, r4
    54cc:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    54d0:	250c      	movs	r5, #12
    54d2:	fb05 0401 	mla	r4, r5, r1, r0
    54d6:	6c24      	ldr	r4, [r4, #64]	; 0x40
	if ((current_ctx != 0) && (current_ctx != ctx)) {
    54d8:	f014 04c0 	ands.w	r4, r4, #192	; 0xc0
    54dc:	d001      	beq.n	54e2 <stop+0x2a>
    54de:	42a2      	cmp	r2, r4
    54e0:	d110      	bne.n	5504 <stop+0x4c>
		*flags = CLOCK_CONTROL_STATUS_OFF;
    54e2:	fb05 0001 	mla	r0, r5, r1, r0
    54e6:	2201      	movs	r2, #1
    54e8:	6402      	str	r2, [r0, #64]	; 0x40
	int err = 0;
    54ea:	2000      	movs	r0, #0
	__asm__ volatile(
    54ec:	f386 8811 	msr	BASEPRI, r6
    54f0:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    54f4:	b928      	cbnz	r0, 5502 <stop+0x4a>
	get_sub_config(dev, type)->stop();
    54f6:	685b      	ldr	r3, [r3, #4]
    54f8:	eb03 01c1 	add.w	r1, r3, r1, lsl #3
    54fc:	684b      	ldr	r3, [r1, #4]
    54fe:	4798      	blx	r3
	return 0;
    5500:	2000      	movs	r0, #0
}
    5502:	bd70      	pop	{r4, r5, r6, pc}
		err = -EPERM;
    5504:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5508:	e7f0      	b.n	54ec <stop+0x34>

0000550a <api_stop>:
	return stop(dev, subsys, CTX_API);
    550a:	2280      	movs	r2, #128	; 0x80
    550c:	f7ff bfd4 	b.w	54b8 <stop>

00005510 <async_start>:
{
    5510:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    5512:	9f06      	ldr	r7, [sp, #24]
	struct nrf_clock_control_data *data = dev->data;
    5514:	6904      	ldr	r4, [r0, #16]
	return &data->subsys[type];
    5516:	b2c9      	uxtb	r1, r1
	__asm__ volatile(
    5518:	f04f 0520 	mov.w	r5, #32
    551c:	f3ef 8c11 	mrs	ip, BASEPRI
    5520:	f385 8812 	msr	BASEPRI_MAX, r5
    5524:	f3bf 8f6f 	isb	sy
	uint32_t current_ctx = GET_CTX(*flags);
    5528:	260c      	movs	r6, #12
    552a:	fb06 4601 	mla	r6, r6, r1, r4
    552e:	6c35      	ldr	r5, [r6, #64]	; 0x40
	if ((*flags & (STATUS_MASK)) == CLOCK_CONTROL_STATUS_OFF) {
    5530:	f005 0e07 	and.w	lr, r5, #7
    5534:	f1be 0f01 	cmp.w	lr, #1
    5538:	d111      	bne.n	555e <async_start+0x4e>
		*flags = CLOCK_CONTROL_STATUS_STARTING | ctx;
    553a:	6437      	str	r7, [r6, #64]	; 0x40
	int err = 0;
    553c:	2500      	movs	r5, #0
	__asm__ volatile(
    553e:	f38c 8811 	msr	BASEPRI, ip
    5542:	f3bf 8f6f 	isb	sy
	if (err < 0) {
    5546:	b945      	cbnz	r5, 555a <async_start+0x4a>
	subdata->cb = cb;
    5548:	260c      	movs	r6, #12
    554a:	fb06 4401 	mla	r4, r6, r1, r4
	subdata->user_data = user_data;
    554e:	e9c4 230e 	strd	r2, r3, [r4, #56]	; 0x38
	 get_sub_config(dev, type)->start();
    5552:	6843      	ldr	r3, [r0, #4]
    5554:	f853 3031 	ldr.w	r3, [r3, r1, lsl #3]
    5558:	4798      	blx	r3
}
    555a:	4628      	mov	r0, r5
    555c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	uint32_t current_ctx = GET_CTX(*flags);
    555e:	f005 05c0 	and.w	r5, r5, #192	; 0xc0
		err = -EALREADY;
    5562:	42af      	cmp	r7, r5
    5564:	bf14      	ite	ne
    5566:	f04f 35ff 	movne.w	r5, #4294967295	; 0xffffffff
    556a:	f06f 0577 	mvneq.w	r5, #119	; 0x77
    556e:	e7e6      	b.n	553e <async_start+0x2e>

00005570 <api_start>:
{
    5570:	b513      	push	{r0, r1, r4, lr}
	return async_start(dev, subsys, cb, user_data, CTX_API);
    5572:	2480      	movs	r4, #128	; 0x80
    5574:	9400      	str	r4, [sp, #0]
    5576:	f7ff ffcb 	bl	5510 <async_start>
}
    557a:	b002      	add	sp, #8
    557c:	bd10      	pop	{r4, pc}

0000557e <api_blocking_start>:
}
    557e:	f06f 0085 	mvn.w	r0, #133	; 0x85
    5582:	4770      	bx	lr

00005584 <onoff_started_callback>:
	return &data->mgr[type];
    5584:	6900      	ldr	r0, [r0, #16]
{
    5586:	b410      	push	{r4}
	return &data->mgr[type];
    5588:	b2cb      	uxtb	r3, r1
	notify(mgr, 0);
    558a:	241c      	movs	r4, #28
    558c:	fb03 0004 	mla	r0, r3, r4, r0
    5590:	2100      	movs	r1, #0
}
    5592:	f85d 4b04 	ldr.w	r4, [sp], #4
	notify(mgr, 0);
    5596:	4710      	bx	r2

00005598 <lfclk_start>:
    nrfx_clock_start(NRF_CLOCK_DOMAIN_LFCLK);
    5598:	2000      	movs	r0, #0
    559a:	f000 ba91 	b.w	5ac0 <nrfx_clock_start>

0000559e <lfclk_stop>:
    nrfx_clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    559e:	2000      	movs	r0, #0
    55a0:	f000 bacb 	b.w	5b3a <nrfx_clock_stop>

000055a4 <qspi_handler>:
	if (event == NRFX_QSPI_EVENT_DONE) {
    55a4:	b908      	cbnz	r0, 55aa <qspi_handler+0x6>
	dev_data->ready = true;
    55a6:	2301      	movs	r3, #1
    55a8:	700b      	strb	r3, [r1, #0]
}
    55aa:	4770      	bx	lr

000055ac <qspi_send_cmd.constprop.0>:
static int qspi_send_cmd(const struct device *dev, const struct qspi_cmd *cmd,
    55ac:	b537      	push	{r0, r1, r2, r4, r5, lr}
    55ae:	460d      	mov	r5, r1
	if (cmd->tx_buf) {
    55b0:	6841      	ldr	r1, [r0, #4]
    55b2:	b319      	cbz	r1, 55fc <qspi_send_cmd.constprop.0+0x50>
		tx_buf = cmd->tx_buf->buf;
    55b4:	e9d1 1300 	ldrd	r1, r3, [r1]
	if (cmd->rx_buf) {
    55b8:	6884      	ldr	r4, [r0, #8]
    55ba:	b30c      	cbz	r4, 5600 <qspi_send_cmd.constprop.0+0x54>
		rx_len = cmd->rx_buf->len;
    55bc:	e9d4 2400 	ldrd	r2, r4, [r4]
	if ((rx_len != 0) && (tx_len != 0)) {
    55c0:	b1fc      	cbz	r4, 5602 <qspi_send_cmd.constprop.0+0x56>
    55c2:	b1f3      	cbz	r3, 5602 <qspi_send_cmd.constprop.0+0x56>
		if (rx_len != tx_len) {
    55c4:	429c      	cmp	r4, r3
    55c6:	d11f      	bne.n	5608 <qspi_send_cmd.constprop.0+0x5c>
		xfer_len += tx_len;
    55c8:	3301      	adds	r3, #1
	if (xfer_len > NRF_QSPI_CINSTR_LEN_9B) {
    55ca:	2b09      	cmp	r3, #9
    55cc:	d81c      	bhi.n	5608 <qspi_send_cmd.constprop.0+0x5c>
	nrf_qspi_cinstr_conf_t cinstr_cfg = {
    55ce:	7800      	ldrb	r0, [r0, #0]
    55d0:	f88d 3001 	strb.w	r3, [sp, #1]
    55d4:	2301      	movs	r3, #1
    55d6:	f88d 0000 	strb.w	r0, [sp]
    55da:	f88d 3002 	strb.w	r3, [sp, #2]
    55de:	f88d 3003 	strb.w	r3, [sp, #3]
	int res = nrfx_qspi_cinstr_xfer(&cinstr_cfg, tx_buf, rx_buf);
    55e2:	4668      	mov	r0, sp
	nrf_qspi_cinstr_conf_t cinstr_cfg = {
    55e4:	2300      	movs	r3, #0
    55e6:	f88d 3004 	strb.w	r3, [sp, #4]
    55ea:	f88d 5005 	strb.w	r5, [sp, #5]
	int res = nrfx_qspi_cinstr_xfer(&cinstr_cfg, tx_buf, rx_buf);
    55ee:	f7fd fb7d 	bl	2cec <nrfx_qspi_cinstr_xfer>
}
    55f2:	b003      	add	sp, #12
    55f4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	return qspi_get_zephyr_ret_code(res);
    55f8:	f7fc b944 	b.w	1884 <qspi_get_zephyr_ret_code>
	size_t tx_len = 0;
    55fc:	460b      	mov	r3, r1
    55fe:	e7db      	b.n	55b8 <qspi_send_cmd.constprop.0+0xc>
	void *rx_buf = NULL;
    5600:	4622      	mov	r2, r4
		xfer_len += tx_len + rx_len;
    5602:	3301      	adds	r3, #1
    5604:	4423      	add	r3, r4
    5606:	e7e0      	b.n	55ca <qspi_send_cmd.constprop.0+0x1e>
}
    5608:	f06f 0015 	mvn.w	r0, #21
    560c:	b003      	add	sp, #12
    560e:	bd30      	pop	{r4, r5, pc}

00005610 <qspi_rdsr.constprop.0.isra.0>:
static int qspi_rdsr(const struct device *dev, uint8_t sr_num)
    5610:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	uint8_t sr = 0xFF;
    5612:	23ff      	movs	r3, #255	; 0xff
    5614:	f88d 3003 	strb.w	r3, [sp, #3]
	const struct qspi_buf sr_buf = {
    5618:	f10d 0303 	add.w	r3, sp, #3
	struct qspi_cmd cmd = {
    561c:	2100      	movs	r1, #0
	const struct qspi_buf sr_buf = {
    561e:	9301      	str	r3, [sp, #4]
	struct qspi_cmd cmd = {
    5620:	2301      	movs	r3, #1
    5622:	e9cd 3102 	strd	r3, r1, [sp, #8]
    5626:	2305      	movs	r3, #5
    5628:	f88d 300c 	strb.w	r3, [sp, #12]
	int ret = qspi_send_cmd(dev, &cmd, false);
    562c:	a803      	add	r0, sp, #12
	struct qspi_cmd cmd = {
    562e:	ab01      	add	r3, sp, #4
    5630:	9104      	str	r1, [sp, #16]
    5632:	9305      	str	r3, [sp, #20]
	int ret = qspi_send_cmd(dev, &cmd, false);
    5634:	f7ff ffba 	bl	55ac <qspi_send_cmd.constprop.0>
	return (ret < 0) ? ret : sr;
    5638:	2800      	cmp	r0, #0
    563a:	bfa8      	it	ge
    563c:	f89d 0003 	ldrbge.w	r0, [sp, #3]
}
    5640:	b007      	add	sp, #28
    5642:	f85d fb04 	ldr.w	pc, [sp], #4

00005646 <qspi_nor_write_protection_set.isra.0>:
static int qspi_nor_write_protection_set(const struct device *dev,
    5646:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	struct qspi_cmd cmd = {
    5648:	2100      	movs	r1, #0
    564a:	4288      	cmp	r0, r1
    564c:	bf14      	ite	ne
    564e:	2304      	movne	r3, #4
    5650:	2306      	moveq	r3, #6
	if (qspi_send_cmd(dev, &cmd, false) != 0) {
    5652:	a801      	add	r0, sp, #4
	struct qspi_cmd cmd = {
    5654:	e9cd 1101 	strd	r1, r1, [sp, #4]
    5658:	9103      	str	r1, [sp, #12]
    565a:	f88d 3004 	strb.w	r3, [sp, #4]
	if (qspi_send_cmd(dev, &cmd, false) != 0) {
    565e:	f7ff ffa5 	bl	55ac <qspi_send_cmd.constprop.0>
		ret = -EIO;
    5662:	2800      	cmp	r0, #0
}
    5664:	bf18      	it	ne
    5666:	f06f 0004 	mvnne.w	r0, #4
    566a:	b005      	add	sp, #20
    566c:	f85d fb04 	ldr.w	pc, [sp], #4

00005670 <is_regular_addr_valid>:
{
    5670:	b538      	push	{r3, r4, r5, lr}
    5672:	4605      	mov	r5, r0
    5674:	460c      	mov	r4, r1
	return is_within_bounds(addr, len, 0, nrfx_nvmc_flash_size_get());
    5676:	f000 fa62 	bl	5b3e <nrfx_nvmc_flash_size_get>
			(addr < (boundary_start + boundary_size)) &&
    567a:	2d00      	cmp	r5, #0
    567c:	db07      	blt.n	568e <is_regular_addr_valid+0x1e>
	return (addr >= boundary_start &&
    567e:	42a8      	cmp	r0, r5
    5680:	d905      	bls.n	568e <is_regular_addr_valid+0x1e>
			(len <= (boundary_start + boundary_size - addr)));
    5682:	1b40      	subs	r0, r0, r5
			(addr < (boundary_start + boundary_size)) &&
    5684:	4284      	cmp	r4, r0
    5686:	bf8c      	ite	hi
    5688:	2000      	movhi	r0, #0
    568a:	2001      	movls	r0, #1
}
    568c:	bd38      	pop	{r3, r4, r5, pc}
			(addr < (boundary_start + boundary_size)) &&
    568e:	2000      	movs	r0, #0
    5690:	e7fc      	b.n	568c <is_regular_addr_valid+0x1c>

00005692 <flash_nrf_read>:
{
    5692:	b570      	push	{r4, r5, r6, lr}
    5694:	460d      	mov	r5, r1
	if (is_regular_addr_valid(addr, len)) {
    5696:	4628      	mov	r0, r5
    5698:	4619      	mov	r1, r3
{
    569a:	4616      	mov	r6, r2
    569c:	461c      	mov	r4, r3
	if (is_regular_addr_valid(addr, len)) {
    569e:	f7ff ffe7 	bl	5670 <is_regular_addr_valid>
    56a2:	b138      	cbz	r0, 56b4 <flash_nrf_read+0x22>
	if (!len) {
    56a4:	b14c      	cbz	r4, 56ba <flash_nrf_read+0x28>
	memcpy(data, (void *)addr, len);
    56a6:	4622      	mov	r2, r4
    56a8:	4629      	mov	r1, r5
    56aa:	4630      	mov	r0, r6
    56ac:	f7ff fed4 	bl	5458 <memcpy>
	return 0;
    56b0:	2000      	movs	r0, #0
}
    56b2:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    56b4:	f06f 0015 	mvn.w	r0, #21
    56b8:	e7fb      	b.n	56b2 <flash_nrf_read+0x20>
		return 0;
    56ba:	4620      	mov	r0, r4
    56bc:	e7f9      	b.n	56b2 <flash_nrf_read+0x20>

000056be <flash_page_foreach>:
	return count;
}

void flash_page_foreach(const struct device *dev, flash_page_cb cb,
			void *data)
{
    56be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	const struct flash_pages_layout *layout;
	struct flash_pages_info page_info;
	size_t block, num_blocks, page = 0, i;
	off_t off = 0;

	api->page_layout(dev, &layout, &num_blocks);
    56c2:	6883      	ldr	r3, [r0, #8]
{
    56c4:	b086      	sub	sp, #24
	api->page_layout(dev, &layout, &num_blocks);
    56c6:	691b      	ldr	r3, [r3, #16]
{
    56c8:	4688      	mov	r8, r1
    56ca:	4691      	mov	r9, r2
	api->page_layout(dev, &layout, &num_blocks);
    56cc:	a901      	add	r1, sp, #4
    56ce:	aa02      	add	r2, sp, #8
    56d0:	4798      	blx	r3
	off_t off = 0;
    56d2:	2400      	movs	r4, #0
	size_t block, num_blocks, page = 0, i;
    56d4:	46a2      	mov	sl, r4

	for (block = 0; block < num_blocks; block++) {
    56d6:	4625      	mov	r5, r4
    56d8:	9b02      	ldr	r3, [sp, #8]
    56da:	42ab      	cmp	r3, r5
    56dc:	d802      	bhi.n	56e4 <flash_page_foreach+0x26>

			off += page_info.size;
			page++;
		}
	}
}
    56de:	b006      	add	sp, #24
    56e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		const struct flash_pages_layout *l = &layout[block];
    56e4:	9f01      	ldr	r7, [sp, #4]
    56e6:	eb07 07c5 	add.w	r7, r7, r5, lsl #3
		for (i = 0; i < l->pages_count; i++) {
    56ea:	2600      	movs	r6, #0
		page_info.size = l->pages_size;
    56ec:	687b      	ldr	r3, [r7, #4]
    56ee:	9304      	str	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
    56f0:	683a      	ldr	r2, [r7, #0]
    56f2:	42b2      	cmp	r2, r6
    56f4:	eb0a 0306 	add.w	r3, sl, r6
    56f8:	d802      	bhi.n	5700 <flash_page_foreach+0x42>
	for (block = 0; block < num_blocks; block++) {
    56fa:	3501      	adds	r5, #1
    56fc:	469a      	mov	sl, r3
    56fe:	e7eb      	b.n	56d8 <flash_page_foreach+0x1a>
			if (!cb(&page_info, data)) {
    5700:	4649      	mov	r1, r9
    5702:	a803      	add	r0, sp, #12
			page_info.start_offset = off;
    5704:	9403      	str	r4, [sp, #12]
			page_info.index = page;
    5706:	9305      	str	r3, [sp, #20]
			if (!cb(&page_info, data)) {
    5708:	47c0      	blx	r8
    570a:	2800      	cmp	r0, #0
    570c:	d0e7      	beq.n	56de <flash_page_foreach+0x20>
			off += page_info.size;
    570e:	9b04      	ldr	r3, [sp, #16]
		for (i = 0; i < l->pages_count; i++) {
    5710:	3601      	adds	r6, #1
			off += page_info.size;
    5712:	441c      	add	r4, r3
		for (i = 0; i < l->pages_count; i++) {
    5714:	e7ec      	b.n	56f0 <flash_page_foreach+0x32>

00005716 <sys_clock_set_timeout>:
}
    5716:	4770      	bx	lr

00005718 <sys_clock_elapsed>:
}
    5718:	2000      	movs	r0, #0
    571a:	4770      	bx	lr

0000571c <pinctrl_lookup_state>:

#include <drivers/pinctrl.h>

int pinctrl_lookup_state(const struct pinctrl_dev_config *config, uint8_t id,
			 const struct pinctrl_state **state)
{
    571c:	b530      	push	{r4, r5, lr}
	*state = &config->states[0];
    571e:	6843      	ldr	r3, [r0, #4]
    5720:	6013      	str	r3, [r2, #0]
	while (*state <= &config->states[config->state_cnt - 1U]) {
    5722:	7a03      	ldrb	r3, [r0, #8]
    5724:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
    5728:	3b01      	subs	r3, #1
    572a:	00db      	lsls	r3, r3, #3
    572c:	6845      	ldr	r5, [r0, #4]
    572e:	6814      	ldr	r4, [r2, #0]
    5730:	441d      	add	r5, r3
    5732:	42ac      	cmp	r4, r5
    5734:	d902      	bls.n	573c <pinctrl_lookup_state+0x20>
		}

		(*state)++;
	}

	return -ENOENT;
    5736:	f06f 0001 	mvn.w	r0, #1
}
    573a:	bd30      	pop	{r4, r5, pc}
		if (id == (*state)->id) {
    573c:	7965      	ldrb	r5, [r4, #5]
    573e:	428d      	cmp	r5, r1
    5740:	d002      	beq.n	5748 <pinctrl_lookup_state+0x2c>
		(*state)++;
    5742:	3408      	adds	r4, #8
    5744:	6014      	str	r4, [r2, #0]
    5746:	e7f1      	b.n	572c <pinctrl_lookup_state+0x10>
			return 0;
    5748:	2000      	movs	r0, #0
    574a:	e7f6      	b.n	573a <pinctrl_lookup_state+0x1e>

0000574c <nrf_gpio_pin_write>:
    if (value == 0)
    574c:	b909      	cbnz	r1, 5752 <nrf_gpio_pin_write+0x6>
        nrf_gpio_pin_clear(pin_number);
    574e:	f7fc bdfb 	b.w	2348 <nrf_gpio_pin_clear>
        nrf_gpio_pin_set(pin_number);
    5752:	f7fc be29 	b.w	23a8 <nrf_gpio_pin_set>

00005756 <pinctrl_configure_pins>:

int pinctrl_configure_pins(const pinctrl_soc_pin_t *pins, uint8_t pin_cnt,
			   uintptr_t reg)
{
    5756:	b570      	push	{r4, r5, r6, lr}
    5758:	4615      	mov	r5, r2
    575a:	4604      	mov	r4, r0
    575c:	eb00 0681 	add.w	r6, r0, r1, lsl #2
	for (uint8_t i = 0U; i < pin_cnt; i++) {
    5760:	42b4      	cmp	r4, r6
    5762:	d101      	bne.n	5768 <pinctrl_configure_pins+0x12>
		default:
			return -ENOTSUP;
		}
	}

	return 0;
    5764:	2000      	movs	r0, #0
}
    5766:	bd70      	pop	{r4, r5, r6, pc}
		__unused nrf_gpio_pin_drive_t drive = NRF_GET_DRIVE(pins[i]);
    5768:	6823      	ldr	r3, [r4, #0]
		switch (NRF_GET_FUN(pins[i])) {
    576a:	0c1a      	lsrs	r2, r3, #16
    576c:	2a22      	cmp	r2, #34	; 0x22
    576e:	f200 808e 	bhi.w	588e <pinctrl_configure_pins+0x138>
    5772:	e8df f002 	tbb	[pc, r2]
    5776:	1d12      	.short	0x1d12
    5778:	39294324 	.word	0x39294324
    577c:	8c8c8c43 	.word	0x8c8c8c43
    5780:	8c4d488c 	.word	0x8c4d488c
    5784:	8c8c8c8c 	.word	0x8c8c8c8c
    5788:	8c8c8c8c 	.word	0x8c8c8c8c
    578c:	68635e52 	.word	0x68635e52
    5790:	6d8c8c8c 	.word	0x6d8c8c8c
    5794:	827d7873 	.word	0x827d7873
    5798:	87          	.byte	0x87
    5799:	00          	.byte	0x00
			NRF_PSEL_UART(reg, TXD) = NRF_GET_PIN(pins[i]);
    579a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    579e:	f8c5 350c 	str.w	r3, [r5, #1292]	; 0x50c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 1);
    57a2:	6820      	ldr	r0, [r4, #0]
    57a4:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    57a8:	f7fc fdfe 	bl	23a8 <nrf_gpio_pin_set>
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
    57ac:	2201      	movs	r2, #1
    57ae:	e015      	b.n	57dc <pinctrl_configure_pins+0x86>
			NRF_PSEL_UART(reg, RXD) = NRF_GET_PIN(pins[i]);
    57b0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    57b4:	f8c5 3514 	str.w	r3, [r5, #1300]	; 0x514
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    57b8:	2200      	movs	r2, #0
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    57ba:	2100      	movs	r1, #0
    57bc:	e00f      	b.n	57de <pinctrl_configure_pins+0x88>
			NRF_PSEL_UART(reg, RTS) = NRF_GET_PIN(pins[i]);
    57be:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    57c2:	f8c5 3508 	str.w	r3, [r5, #1288]	; 0x508
    57c6:	e7ec      	b.n	57a2 <pinctrl_configure_pins+0x4c>
			NRF_PSEL_SPIM(reg, SCK) = NRF_GET_PIN(pins[i]);
    57c8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    57cc:	f8c5 3508 	str.w	r3, [r5, #1288]	; 0x508
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 0);
    57d0:	6820      	ldr	r0, [r4, #0]
        nrf_gpio_pin_clear(pin_number);
    57d2:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    57d6:	f7fc fdb7 	bl	2348 <nrf_gpio_pin_clear>
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
    57da:	2200      	movs	r2, #0
    57dc:	2101      	movs	r1, #1
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    57de:	6820      	ldr	r0, [r4, #0]
    57e0:	f7fc fdc2 	bl	2368 <nrf_pin_configure.constprop.0>
	for (uint8_t i = 0U; i < pin_cnt; i++) {
    57e4:	3404      	adds	r4, #4
    57e6:	e7bb      	b.n	5760 <pinctrl_configure_pins+0xa>
			NRF_PSEL_SPIM(reg, MOSI) = NRF_GET_PIN(pins[i]);
    57e8:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    57ec:	f8c5 350c 	str.w	r3, [r5, #1292]	; 0x50c
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]), 0);
    57f0:	6820      	ldr	r0, [r4, #0]
    57f2:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    57f6:	f7fc fda7 	bl	2348 <nrf_gpio_pin_clear>
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_OUTPUT,
    57fa:	e7d7      	b.n	57ac <pinctrl_configure_pins+0x56>
			NRF_PSEL_SPIM(reg, MISO) = NRF_GET_PIN(pins[i]);
    57fc:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5800:	f8c5 3510 	str.w	r3, [r5, #1296]	; 0x510
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    5804:	e7d8      	b.n	57b8 <pinctrl_configure_pins+0x62>
			NRF_PSEL_TWIM(reg, SCL) = NRF_GET_PIN(pins[i]);
    5806:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    580a:	f8c5 3508 	str.w	r3, [r5, #1288]	; 0x508
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    580e:	e7d3      	b.n	57b8 <pinctrl_configure_pins+0x62>
			NRF_PSEL_TWIM(reg, SDA) = NRF_GET_PIN(pins[i]);
    5810:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5814:	f8c5 350c 	str.w	r3, [r5, #1292]	; 0x50c
    5818:	e7ce      	b.n	57b8 <pinctrl_configure_pins+0x62>
			NRF_PSEL_PWM(reg, OUT[0]) = NRF_GET_PIN(pins[i]);
    581a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    581e:	f8c5 3560 	str.w	r3, [r5, #1376]	; 0x560
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
    5822:	6820      	ldr	r0, [r4, #0]
    5824:	f3c0 3140 	ubfx	r1, r0, #13, #1
    5828:	f000 003f 	and.w	r0, r0, #63	; 0x3f
    582c:	f7ff ff8e 	bl	574c <nrf_gpio_pin_write>
    5830:	e7bc      	b.n	57ac <pinctrl_configure_pins+0x56>
			NRF_PSEL_PWM(reg, OUT[1]) = NRF_GET_PIN(pins[i]);
    5832:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5836:	f8c5 3564 	str.w	r3, [r5, #1380]	; 0x564
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
    583a:	e7f2      	b.n	5822 <pinctrl_configure_pins+0xcc>
			NRF_PSEL_PWM(reg, OUT[2]) = NRF_GET_PIN(pins[i]);
    583c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5840:	f8c5 3568 	str.w	r3, [r5, #1384]	; 0x568
			nrf_gpio_pin_write(NRF_GET_PIN(pins[i]),
    5844:	e7ed      	b.n	5822 <pinctrl_configure_pins+0xcc>
			NRF_PSEL_PWM(reg, OUT[3]) = NRF_GET_PIN(pins[i]);
    5846:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    584a:	f8c5 356c 	str.w	r3, [r5, #1388]	; 0x56c
    584e:	e7e8      	b.n	5822 <pinctrl_configure_pins+0xcc>
			NRF_PSEL_QSPI(reg, SCK) = NRF_GET_PIN(pins[i]);
    5850:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5854:	f8c5 3524 	str.w	r3, [r5, #1316]	; 0x524
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    5858:	2201      	movs	r2, #1
    585a:	e7ae      	b.n	57ba <pinctrl_configure_pins+0x64>
			NRF_PSEL_QSPI(reg, CSN) = NRF_GET_PIN(pins[i]);
    585c:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5860:	f8c5 3528 	str.w	r3, [r5, #1320]	; 0x528
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    5864:	e7f8      	b.n	5858 <pinctrl_configure_pins+0x102>
			NRF_PSEL_QSPI(reg, IO0) = NRF_GET_PIN(pins[i]);
    5866:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    586a:	f8c5 3530 	str.w	r3, [r5, #1328]	; 0x530
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    586e:	e7f3      	b.n	5858 <pinctrl_configure_pins+0x102>
			NRF_PSEL_QSPI(reg, IO1) = NRF_GET_PIN(pins[i]);
    5870:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5874:	f8c5 3534 	str.w	r3, [r5, #1332]	; 0x534
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    5878:	e7ee      	b.n	5858 <pinctrl_configure_pins+0x102>
			NRF_PSEL_QSPI(reg, IO2) = NRF_GET_PIN(pins[i]);
    587a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    587e:	f8c5 3538 	str.w	r3, [r5, #1336]	; 0x538
			nrf_pin_configure(pins[i], NRF_GPIO_PIN_DIR_INPUT,
    5882:	e7e9      	b.n	5858 <pinctrl_configure_pins+0x102>
			NRF_PSEL_QSPI(reg, IO3) = NRF_GET_PIN(pins[i]);
    5884:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    5888:	f8c5 353c 	str.w	r3, [r5, #1340]	; 0x53c
    588c:	e7e4      	b.n	5858 <pinctrl_configure_pins+0x102>
		switch (NRF_GET_FUN(pins[i])) {
    588e:	f06f 0085 	mvn.w	r0, #133	; 0x85
    5892:	e768      	b.n	5766 <pinctrl_configure_pins+0x10>

00005894 <fprotect_set_permission>:

static int fprotect_set_permission(uint32_t start, size_t length,
				   size_t permission)
{
    5894:	b573      	push	{r0, r1, r4, r5, r6, lr}
    5896:	4605      	mov	r5, r0
	__ASSERT_NO_MSG(nrf_ficr_codepagesize_get(NRF_FICR) ==
			CONFIG_FPROTECT_BLOCK_SIZE);

	uint32_t region_idx;
	int result = find_free_region(&region_idx);
    5898:	a801      	add	r0, sp, #4
{
    589a:	460c      	mov	r4, r1
    589c:	4616      	mov	r6, r2
	int result = find_free_region(&region_idx);
    589e:	f7fc fd93 	bl	23c8 <find_free_region>

	if (result != 0) {
    58a2:	bb70      	cbnz	r0, 5902 <fprotect_set_permission+0x6e>
    58a4:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    58a8:	6919      	ldr	r1, [r3, #16]
		return result;
	}

	if (start % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
    58aa:	fbb5 f2f1 	udiv	r2, r5, r1
    58ae:	fb01 5212 	mls	r2, r1, r2, r5
    58b2:	bb42      	cbnz	r2, 5906 <fprotect_set_permission+0x72>
    58b4:	6919      	ldr	r1, [r3, #16]
	    length % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
    58b6:	fbb4 f2f1 	udiv	r2, r4, r1
    58ba:	fb01 4212 	mls	r2, r1, r2, r4
	if (start % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
    58be:	bb12      	cbnz	r2, 5906 <fprotect_set_permission+0x72>
    58c0:	691a      	ldr	r2, [r3, #16]
NRF_STATIC_INLINE uint32_t nrf_ficr_codesize_get(NRF_FICR_Type const * p_reg)
{
#if defined(FICR_INFO_CODESIZE_CODESIZE_Msk)
    return p_reg->INFO.CODESIZE;
#else
    return p_reg->CODESIZE;
    58c2:	695b      	ldr	r3, [r3, #20]
	    length > NRF_ACL_REGION_SIZE_MAX || length == 0) {
    58c4:	4353      	muls	r3, r2
	    length % nrf_ficr_codepagesize_get(NRF_FICR) != 0 ||
    58c6:	42a3      	cmp	r3, r4
    58c8:	d31d      	bcc.n	5906 <fprotect_set_permission+0x72>
	    length > NRF_ACL_REGION_SIZE_MAX || length == 0) {
    58ca:	b1e4      	cbz	r4, 5906 <fprotect_set_permission+0x72>
		return -EINVAL;
	}

	nrf_acl_region_set(NRF_ACL, region_idx, start, length, permission);
    58cc:	9b01      	ldr	r3, [sp, #4]
    p_reg->ACL[region_id].ADDR = address;
    58ce:	011b      	lsls	r3, r3, #4
    58d0:	f103 4180 	add.w	r1, r3, #1073741824	; 0x40000000
    58d4:	f501 31f0 	add.w	r1, r1, #122880	; 0x1e000
    58d8:	f8c1 5800 	str.w	r5, [r1, #2048]	; 0x800
    p_reg->ACL[region_id].SIZE = size;
    58dc:	f8c1 4804 	str.w	r4, [r1, #2052]	; 0x804
    p_reg->ACL[region_id].PERM = perm;
    58e0:	f8c1 6808 	str.w	r6, [r1, #2056]	; 0x808
    return (uint32_t)p_reg->ACL[region_id].ADDR;
    58e4:	f8d1 2800 	ldr.w	r2, [r1, #2048]	; 0x800

	if ((nrf_acl_region_address_get(NRF_ACL, region_idx) != start)
    58e8:	4295      	cmp	r5, r2
    58ea:	d10f      	bne.n	590c <fprotect_set_permission+0x78>
    return (size_t)p_reg->ACL[region_id].SIZE;
    58ec:	f8d1 2804 	ldr.w	r2, [r1, #2052]	; 0x804
		|| (nrf_acl_region_size_get(NRF_ACL, region_idx) != length)
    58f0:	4294      	cmp	r4, r2
    58f2:	d10b      	bne.n	590c <fprotect_set_permission+0x78>
    return (nrf_acl_perm_t)p_reg->ACL[region_id].PERM;
    58f4:	f8d1 3808 	ldr.w	r3, [r1, #2056]	; 0x808
		|| (nrf_acl_region_perm_get(NRF_ACL, region_idx) != permission)) {
    58f8:	b2db      	uxtb	r3, r3
		return -EFAULT;
    58fa:	42b3      	cmp	r3, r6
    58fc:	bf18      	it	ne
    58fe:	f06f 000d 	mvnne.w	r0, #13
	}

	return 0;
}
    5902:	b002      	add	sp, #8
    5904:	bd70      	pop	{r4, r5, r6, pc}
		return -EINVAL;
    5906:	f06f 0015 	mvn.w	r0, #21
    590a:	e7fa      	b.n	5902 <fprotect_set_permission+0x6e>
		return -EFAULT;
    590c:	f06f 000d 	mvn.w	r0, #13
    5910:	e7f7      	b.n	5902 <fprotect_set_permission+0x6e>

00005912 <fprotect_area>:
}
#endif

int fprotect_area(uint32_t start, size_t length)
{
	return fprotect_set_permission(start, length,
    5912:	2202      	movs	r2, #2
    5914:	f7ff bfbe 	b.w	5894 <fprotect_set_permission>

00005918 <hw_cc3xx_init_internal>:

	/* Initialize the cc3xx HW with or without RNG support */
#if CONFIG_ENTROPY_CC3XX
	res = nrf_cc3xx_platform_init();
#else
	res = nrf_cc3xx_platform_init_no_rng();
    5918:	f7fd bc48 	b.w	31ac <nrf_cc3xx_platform_init_no_rng>

0000591c <hw_cc3xx_init>:

	return res;
}

static int hw_cc3xx_init(const struct device *dev)
{
    591c:	b508      	push	{r3, lr}
	int res;

	/* Set the RTOS abort APIs */
	nrf_cc3xx_platform_abort_init();
    591e:	f7fb fb27 	bl	f70 <nrf_cc3xx_platform_abort_init>

	/* Set the RTOS mutex APIs */
	nrf_cc3xx_platform_mutex_init();
    5922:	f7ff fd52 	bl	53ca <nrf_cc3xx_platform_mutex_init>

	/* Enable the hardware */
	res = hw_cc3xx_init_internal(dev);
	return res;
}
    5926:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	res = nrf_cc3xx_platform_init_no_rng();
    592a:	f7fd bc3f 	b.w	31ac <nrf_cc3xx_platform_init_no_rng>

0000592e <bootutil_buffer_is_erased.part.0>:
bool bootutil_buffer_is_erased(const struct flash_area *area,
    592e:	b538      	push	{r3, r4, r5, lr}
    5930:	460c      	mov	r4, r1
    5932:	4615      	mov	r5, r2
    5934:	4425      	add	r5, r4
    erased_val = flash_area_erased_val(area);
    5936:	f7ff fd20 	bl	537a <flash_area_erased_val>
    for (i = 0, u8b = (uint8_t *)buffer; i < len; i++) {
    593a:	4621      	mov	r1, r4
    593c:	42a9      	cmp	r1, r5
    593e:	d101      	bne.n	5944 <bootutil_buffer_is_erased.part.0+0x16>
    return true;
    5940:	2001      	movs	r0, #1
}
    5942:	bd38      	pop	{r3, r4, r5, pc}
        if (u8b[i] != erased_val) {
    5944:	f811 3b01 	ldrb.w	r3, [r1], #1
    5948:	4298      	cmp	r0, r3
    594a:	d0f7      	beq.n	593c <bootutil_buffer_is_erased.part.0+0xe>
            return false;
    594c:	2000      	movs	r0, #0
    594e:	e7f8      	b.n	5942 <bootutil_buffer_is_erased.part.0+0x14>

00005950 <boot_swap_info_off>:
    return ALIGN_DOWN(boot_magic_off(fap) - BOOT_MAX_ALIGN, BOOT_MAX_ALIGN);
    5950:	6880      	ldr	r0, [r0, #8]
    5952:	3818      	subs	r0, #24
    5954:	f020 0007 	bic.w	r0, r0, #7
}
    5958:	3810      	subs	r0, #16
    595a:	4770      	bx	lr

0000595c <boot_magic_compatible_check>:
    switch (tbl_val) {
    595c:	2804      	cmp	r0, #4
    595e:	d009      	beq.n	5974 <boot_magic_compatible_check+0x18>
    5960:	2805      	cmp	r0, #5
    5962:	d103      	bne.n	596c <boot_magic_compatible_check+0x10>
        return val != BOOT_MAGIC_GOOD;
    5964:	1e48      	subs	r0, r1, #1
    5966:	bf18      	it	ne
    5968:	2001      	movne	r0, #1
    596a:	4770      	bx	lr
        return tbl_val == val;
    596c:	1a43      	subs	r3, r0, r1
    596e:	4258      	negs	r0, r3
    5970:	4158      	adcs	r0, r3
    5972:	4770      	bx	lr
    switch (tbl_val) {
    5974:	2001      	movs	r0, #1
}
    5976:	4770      	bx	lr

00005978 <bootutil_buffer_is_erased>:
    if (buffer == NULL || len == 0) {
    5978:	b111      	cbz	r1, 5980 <bootutil_buffer_is_erased+0x8>
    597a:	b10a      	cbz	r2, 5980 <bootutil_buffer_is_erased+0x8>
    597c:	f7ff bfd7 	b.w	592e <bootutil_buffer_is_erased.part.0>
}
    5980:	2000      	movs	r0, #0
    5982:	4770      	bx	lr

00005984 <boot_read_flag>:
{
    5984:	b538      	push	{r3, r4, r5, lr}
    5986:	460c      	mov	r4, r1
    rc = flash_area_read(fap, off, flag, sizeof *flag);
    5988:	2301      	movs	r3, #1
{
    598a:	4611      	mov	r1, r2
    rc = flash_area_read(fap, off, flag, sizeof *flag);
    598c:	4622      	mov	r2, r4
{
    598e:	4605      	mov	r5, r0
    rc = flash_area_read(fap, off, flag, sizeof *flag);
    5990:	f7ff fc9b 	bl	52ca <flash_area_read>
    if (rc < 0) {
    5994:	2800      	cmp	r0, #0
    5996:	db10      	blt.n	59ba <boot_read_flag+0x36>
    if (bootutil_buffer_is_erased(fap, flag, sizeof *flag)) {
    5998:	2201      	movs	r2, #1
    599a:	4621      	mov	r1, r4
    599c:	4628      	mov	r0, r5
    599e:	f7ff ffeb 	bl	5978 <bootutil_buffer_is_erased>
    59a2:	b118      	cbz	r0, 59ac <boot_read_flag+0x28>
        *flag = BOOT_FLAG_UNSET;
    59a4:	2303      	movs	r3, #3
    59a6:	7023      	strb	r3, [r4, #0]
    return 0;
    59a8:	2000      	movs	r0, #0
}
    59aa:	bd38      	pop	{r3, r4, r5, pc}
    if (flag != BOOT_FLAG_SET) {
    59ac:	7823      	ldrb	r3, [r4, #0]
        return BOOT_FLAG_BAD;
    59ae:	2b01      	cmp	r3, #1
    59b0:	bf0c      	ite	eq
    59b2:	2301      	moveq	r3, #1
    59b4:	2302      	movne	r3, #2
        *flag = boot_flag_decode(*flag);
    59b6:	7023      	strb	r3, [r4, #0]
    59b8:	e7f7      	b.n	59aa <boot_read_flag+0x26>
        return BOOT_EFLASH;
    59ba:	2001      	movs	r0, #1
    59bc:	e7f5      	b.n	59aa <boot_read_flag+0x26>

000059be <boot_write_trailer>:
{
    59be:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
    59c2:	461d      	mov	r5, r3
    59c4:	4606      	mov	r6, r0
    59c6:	460f      	mov	r7, r1
    59c8:	4690      	mov	r8, r2
    align = flash_area_align(fap);
    59ca:	f7ff fccd 	bl	5368 <flash_area_align>
    align = ALIGN_UP(inlen, align);
    59ce:	1e6c      	subs	r4, r5, #1
    59d0:	4404      	add	r4, r0
    59d2:	4243      	negs	r3, r0
    59d4:	401c      	ands	r4, r3
    if (align > BOOT_MAX_ALIGN) {
    59d6:	2c08      	cmp	r4, #8
    59d8:	d81a      	bhi.n	5a10 <boot_write_trailer+0x52>
    erased_val = flash_area_erased_val(fap);
    59da:	4630      	mov	r0, r6
    59dc:	f7ff fccd 	bl	537a <flash_area_erased_val>
    memcpy(buf, inbuf, inlen);
    59e0:	462a      	mov	r2, r5
    erased_val = flash_area_erased_val(fap);
    59e2:	4681      	mov	r9, r0
    memcpy(buf, inbuf, inlen);
    59e4:	4641      	mov	r1, r8
    59e6:	4668      	mov	r0, sp
    59e8:	f7ff fd36 	bl	5458 <memcpy>
    memset(&buf[inlen], erased_val, align - inlen);
    59ec:	1b62      	subs	r2, r4, r5
    59ee:	4649      	mov	r1, r9
    59f0:	eb0d 0005 	add.w	r0, sp, r5
    59f4:	f7ff fd3b 	bl	546e <memset>
    rc = flash_area_write(fap, off, buf, align);
    59f8:	4623      	mov	r3, r4
    59fa:	466a      	mov	r2, sp
    59fc:	4639      	mov	r1, r7
    59fe:	4630      	mov	r0, r6
    5a00:	f7ff fc7f 	bl	5302 <flash_area_write>
    if (rc != 0) {
    5a04:	3800      	subs	r0, #0
    5a06:	bf18      	it	ne
    5a08:	2001      	movne	r0, #1
}
    5a0a:	b003      	add	sp, #12
    5a0c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
        return -1;
    5a10:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    5a14:	e7f9      	b.n	5a0a <boot_write_trailer+0x4c>

00005a16 <boot_write_trailer_flag>:
{
    5a16:	b507      	push	{r0, r1, r2, lr}
    return boot_write_trailer(fap, off, buf, 1);
    5a18:	2301      	movs	r3, #1
    const uint8_t buf[1] = { flag_val };
    5a1a:	f88d 2004 	strb.w	r2, [sp, #4]
    return boot_write_trailer(fap, off, buf, 1);
    5a1e:	aa01      	add	r2, sp, #4
    5a20:	f7ff ffcd 	bl	59be <boot_write_trailer>
}
    5a24:	b003      	add	sp, #12
    5a26:	f85d fb04 	ldr.w	pc, [sp], #4

00005a2a <boot_write_image_ok>:
    return ALIGN_DOWN(boot_magic_off(fap) - BOOT_MAX_ALIGN, BOOT_MAX_ALIGN);
    5a2a:	6881      	ldr	r1, [r0, #8]
    5a2c:	3918      	subs	r1, #24
    return boot_write_trailer_flag(fap, off, BOOT_FLAG_SET);
    5a2e:	2201      	movs	r2, #1
    5a30:	f021 0107 	bic.w	r1, r1, #7
    5a34:	f7ff bfef 	b.w	5a16 <boot_write_trailer_flag>

00005a38 <boot_read_image_ok>:
    return ALIGN_DOWN(boot_magic_off(fap) - BOOT_MAX_ALIGN, BOOT_MAX_ALIGN);
    5a38:	6882      	ldr	r2, [r0, #8]
    5a3a:	3a18      	subs	r2, #24
    return boot_read_flag(fap, image_ok, boot_image_ok_off(fap));
    5a3c:	f022 0207 	bic.w	r2, r2, #7
    5a40:	f7ff bfa0 	b.w	5984 <boot_read_flag>

00005a44 <boot_read_swap_state_by_id>:
{
    5a44:	b513      	push	{r0, r1, r4, lr}
    5a46:	460c      	mov	r4, r1
    rc = flash_area_open(flash_area_id, &fap);
    5a48:	b2c0      	uxtb	r0, r0
    5a4a:	a901      	add	r1, sp, #4
    5a4c:	f7fb fa3e 	bl	ecc <flash_area_open>
    if (rc != 0) {
    5a50:	b950      	cbnz	r0, 5a68 <boot_read_swap_state_by_id+0x24>
    rc = boot_read_swap_state(fap, state);
    5a52:	4621      	mov	r1, r4
    5a54:	9801      	ldr	r0, [sp, #4]
    5a56:	f7fc fcf5 	bl	2444 <boot_read_swap_state>
    5a5a:	4604      	mov	r4, r0
    flash_area_close(fap);
    5a5c:	9801      	ldr	r0, [sp, #4]
    5a5e:	f7ff fc33 	bl	52c8 <flash_area_close>
}
    5a62:	4620      	mov	r0, r4
    5a64:	b002      	add	sp, #8
    5a66:	bd10      	pop	{r4, pc}
        return BOOT_EFLASH;
    5a68:	2401      	movs	r4, #1
    5a6a:	e7fa      	b.n	5a62 <boot_read_swap_state_by_id+0x1e>

00005a6c <boot_write_swap_info>:
{
    5a6c:	b513      	push	{r0, r1, r4, lr}
    BOOT_SET_SWAP_INFO(swap_info, image_num, swap_type);
    5a6e:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
{
    5a72:	4604      	mov	r4, r0
    BOOT_SET_SWAP_INFO(swap_info, image_num, swap_type);
    5a74:	f88d 2007 	strb.w	r2, [sp, #7]
    off = boot_swap_info_off(fap);
    5a78:	f7ff ff6a 	bl	5950 <boot_swap_info_off>
    return boot_write_trailer(fap, off, (const uint8_t *) &swap_info, 1);
    5a7c:	2301      	movs	r3, #1
    off = boot_swap_info_off(fap);
    5a7e:	4601      	mov	r1, r0
    return boot_write_trailer(fap, off, (const uint8_t *) &swap_info, 1);
    5a80:	f10d 0207 	add.w	r2, sp, #7
    5a84:	4620      	mov	r0, r4
    5a86:	f7ff ff9a 	bl	59be <boot_write_trailer>
}
    5a8a:	b002      	add	sp, #8
    5a8c:	bd10      	pop	{r4, pc}

00005a8e <nrf52_errata_136>:
            uint32_t var1 = *(uint32_t *)0x10000130ul;
    5a8e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
            if (var1 == 0x08)
    5a92:	f8d3 0130 	ldr.w	r0, [r3, #304]	; 0x130
}
    5a96:	f1a0 0308 	sub.w	r3, r0, #8
    5a9a:	4258      	negs	r0, r3
    5a9c:	4158      	adcs	r0, r3
    5a9e:	4770      	bx	lr

00005aa0 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(const void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
    5aa0:	4700      	bx	r0

00005aa2 <nrfx_busy_wait>:
    5aa2:	f000 b8a3 	b.w	5bec <z_impl_k_busy_wait>

00005aa6 <nrfx_clock_enable>:
{
    5aa6:	b508      	push	{r3, lr}
    priority = NRFX_CLOCK_DEFAULT_CONFIG_IRQ_PRIORITY;
#else
    #error "This code is not supposed to be compiled when neither POWER nor CLOCK is enabled."
#endif

    if (!NRFX_IRQ_IS_ENABLED(nrfx_get_irq_number(NRF_CLOCK)))
    5aa8:	2000      	movs	r0, #0
    5aaa:	f7fb fa9b 	bl	fe4 <arch_irq_is_enabled>
    5aae:	b908      	cbnz	r0, 5ab4 <nrfx_clock_enable+0xe>
    {
        NRFX_IRQ_PRIORITY_SET(nrfx_get_irq_number(NRF_CLOCK), priority);
        NRFX_IRQ_ENABLE(nrfx_get_irq_number(NRF_CLOCK));
    5ab0:	f7fb fa74 	bl	f9c <arch_irq_enable>
    p_reg->LFCLKSRC = (uint32_t)(source);
    5ab4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    5ab8:	2200      	movs	r2, #0
    5aba:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
    5abe:	bd08      	pop	{r3, pc}

00005ac0 <nrfx_clock_start>:
{
    5ac0:	b508      	push	{r3, lr}
    switch (domain)
    5ac2:	b110      	cbz	r0, 5aca <nrfx_clock_start+0xa>
    5ac4:	2801      	cmp	r0, #1
    5ac6:	d02d      	beq.n	5b24 <nrfx_clock_start+0x64>
}
    5ac8:	bd08      	pop	{r3, pc}
                    (nrf_clock_lfclk_t)((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_SRC_Msk)
    5aca:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    5ace:	f8d2 1418 	ldr.w	r1, [r2, #1048]	; 0x418
            if ((p_reg->LFCLKSTAT & CLOCK_LFCLKSTAT_STATE_Msk)
    5ad2:	f8d2 3418 	ldr.w	r3, [r2, #1048]	; 0x418
    5ad6:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
    5ada:	d10b      	bne.n	5af4 <nrfx_clock_start+0x34>
            return ((p_reg->LFCLKRUN & CLOCK_LFCLKRUN_STATUS_Msk)
    5adc:	f8d2 1414 	ldr.w	r1, [r2, #1044]	; 0x414
                else if (nrf_clock_start_task_check(NRF_CLOCK, NRF_CLOCK_DOMAIN_LFCLK))
    5ae0:	07c9      	lsls	r1, r1, #31
    5ae2:	d510      	bpl.n	5b06 <nrfx_clock_start+0x46>
    return (nrf_clock_lfclk_t)((p_reg->LFCLKSRCCOPY & CLOCK_LFCLKSRCCOPY_SRC_Msk)
    5ae4:	f8d2 341c 	ldr.w	r3, [r2, #1052]	; 0x41c
    if (!is_correct_clk)
    5ae8:	079b      	lsls	r3, r3, #30
    5aea:	d408      	bmi.n	5afe <nrfx_clock_start+0x3e>
    p_reg->INTENSET = mask;
    5aec:	2302      	movs	r3, #2
    5aee:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
                        break;
    5af2:	e7e9      	b.n	5ac8 <nrfx_clock_start+0x8>
                                        >> CLOCK_LFCLKSTAT_SRC_Pos);
    5af4:	f001 0303 	and.w	r3, r1, #3
    is_correct_clk = is_correct_clk || (*p_lfclksrc == NRF_CLOCK_LFCLK_RC);
    5af8:	2b01      	cmp	r3, #1
    5afa:	d004      	beq.n	5b06 <nrfx_clock_start+0x46>
    if (!is_correct_clk)
    5afc:	b11b      	cbz	r3, 5b06 <nrfx_clock_start+0x46>
        clock_stop(NRF_CLOCK_DOMAIN_LFCLK);
    5afe:	2000      	movs	r0, #0
    5b00:	f7fc fe50 	bl	27a4 <clock_stop>
        *p_lfclksrc = clock_initial_lfclksrc_get();
    5b04:	2300      	movs	r3, #0
    p_reg->LFCLKSRC = (uint32_t)(source);
    5b06:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
    5b0a:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    5b0e:	2300      	movs	r3, #0
    5b10:	f8c2 3104 	str.w	r3, [r2, #260]	; 0x104
    5b14:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
    p_reg->INTENSET = mask;
    5b18:	2302      	movs	r3, #2
    5b1a:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    5b1e:	2301      	movs	r3, #1
    5b20:	6093      	str	r3, [r2, #8]
}
    5b22:	e7d1      	b.n	5ac8 <nrfx_clock_start+0x8>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
    5b24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    5b28:	2200      	movs	r2, #0
    5b2a:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
    5b2e:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
    p_reg->INTENSET = mask;
    5b32:	f8c3 0304 	str.w	r0, [r3, #772]	; 0x304
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
    5b36:	6018      	str	r0, [r3, #0]
}
    5b38:	e7c6      	b.n	5ac8 <nrfx_clock_start+0x8>

00005b3a <nrfx_clock_stop>:
    clock_stop(domain);
    5b3a:	f7fc be33 	b.w	27a4 <clock_stop>

00005b3e <nrfx_nvmc_flash_size_get>:
    return p_reg->CODEPAGESIZE;
    5b3e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    5b42:	691a      	ldr	r2, [r3, #16]
    return p_reg->CODESIZE;
    5b44:	6958      	ldr	r0, [r3, #20]
}

uint32_t nrfx_nvmc_flash_size_get(void)
{
    return flash_total_size_get();
}
    5b46:	4350      	muls	r0, r2
    5b48:	4770      	bx	lr

00005b4a <nrfx_nvmc_flash_page_size_get>:
    return p_reg->CODEPAGESIZE;
    5b4a:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    5b4e:	6918      	ldr	r0, [r3, #16]

uint32_t nrfx_nvmc_flash_page_size_get(void)
{
    return flash_page_size_get();
}
    5b50:	4770      	bx	lr

00005b52 <nrfx_nvmc_flash_page_count_get>:
    return p_reg->CODESIZE;
    5b52:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
    5b56:	6958      	ldr	r0, [r3, #20]

uint32_t nrfx_nvmc_flash_page_count_get(void)
{
    return flash_page_count_get();
}
    5b58:	4770      	bx	lr

00005b5a <nrf_gpio_cfg_default>:
{
    5b5a:	b507      	push	{r0, r1, r2, lr}
    5b5c:	9001      	str	r0, [sp, #4]
    NRF_GPIO_Type * reg = nrf_gpio_pin_port_decode(&pin_number);
    5b5e:	a801      	add	r0, sp, #4
    5b60:	f7fc fef2 	bl	2948 <nrf_gpio_pin_port_decode>
    reg->PIN_CNF[pin_number] = cnf;
    5b64:	9b01      	ldr	r3, [sp, #4]
    5b66:	f503 73e0 	add.w	r3, r3, #448	; 0x1c0
    5b6a:	2202      	movs	r2, #2
    5b6c:	f840 2023 	str.w	r2, [r0, r3, lsl #2]
}
    5b70:	b003      	add	sp, #12
    5b72:	f85d fb04 	ldr.w	pc, [sp], #4

00005b76 <nrfx_qspi_write>:
    return qspi_xfer((void *)p_tx_buffer, tx_buffer_length, dst_address, NRFX_QSPI_STATE_WRITE);
    5b76:	2302      	movs	r3, #2
    5b78:	f7fc bef4 	b.w	2964 <qspi_xfer>

00005b7c <nrfx_qspi_read>:
    return qspi_xfer((void *)p_rx_buffer, rx_buffer_length, src_address, NRFX_QSPI_STATE_READ);
    5b7c:	2303      	movs	r3, #3
    5b7e:	f7fc bef1 	b.w	2964 <qspi_xfer>

00005b82 <nrfx_qspi_chip_erase>:
    return nrfx_qspi_erase(NRF_QSPI_ERASE_LEN_ALL, 0);
    5b82:	2100      	movs	r1, #0
    5b84:	2002      	movs	r0, #2
    5b86:	f7fd b969 	b.w	2e5c <nrfx_qspi_erase>

00005b8a <z_device_state_init>:
}
    5b8a:	4770      	bx	lr

00005b8c <z_device_is_ready>:
{
	/*
	 * if an invalid device pointer is passed as argument, this call
	 * reports the `device` as not ready for usage.
	 */
	if (dev == NULL) {
    5b8c:	b138      	cbz	r0, 5b9e <z_device_is_ready+0x12>
		return false;
	}

	return dev->state->initialized && (dev->state->init_res == 0U);
    5b8e:	68c3      	ldr	r3, [r0, #12]
    5b90:	8818      	ldrh	r0, [r3, #0]
    5b92:	f3c0 0008 	ubfx	r0, r0, #0, #9
    5b96:	f5a0 7380 	sub.w	r3, r0, #256	; 0x100
    5b9a:	4258      	negs	r0, r3
    5b9c:	4158      	adcs	r0, r3
}
    5b9e:	4770      	bx	lr

00005ba0 <arch_system_halt>:
	__asm__ volatile(
    5ba0:	f04f 0220 	mov.w	r2, #32
    5ba4:	f3ef 8311 	mrs	r3, BASEPRI
    5ba8:	f382 8812 	msr	BASEPRI_MAX, r2
    5bac:	f3bf 8f6f 	isb	sy
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
    5bb0:	e7fe      	b.n	5bb0 <arch_system_halt+0x10>

00005bb2 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
    5bb2:	b508      	push	{r3, lr}
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
    5bb4:	f7ff fff4 	bl	5ba0 <arch_system_halt>

00005bb8 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
    5bb8:	b510      	push	{r4, lr}
    5bba:	f04f 0320 	mov.w	r3, #32
    5bbe:	f3ef 8411 	mrs	r4, BASEPRI
    5bc2:	f383 8812 	msr	BASEPRI_MAX, r3
    5bc6:	f3bf 8f6f 	isb	sy
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
    5bca:	f7ff fff2 	bl	5bb2 <k_sys_fatal_error_handler>
	__asm__ volatile(
    5bce:	f384 8811 	msr	BASEPRI, r4
    5bd2:	f3bf 8f6f 	isb	sy
	arch_irq_unlock(key);

	if (IS_ENABLED(CONFIG_MULTITHREADING)) {
		k_thread_abort(thread);
	}
}
    5bd6:	bd10      	pop	{r4, pc}

00005bd8 <z_early_memset>:
	(void) memset(dst, c, n);
    5bd8:	f7ff bc49 	b.w	546e <memset>

00005bdc <z_early_memcpy>:
	(void) memcpy(dst, src, n);
    5bdc:	f7ff bc3c 	b.w	5458 <memcpy>

00005be0 <k_is_in_isr>:
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
    5be0:	f3ef 8005 	mrs	r0, IPSR
}

bool k_is_in_isr(void)
{
	return arch_is_in_isr();
}
    5be4:	3800      	subs	r0, #0
    5be6:	bf18      	it	ne
    5be8:	2001      	movne	r0, #1
    5bea:	4770      	bx	lr

00005bec <z_impl_k_busy_wait>:
#endif

void z_impl_k_busy_wait(uint32_t usec_to_wait)
{
	SYS_PORT_TRACING_FUNC_ENTER(k_thread, busy_wait, usec_to_wait);
	if (usec_to_wait == 0U) {
    5bec:	b108      	cbz	r0, 5bf2 <z_impl_k_busy_wait+0x6>
		if ((current_cycles - start_cycles) >= cycles_to_wait) {
			break;
		}
	}
#else
	arch_busy_wait(usec_to_wait);
    5bee:	f7fb bce9 	b.w	15c4 <arch_busy_wait>
#endif /* CONFIG_ARCH_HAS_CUSTOM_BUSY_WAIT */
	SYS_PORT_TRACING_FUNC_EXIT(k_thread, busy_wait, usec_to_wait);
}
    5bf2:	4770      	bx	lr

00005bf4 <boot_banner>:
#else
	printk("*** Booting Zephyr OS version %s %s ***\n",
	       KERNEL_VERSION_STRING, BOOT_DELAY_BANNER);
#endif
#endif
}
    5bf4:	4770      	bx	lr

00005bf6 <_OffsetAbsSyms>:

#include <gen_offset.h>

#include "offsets_aarch32.c"

GEN_ABS_SYM_END
    5bf6:	4770      	bx	lr

00005bf8 <nrf_cc310_bl_ecdsa_verify_secp256r1>:
    5bf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5bfc:	9f06      	ldr	r7, [sp, #24]
    5bfe:	4604      	mov	r4, r0
    5c00:	4615      	mov	r5, r2
    5c02:	461e      	mov	r6, r3
    5c04:	f7fd fc94 	bl	3530 <nrf_cc310_bl_ecdsa_verify_init_secp256r1>
    5c08:	b938      	cbnz	r0, 5c1a <nrf_cc310_bl_ecdsa_verify_secp256r1+0x22>
    5c0a:	463b      	mov	r3, r7
    5c0c:	4632      	mov	r2, r6
    5c0e:	4629      	mov	r1, r5
    5c10:	4620      	mov	r0, r4
    5c12:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    5c16:	f7fd bcb1 	b.w	357c <nrf_cc310_bl_ecdsa_verify_hash_secp256r1>
    5c1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

00005c1e <PkaInitAndMutexLock>:
    5c1e:	460a      	mov	r2, r1
    5c20:	2100      	movs	r1, #0
    5c22:	f7fd bf33 	b.w	3a8c <PkaInitPka>

00005c26 <SaSi_PalMemCopy>:
    5c26:	f7ff bc17 	b.w	5458 <memcpy>

00005c2a <SaSi_PalMemSet>:
    5c2a:	f7ff bc20 	b.w	546e <memset>

00005c2e <SaSi_PalMemSetZero>:
    5c2e:	460a      	mov	r2, r1
    5c30:	2100      	movs	r1, #0
    5c32:	f7ff bc1c 	b.w	546e <memset>

00005c36 <CRYS_COMMON_ReverseMemcpy32>:
    5c36:	eb01 0282 	add.w	r2, r1, r2, lsl #2
    5c3a:	3804      	subs	r0, #4
    5c3c:	428a      	cmp	r2, r1
    5c3e:	d101      	bne.n	5c44 <CRYS_COMMON_ReverseMemcpy32+0xe>
    5c40:	2000      	movs	r0, #0
    5c42:	4770      	bx	lr
    5c44:	f852 3d04 	ldr.w	r3, [r2, #-4]!
    5c48:	ba1b      	rev	r3, r3
    5c4a:	f840 3f04 	str.w	r3, [r0, #4]!
    5c4e:	e7f5      	b.n	5c3c <CRYS_COMMON_ReverseMemcpy32+0x6>

00005c50 <z_arm_platform_init>:
	 */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r0, =SystemInit
	bx r0
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	b SystemInit
    5c50:	f7fc bcb4 	b.w	25bc <SystemInit>
